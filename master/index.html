<!DOCTYPE html>
<!--
Welcome to a Clippy's lint list, at least the source code of it. If you are
interested in contributing to this website checkout `util/gh-pages/index_template.html`
inside the rust-clippy repository.

Otherwise, have a great day =^.^=
-->
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="A collection of lints to catch common mistakes and improve your Rust code."><title>Clippy Lints</title><link id="githubLightHighlight" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github.min.css" disabled="true" /><link id="githubDarkHighlight" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/github-dark.min.css" disabled="true" /><!-- The files are not copied over into the Clippy project since they use the MPL-2.0 License -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/rust-lang/mdBook@0.4.46/src/theme/css/variables.css"/><link id="styleHighlight" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/rust-lang/mdBook@0.4.46/src/theme/highlight.css"><link id="styleNight" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/rust-lang/mdBook@0.4.46/src/theme/tomorrow-night.css" disabled="true"><link id="styleAyu" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/rust-lang/mdBook@0.4.46/src/theme/ayu-highlight.css" disabled="true"><link rel="stylesheet" href="style.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/languages/rust.min.js" defer></script><script src="script.js" defer></script></head><body><div id="settings-dropdown" class="dropdown"><button class="settings-icon" tabindex="-1"></button><div class="settings-menu" tabindex="-1"><div class="setting-radio-name">Theme</div><select id="theme-choice"><option value="ayu">Ayu</option><option value="coal">Coal</option><option value="light">Light</option><option value="navy">Navy</option><option value="rust">Rust</option></select><label><input type="checkbox" id="disable-shortcuts"> <span>Disable keyboard shortcuts</span></label></div></div><script src="theme.js"></script><div class="container"><h1 class="page-header">Clippy Lints <span class="badge">Total number: 802</span></h1><noscript><div class="alert alert-danger" role="alert">Lints search and filtering only works with JS enabled. :(</div></noscript><div id="menu-filters"><div id="upper-filters"><div class="dropdown" data-filter="levels" tabindex="-1"><button type="button" class="btn-default dropdown-toggle">Lint levels <span id="levels-count" class="badge">4</span> <span class="caret"></span></button><ul class="dropdown-menu"><li class="checkbox"><button class="reset-all">All</button></li><li class="checkbox"><button class="reset-none">None</button></li><li role="separator" class="divider"></li><li class="checkbox"><label><input type="checkbox" name="allow" checked />Allow</label></li><li class="checkbox"><label><input type="checkbox" name="warn" checked />Warn</label></li><li class="checkbox"><label><input type="checkbox" name="deny" checked />Deny</label></li><li class="checkbox"><label><input type="checkbox" name="none" checked />None</label></li></ul></div><div class="dropdown" data-filter="groups" tabindex="-1"><button type="button" class="btn-default dropdown-toggle">Lint groups <span id="groups-count" class="badge">9</span> <span class="caret"></span></button><ul class="dropdown-menu"><li class="checkbox"><button class="reset-all">All</button></li><li class="checkbox"><button class="reset-default">Default</button></li><li class="checkbox"><button class="reset-none">None</button></li><li role="separator" class="divider"></li><li class="checkbox"><label><input type="checkbox" name="cargo" checked/>Cargo</label></li><li class="checkbox"><label><input type="checkbox" name="complexity" checked/>Complexity</label></li><li class="checkbox"><label><input type="checkbox" name="correctness" checked/>Correctness</label></li><li class="checkbox"><label><input type="checkbox" name="nursery" checked/>Nursery</label></li><li class="checkbox"><label><input type="checkbox" name="pedantic" checked/>Pedantic</label></li><li class="checkbox"><label><input type="checkbox" name="perf" checked/>Perf</label></li><li class="checkbox"><label><input type="checkbox" name="restriction" checked/>Restriction</label></li><li class="checkbox"><label><input type="checkbox" name="style" checked/>Style</label></li><li class="checkbox"><label><input type="checkbox" name="suspicious" checked/>Suspicious</label></li><li class="checkbox"><label><input type="checkbox" name="deprecated"/>Deprecated</label></li></ul></div><div id="version-filter" class="dropdown" tabindex="-1"><button type="button" class="btn-default dropdown-toggle">Version <span id="versions-count" class="badge">0</span> <span class="caret"></span></button><ul class="dropdown-menu"><li class="checkbox"><button id="reset-versions">Clear filters</button></li><li role="separator" class="divider"></li><li class="checkbox"><label>≥</label> <span>1.</span><input type="number" name="gte" min="29" maxlength="2" class="version-filter-input form-control filter-input" /><span>.0</span></li><li class="checkbox"><label>≤</label> <span>1.</span><input type="number" name="lte" min="29" maxlength="2" class="version-filter-input form-control filter-input" /><span>.0</span></li><li class="checkbox"><label>=</label> <span>1.</span><input type="number" name="eq" min="29" maxlength="2" class="version-filter-input form-control filter-input" /><span>.0</span></li></ul></div><div class="dropdown" data-filter="applicabilities" tabindex="-1"><button type="button" class="btn-default dropdown-toggle">Applicability <span id="applicabilities-count" class="badge">4</span> <span class="caret"></span></button><ul class="dropdown-menu"><li class="checkbox"><button class="reset-all">All</button></li><li class="checkbox"><button class="reset-none">None</button></li><li role="separator" class="divider"></li><li class="checkbox"><label><input type="checkbox" name="Unspecified" checked />Unspecified</label></li><li class="checkbox"><label><input type="checkbox" name="MachineApplicable" checked />MachineApplicable</label></li><li class="checkbox"><label><input type="checkbox" name="MaybeIncorrect" checked />MaybeIncorrect</label></li><li class="checkbox"><label><input type="checkbox" name="HasPlaceholders" checked />HasPlaceholders</label></li></ul></div></div><div class="search-control"><label class="input-group-addon" id="filter-label" for="search-input">Filter:</label><input type="text" class="form-control filter-input" placeholder="Keywords or search string (`S` or `/` to focus)" id="search-input" /><button id="filter-clear" type="button">Clear</button></div><div class="btn-group expansion-group"><button title="Collapse All" class="btn-default expansion-control" type="button" id="collapse-all"><span class="glyphicon glyphicon-collapse-up"></span></button><button title="Expand All" class="btn-default expansion-control" type="button" id="expand-all"><span class="glyphicon glyphicon-collapse-down"></span></button></div></div><article id="absolute_paths"><input id="label-absolute_paths" type="checkbox"><label for="label-absolute_paths"><h2 class="lint-title"><div class="panel-title-name" id="lint-absolute_paths">absolute_paths
<a href="#absolute_paths" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of items through absolute paths, like <code>std::env::current_dir</code>.</p>
<h3>Why restrict this?</h3>
<p>Many codebases have their own style when it comes to importing, but one that is seldom used
is using absolute paths <em>everywhere</em>. This is generally considered unidiomatic, and you
should add a <code>use</code> statement.</p>
<p>The default maximum segments (2) is pretty strict, you may want to increase this in
<code>clippy.toml</code>.</p>
<p>Note: One exception to this is code from macro expansion - this does not lint such cases, as
using absolute paths is the proper way of referencing items in one.</p>
<h3>Known issues</h3>
<p>There are currently a few cases which are not caught by this lint:</p>
<ul>
<li>Macro calls. e.g. <code>path::to::macro!()</code></li>
<li>Derive macros. e.g. <code>#[derive(path::to::macro)]</code></li>
<li>Attribute macros. e.g. <code>#[path::to::macro]</code></li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">let x = std::f64::consts::PI;
</code></pre>
<p>Use any of the below instead, or anything else:</p>
<pre><code class="language-rust">use std::f64;
use std::f64::consts;
use std::f64::consts::PI;
let x = f64::consts::PI;
let x = consts::PI;
let x = PI;
use std::f64::consts as f64_consts;
let x = f64_consts::PI;
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>absolute-paths-allowed-crates</code>:  Which crates to allow absolute paths from</p>
<p>(default: <code>[]</code>)</p>
</li>
<li>
<p><code>absolute-paths-max-segments</code>:  The maximum number of segments a path can have before being linted, anything above this will
be linted.</p>
<p>(default: <code>2</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13">View Source</a></div></div></div></article><article id="absurd_extreme_comparisons"><input id="label-absurd_extreme_comparisons" type="checkbox"><label for="label-absurd_extreme_comparisons"><h2 class="lint-title"><div class="panel-title-name" id="lint-absurd_extreme_comparisons">absurd_extreme_comparisons
<a href="#absurd_extreme_comparisons" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for comparisons where one side of the relation is
either the minimum or maximum value for its type and warns if it involves a
case that is always true or always false. Only integer and boolean types are
checked.</p>
<h3>Why is this bad?</h3>
<p>An expression like <code>min &lt;= x</code> may misleadingly imply
that it is possible for <code>x</code> to be less than the minimum. Expressions like
<code>max &lt; x</code> are probably mistakes.</p>
<h3>Known problems</h3>
<p>For <code>usize</code> the size of the current compile target will
be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such
a comparison to detect target pointer width will trigger this lint. One can
use <code>mem::sizeof</code> and compare its value or conditional compilation
attributes
like <code>#[cfg(target_pointer_width = "64")] ..</code> instead.</p>
<h3>Example</h3>
<pre><code class="language-rust">let vec: Vec&lt;isize&gt; = Vec::new();
if vec.len() &lt;= 0 {}
if 100 &gt; i32::MAX {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absurd_extreme_comparisons">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L37">View Source</a></div></div></div></article><article id="alloc_instead_of_core"><input id="label-alloc_instead_of_core" type="checkbox"><label for="label-alloc_instead_of_core"><h2 class="lint-title"><div class="panel-title-name" id="lint-alloc_instead_of_core">alloc_instead_of_core
<a href="#alloc_instead_of_core" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Finds items imported through <code>alloc</code> when available through <code>core</code>.</p>
<h3>Why restrict this?</h3>
<p>Crates which have <code>no_std</code> compatibility and may optionally require alloc may wish to ensure types are
imported from core to ensure disabling <code>alloc</code> does not cause the crate to fail to compile. This lint
is also useful for crates migrating to become <code>no_std</code> compatible.</p>
<h3>Known problems</h3>
<p>The lint is only partially aware of the required MSRV for items that were originally in <code>std</code> but moved
to <code>core</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">use alloc::slice::from_ref;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use core::slice::from_ref;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.64.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+alloc_instead_of_core">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/std_instead_of_core.rs#L61">View Source</a></div></div></div></article><article id="allow_attributes"><input id="label-allow_attributes" type="checkbox"><label for="label-allow_attributes"><h2 class="lint-title"><div class="panel-title-name" id="lint-allow_attributes">allow_attributes
<a href="#allow_attributes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of the <code>#[allow]</code> attribute and suggests replacing it with
the <code>#[expect]</code> attribute (See <a href="https://rust-lang.github.io/rfcs/2383-lint-reasons.html">RFC 2383</a>)</p>
<p>This lint only warns outer attributes (<code>#[allow]</code>), as inner attributes
(<code>#![allow]</code>) are usually used to enable or disable lints on a global scale.</p>
<h3>Why is this bad?</h3>
<p><code>#[expect]</code> attributes suppress the lint emission, but emit a warning, if
the expectation is unfulfilled. This can be useful to be notified when the
lint is no longer triggered.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[allow(unused_mut)]
fn foo() -&gt; usize {
    let mut a = Vec::new();
    a.len()
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[expect(unused_mut)]
fn foo() -&gt; usize {
    let mut a = Vec::new();
    a.len()
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+allow_attributes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/attrs/mod.rs#L207">View Source</a></div></div></div></article><article id="allow_attributes_without_reason"><input id="label-allow_attributes_without_reason" type="checkbox"><label for="label-allow_attributes_without_reason"><h2 class="lint-title"><div class="panel-title-name" id="lint-allow_attributes_without_reason">allow_attributes_without_reason
<a href="#allow_attributes_without_reason" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for attributes that allow lints without a reason.</p>
<h3>Why restrict this?</h3>
<p>Justifying each <code>allow</code> helps readers understand the reasoning,
and may allow removing <code>allow</code> attributes if their purpose is obsolete.</p>
<h3>Example</h3>
<pre><code class="language-rust">#![allow(clippy::some_lint)]
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#![allow(clippy::some_lint, reason = "False positive rust-lang/rust-clippy#1002020")]
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.61.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+allow_attributes_without_reason">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/attrs/mod.rs#L184">View Source</a></div></div></div></article><article id="almost_complete_range"><input id="label-almost_complete_range" type="checkbox"><label for="label-almost_complete_range"><h2 class="lint-title"><div class="panel-title-name" id="lint-almost_complete_range">almost_complete_range
<a href="#almost_complete_range" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for ranges which almost include the entire range of letters from ‘a’ to ‘z’
or digits from ‘0’ to ‘9’, but don’t because they’re a half open range.</p>
<h3>Why is this bad?</h3>
<p>This (<code>'a'..'z'</code>) is almost certainly a typo meant to include all letters.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = 'a'..'z';
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = 'a'..='z';
</code></pre>
<h3>Past names</h3>
<ul>
<li>almost_complete_letter_range</li>
</ul>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.68.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+almost_complete_range">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/almost_complete_range.rs#L10">View Source</a></div></div></div></article><article id="almost_swapped"><input id="label-almost_swapped" type="checkbox"><label for="label-almost_swapped"><h2 class="lint-title"><div class="panel-title-name" id="lint-almost_swapped">almost_swapped
<a href="#almost_swapped" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>foo = bar; bar = foo</code> sequences.</p>
<h3>Why is this bad?</h3>
<p>This looks like a failed attempt to swap.</p>
<h3>Example</h3>
<pre><code class="language-rust">a = b;
b = a;
</code></pre>
<p>If swapping is intended, use <code>swap()</code> instead:</p>
<pre><code class="language-rust">std::mem::swap(&amp;mut a, &amp;mut b);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+almost_swapped">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/swap.rs#L52">View Source</a></div></div></div></article><article id="approx_constant"><input id="label-approx_constant" type="checkbox"><label for="label-approx_constant"><h2 class="lint-title"><div class="panel-title-name" id="lint-approx_constant">approx_constant
<a href="#approx_constant" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for floating point literals that approximate
constants which are defined in
<a href="https://doc.rust-lang.org/stable/std/f32/consts/#constants"><code>std::f32::consts</code></a>
or
<a href="https://doc.rust-lang.org/stable/std/f64/consts/#constants"><code>std::f64::consts</code></a>,
respectively, suggesting to use the predefined constant.</p>
<h3>Why is this bad?</h3>
<p>Usually, the definition in the standard library is more
precise than what people come up with. If you find that your definition is
actually more precise, please <a href="https://github.com/rust-lang/rust/issues">file a Rust
issue</a>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = 3.14;
let y = 1_f64 / x;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = std::f32::consts::PI;
let y = std::f64::consts::FRAC_1_PI;
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+approx_constant">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/approx_const.rs#L11">View Source</a></div></div></div></article><article id="arbitrary_source_item_ordering"><input id="label-arbitrary_source_item_ordering" type="checkbox"><label for="label-arbitrary_source_item_ordering"><h2 class="lint-title"><div class="panel-title-name" id="lint-arbitrary_source_item_ordering">arbitrary_source_item_ordering
<a href="#arbitrary_source_item_ordering" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Confirms that items are sorted in source files as per configuration.</p>
<h3>Why restrict this?</h3>
<p>Keeping a consistent ordering throughout the codebase helps with working
as a team, and possibly improves maintainability of the codebase. The
idea is that by defining a consistent and enforceable rule for how
source files are structured, less time will be wasted during reviews on
a topic that is (under most circumstances) not relevant to the logic
implemented in the code. Sometimes this will be referred to as
“bikeshedding”.</p>
<p>The content of items with a representation clause attribute, such as
<code>#[repr(C)]</code> will not be checked, as the order of their fields or
variants might be dictated by an external API (application binary
interface).</p>
<h3>Default Ordering and Configuration</h3>
<p>As there is no generally applicable rule, and each project may have
different requirements, the lint can be configured with high
granularity. The configuration is split into two stages:</p>
<ol>
<li>Which item kinds that should have an internal order enforced.</li>
<li>Individual ordering rules per item kind.</li>
</ol>
<p>The item kinds that can be linted are:</p>
<ul>
<li>Module (with customized groupings, alphabetical within - configurable)</li>
<li>Trait (with customized order of associated items, alphabetical within)</li>
<li>Enum, Impl, Struct (purely alphabetical)</li>
</ul>
<h4>Module Item Order</h4>
<p>Due to the large variation of items within modules, the ordering can be
configured on a very granular level. Item kinds can be grouped together
arbitrarily, items within groups will be ordered alphabetically. The
following table shows the default groupings:</p>
<table class="table"><thead><tr><th>Group</th><th>Item Kinds</th></tr></thead><tbody>
<tr><td><code>modules</code></td><td>“mod”, “foreign_mod”</td></tr>
<tr><td><code>use</code></td><td>“use”</td></tr>
<tr><td><code>macros</code></td><td>“macro”</td></tr>
<tr><td><code>global_asm</code></td><td>“global_asm”</td></tr>
<tr><td><code>UPPER_SNAKE_CASE</code></td><td>“static”, “const”</td></tr>
<tr><td><code>PascalCase</code></td><td>“ty_alias”, “opaque_ty”, “enum”, “struct”, “union”, “trait”, “trait_alias”, “impl”</td></tr>
<tr><td><code>lower_snake_case</code></td><td>“fn”</td></tr>
</tbody></table>
<p>The groups’ names are arbitrary and can be changed to suit the
conventions that should be enforced for a specific project.</p>
<p>All item kinds must be accounted for to create an enforceable linting
rule set. Following are some example configurations that may be useful.</p>
<p>Example: <em>module inclusions and use statements to be at the top</em></p>
<pre><code class="language-toml">module-item-order-groupings = [
    [ "modules", [ "extern_crate", "mod", "foreign_mod" ], ],
    [ "use", [ "use", ], ],
    [ "everything_else", [ "macro", "global_asm", "static", "const", "ty_alias", "enum", "struct", "union", "trait", "trait_alias", "impl", "fn", ], ],
]
</code></pre>
<p>Example: <em>only consts and statics should be alphabetically ordered</em></p>
<p>It is also possible to configure a selection of module item groups that
should be ordered alphabetically. This may be useful if for example
statics and consts should be ordered, but the rest should be left open.</p>
<pre><code class="language-toml">module-items-ordered-within-groupings = ["UPPER_SNAKE_CASE"]
</code></pre>
<h3>Known Problems</h3>
<h4>Performance Impact</h4>
<p>Keep in mind, that ordering source code alphabetically can lead to
reduced performance in cases where the most commonly used enum variant
isn’t the first entry anymore, and similar optimizations that can reduce
branch misses, cache locality and such. Either don’t use this lint if
that’s relevant, or disable the lint in modules or items specifically
where it matters. Other solutions can be to use profile guided
optimization (PGO), post-link optimization (e.g. using BOLT for LLVM),
or other advanced optimization methods. A good starting point to dig
into optimization is <a href="https://github.com/Kobzol/cargo-pgo/blob/main/README.md">cargo-pgo</a>.</p>
<h4>Lints on a Contains basis</h4>
<p>The lint can be disabled only on a “contains” basis, but not per element
within a “container”, e.g. the lint works per-module, per-struct,
per-enum, etc. but not for “don’t order this particular enum variant”.</p>
<h4>Module documentation</h4>
<p>Module level rustdoc comments are not part of the resulting syntax tree
and as such cannot be linted from within <code>check_mod</code>. Instead, the
<code>rustdoc::missing_documentation</code> lint may be used.</p>
<h4>Module Tests</h4>
<p>This lint does not implement detection of module tests (or other feature
dependent elements for that matter). To lint the location of mod tests,
the lint <code>items_after_test_module</code> can be used instead.</p>
<h3>Example</h3>
<pre><code class="language-rust">trait TraitUnordered {
    const A: bool;
    const C: bool;
    const B: bool;

    type SomeType;

    fn a();
    fn c();
    fn b();
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">trait TraitOrdered {
    const A: bool;
    const B: bool;
    const C: bool;

    type SomeType;

    fn a();
    fn b();
    fn c();
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>module-item-order-groupings</code>:  The named groupings of different source item kinds within modules.</p>
<p>(default: <code>[["modules", ["extern_crate", "mod", "foreign_mod"]], ["use", ["use"]], ["macros", ["macro"]], ["global_asm", ["global_asm"]], ["UPPER_SNAKE_CASE", ["static", "const"]], ["PascalCase", ["ty_alias", "enum", "struct", "union", "trait", "trait_alias", "impl"]], ["lower_snake_case", ["fn"]]]</code>)</p>
</li>
<li>
<p><code>module-items-ordered-within-groupings</code>:  Whether the items within module groups should be ordered alphabetically or not.</p>
</li>
</ul>
<p>This option can be configured to “all”, “none”, or a list of specific grouping names that should be checked
(e.g. only “enums”).</p>
<p>(default: <code>"none"</code>)</p>
<ul>
<li>
<p><code>source-item-ordering</code>:  Which kind of elements should be ordered internally, possible values being <code>enum</code>, <code>impl</code>, <code>module</code>, <code>struct</code>, <code>trait</code>.</p>
<p>(default: <code>["enum", "impl", "module", "struct", "trait"]</code>)</p>
</li>
<li>
<p><code>trait-assoc-item-kinds-order</code>:  The order of associated items in traits.</p>
<p>(default: <code>["const", "type", "fn"]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.84.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+arbitrary_source_item_ordering">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/arbitrary_source_item_ordering.rs#L19">View Source</a></div></div></div></article><article id="arc_with_non_send_sync"><input id="label-arc_with_non_send_sync" type="checkbox"><label for="label-arc_with_non_send_sync"><h2 class="lint-title"><div class="panel-title-name" id="lint-arc_with_non_send_sync">arc_with_non_send_sync
<a href="#arc_with_non_send_sync" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does.</h3>
<p>This lint warns when you use <code>Arc</code> with a type that does not implement <code>Send</code> or <code>Sync</code>.</p>
<h3>Why is this bad?</h3>
<p><code>Arc&lt;T&gt;</code> is a thread-safe <code>Rc&lt;T&gt;</code> and guarantees that updates to the reference counter
use atomic operations. To send an <code>Arc&lt;T&gt;</code> across thread boundaries and
share ownership between multiple threads, <code>T</code> must be <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html#thread-safety">both <code>Send</code> and <code>Sync</code></a>,
so either <code>T</code> should be made <code>Send + Sync</code> or an <code>Rc</code> should be used instead of an <code>Arc</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">
fn main() {
    // This is fine, as `i32` implements `Send` and `Sync`.
    let a = Arc::new(42);

    // `RefCell` is `!Sync`, so either the `Arc` should be replaced with an `Rc`
    // or the `RefCell` replaced with something like a `RwLock`
    let b = Arc::new(RefCell::new(42));
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+arc_with_non_send_sync">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/arc_with_non_send_sync.rs#L13">View Source</a></div></div></div></article><article id="arithmetic_side_effects"><input id="label-arithmetic_side_effects" type="checkbox"><label for="label-arithmetic_side_effects"><h2 class="lint-title"><div class="panel-title-name" id="lint-arithmetic_side_effects">arithmetic_side_effects
<a href="#arithmetic_side_effects" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks any kind of arithmetic operation of any type.</p>
<p>Operators like <code>+</code>, <code>-</code>, <code>*</code> or <code>&lt;&lt;</code> are usually capable of overflowing according to the <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow">Rust
Reference</a>,
or can panic (<code>/</code>, <code>%</code>).</p>
<p>Known safe built-in types like <code>Wrapping</code> or <code>Saturating</code>, floats, operations in constant
environments, allowed types and non-constant operations that won’t overflow are ignored.</p>
<h3>Why restrict this?</h3>
<p>For integers, overflow will trigger a panic in debug builds or wrap the result in
release mode; division by zero will cause a panic in either mode. As a result, it is
desirable to explicitly call checked, wrapping or saturating arithmetic methods.</p>
<h4>Example</h4>
<pre><code class="language-rust">// `n` can be any number, including `i32::MAX`.
fn foo(n: i32) -&gt; i32 {
    n + 1
}
</code></pre>
<p>Third-party types can also overflow or present unwanted side-effects.</p>
<h4>Example</h4>
<pre><code class="language-rust">use rust_decimal::Decimal;
let _n = Decimal::MAX + Decimal::MAX;
</code></pre>
<h3>Past names</h3>
<ul>
<li>integer_arithmetic</li>
</ul>
<h3>Configuration</h3>
<ul>
<li><code>arithmetic-side-effects-allowed</code>:  Suppress checking of the passed type names in all types of operations.</li>
</ul>
<p>If a specific operation is desired, consider using <code>arithmetic_side_effects_allowed_binary</code> or <code>arithmetic_side_effects_allowed_unary</code> instead.</p>
<h4>Example</h4>
<pre><code class="language-toml">arithmetic-side-effects-allowed = ["SomeType", "AnotherType"]
</code></pre>
<h4>Noteworthy</h4>
<p>A type, say <code>SomeType</code>, listed in this configuration has the same behavior of
<code>["SomeType" , "*"], ["*", "SomeType"]</code> in <code>arithmetic_side_effects_allowed_binary</code>.</p>
<p>(default: <code>[]</code>)</p>
<ul>
<li><code>arithmetic-side-effects-allowed-binary</code>:  Suppress checking of the passed type pair names in binary operations like addition or
multiplication.</li>
</ul>
<p>Supports the “*” wildcard to indicate that a certain type won’t trigger the lint regardless
of the involved counterpart. For example, <code>["SomeType", "*"]</code> or <code>["*", "AnotherType"]</code>.</p>
<p>Pairs are asymmetric, which means that <code>["SomeType", "AnotherType"]</code> is not the same as
<code>["AnotherType", "SomeType"]</code>.</p>
<h4>Example</h4>
<pre><code class="language-toml">arithmetic-side-effects-allowed-binary = [["SomeType" , "f32"], ["AnotherType", "*"]]
</code></pre>
<p>(default: <code>[]</code>)</p>
<ul>
<li><code>arithmetic-side-effects-allowed-unary</code>:  Suppress checking of the passed type names in unary operations like “negation” (<code>-</code>).</li>
</ul>
<h4>Example</h4>
<pre><code class="language-toml">arithmetic-side-effects-allowed-unary = ["SomeType", "AnotherType"]
</code></pre>
<p>(default: <code>[]</code>)</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.64.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+arithmetic_side_effects">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L69">View Source</a></div></div></div></article><article id="as_conversions"><input id="label-as_conversions" type="checkbox"><label for="label-as_conversions"><h2 class="lint-title"><div class="panel-title-name" id="lint-as_conversions">as_conversions
<a href="#as_conversions" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>as</code> conversions.</p>
<p>Note that this lint is specialized in linting <em>every single</em> use of <code>as</code>
regardless of whether good alternatives exist or not. If you want more
precise lints for <code>as</code>, please consider using these separate lints:</p>
<ul>
<li><code>clippy::cast_lossless</code></li>
<li><code>clippy::cast_possible_truncation</code></li>
<li><code>clippy::cast_possible_wrap</code></li>
<li><code>clippy::cast_precision_loss</code></li>
<li><code>clippy::cast_sign_loss</code></li>
<li><code>clippy::char_lit_as_u8</code></li>
<li><code>clippy::fn_to_numeric_cast</code></li>
<li><code>clippy::fn_to_numeric_cast_with_truncation</code></li>
<li><code>clippy::ptr_as_ptr</code></li>
<li><code>clippy::unnecessary_cast</code></li>
<li><code>invalid_reference_casting</code></li>
</ul>
<p>There is a good explanation the reason why this lint should work in this
way and how it is useful <a href="https://github.com/rust-lang/rust-clippy/issues/5122">in this
issue</a>.</p>
<h3>Why restrict this?</h3>
<p><code>as</code> conversions will perform many kinds of
conversions, including silently lossy conversions and dangerous coercions.
There are cases when it makes sense to use <code>as</code>, so the lint is
Allow by default.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a: u32;
...
f(a as u16);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">f(a.try_into()?);

// or

f(a.try_into().expect("Unexpected u16 overflow in f"));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.41.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+as_conversions">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/as_conversions.rs#L7">View Source</a></div></div></div></article><article id="as_pointer_underscore"><input id="label-as_pointer_underscore" type="checkbox"><label for="label-as_pointer_underscore"><h2 class="lint-title"><div class="panel-title-name" id="lint-as_pointer_underscore">as_pointer_underscore
<a href="#as_pointer_underscore" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the usage of <code>as *const _</code> or <code>as *mut _</code> conversion using inferred type.</p>
<h3>Why restrict this?</h3>
<p>The conversion might include a dangerous cast that might go undetected due to the type being inferred.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn as_usize&lt;T&gt;(t: &amp;T) -&gt; usize {
    // BUG: `t` is already a reference, so we will here
    // return a dangling pointer to a temporary value instead
    &amp;t as *const _ as usize
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn as_usize&lt;T&gt;(t: &amp;T) -&gt; usize {
    t as *const T as usize
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.85.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+as_pointer_underscore">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L738">View Source</a></div></div></div></article><article id="as_ptr_cast_mut"><input id="label-as_ptr_cast_mut" type="checkbox"><label for="label-as_ptr_cast_mut"><h2 class="lint-title"><div class="panel-title-name" id="lint-as_ptr_cast_mut">as_ptr_cast_mut
<a href="#as_ptr_cast_mut" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the result of a <code>&amp;self</code>-taking <code>as_ptr</code> being cast to a mutable pointer.</p>
<h3>Why is this bad?</h3>
<p>Since <code>as_ptr</code> takes a <code>&amp;self</code>, the pointer won’t have write permissions unless interior
mutability is used, making it unlikely that having it as a mutable pointer is correct.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut vec = Vec::&lt;u8&gt;::with_capacity(1);
let ptr = vec.as_ptr() as *mut u8;
unsafe { ptr.write(4) }; // UNDEFINED BEHAVIOUR
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut vec = Vec::&lt;u8&gt;::with_capacity(1);
let ptr = vec.as_mut_ptr();
unsafe { ptr.write(4) };
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.66.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+as_ptr_cast_mut">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L643">View Source</a></div></div></div></article><article id="as_underscore"><input id="label-as_underscore" type="checkbox"><label for="label-as_underscore"><h2 class="lint-title"><div class="panel-title-name" id="lint-as_underscore">as_underscore
<a href="#as_underscore" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the usage of <code>as _</code> conversion using inferred type.</p>
<h3>Why restrict this?</h3>
<p>The conversion might include lossy conversion or a dangerous cast that might go
undetected due to the type being inferred.</p>
<p>The lint is allowed by default as using <code>_</code> is less wordy than always specifying the type.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(n: usize) {}
let n: u16 = 256;
foo(n as _);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo(n: usize) {}
let n: u16 = 256;
foo(n as usize);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.63.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+as_underscore">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L555">View Source</a></div></div></div></article><article id="assertions_on_constants"><input id="label-assertions_on_constants" type="checkbox"><label for="label-assertions_on_constants"><h2 class="lint-title"><div class="panel-title-name" id="lint-assertions_on_constants">assertions_on_constants
<a href="#assertions_on_constants" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>assert!(true)</code> and <code>assert!(false)</code> calls.</p>
<h3>Why is this bad?</h3>
<p>Will be optimized out by the compiler or should probably be replaced by a
<code>panic!()</code> or <code>unreachable!()</code></p>
<h3>Example</h3>
<pre><code class="language-rust">assert!(false)
assert!(true)
const B: bool = false;
assert!(B)
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.34.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+assertions_on_constants">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/assertions_on_constants.rs#L14">View Source</a></div></div></div></article><article id="assertions_on_result_states"><input id="label-assertions_on_result_states" type="checkbox"><label for="label-assertions_on_result_states"><h2 class="lint-title"><div class="panel-title-name" id="lint-assertions_on_result_states">assertions_on_result_states
<a href="#assertions_on_result_states" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>assert!(r.is_ok())</code> or <code>assert!(r.is_err())</code> calls.</p>
<h3>Why restrict this?</h3>
<p>This form of assertion does not show any of the information present in the <code>Result</code>
other than which variant it isn’t.</p>
<h3>Known problems</h3>
<p>The suggested replacement decreases the readability of code and log output.</p>
<h3>Example</h3>
<pre><code class="language-rust">assert!(r.is_ok());
assert!(r.is_err());
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">r.unwrap();
r.unwrap_err();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.64.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+assertions_on_result_states">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/assertions_on_result_states.rs#L15">View Source</a></div></div></div></article><article id="assign_op_pattern"><input id="label-assign_op_pattern" type="checkbox"><label for="label-assign_op_pattern"><h2 class="lint-title"><div class="panel-title-name" id="lint-assign_op_pattern">assign_op_pattern
<a href="#assign_op_pattern" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>a = a op b</code> or <code>a = b commutative_op a</code>
patterns.</p>
<h3>Why is this bad?</h3>
<p>These can be written as the shorter <code>a op= b</code>.</p>
<h3>Known problems</h3>
<p>While forbidden by the spec, <code>OpAssign</code> traits may have
implementations that differ from the regular <code>Op</code> impl.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut a = 5;
let b = 0;
// ...

a = a + b;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut a = 5;
let b = 0;
// ...

a += b;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+assign_op_pattern">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L125">View Source</a></div></div></div></article><article id="assign_ops"><input id="label-assign_ops" type="checkbox"><label for="label-assign_ops"><h2 class="lint-title"><div class="panel-title-name" id="lint-assign_ops">assign_ops
<a href="#assign_ops" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p>Compound operators are harmless and linting on them is not in scope for clippy.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">1.30.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+assign_ops">Related Issues</a></div></div></div></article><article id="assigning_clones"><input id="label-assigning_clones" type="checkbox"><label for="label-assigning_clones"><h2 class="lint-title"><div class="panel-title-name" id="lint-assigning_clones">assigning_clones
<a href="#assigning_clones" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for code like <code>foo = bar.clone();</code></p>
<h3>Why is this bad?</h3>
<p>Custom <code>Clone::clone_from()</code> or <code>ToOwned::clone_into</code> implementations allow the objects
to share resources and therefore avoid allocations.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Thing;

impl Clone for Thing {
    fn clone(&amp;self) -&gt; Self { todo!() }
    fn clone_from(&amp;mut self, other: &amp;Self) { todo!() }
}

pub fn assign_to_ref(a: &amp;mut Thing, b: Thing) {
    *a = b.clone();
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct Thing;

impl Clone for Thing {
    fn clone(&amp;self) -&gt; Self { todo!() }
    fn clone_from(&amp;mut self, other: &amp;Self) { todo!() }
}

pub fn assign_to_ref(a: &amp;mut Thing, b: Thing) {
    a.clone_from(&amp;b);
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.78.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+assigning_clones">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/assigning_clones.rs#L16">View Source</a></div></div></div></article><article id="async_yields_async"><input id="label-async_yields_async" type="checkbox"><label for="label-async_yields_async"><h2 class="lint-title"><div class="panel-title-name" id="lint-async_yields_async">async_yields_async
<a href="#async_yields_async" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for async blocks that yield values of types
that can themselves be awaited.</p>
<h3>Why is this bad?</h3>
<p>An await is likely missing.</p>
<h3>Example</h3>
<pre><code class="language-rust">async fn foo() {}

fn bar() {
  let x = async {
    foo()
  };
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">async fn foo() {}

fn bar() {
  let x = async {
    foo().await
  };
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.48.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+async_yields_async">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/async_yields_async.rs#L13">View Source</a></div></div></div></article><article id="await_holding_invalid_type"><input id="label-await_holding_invalid_type" type="checkbox"><label for="label-await_holding_invalid_type"><h2 class="lint-title"><div class="panel-title-name" id="lint-await_holding_invalid_type">await_holding_invalid_type
<a href="#await_holding_invalid_type" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Allows users to configure types which should not be held across await
suspension points.</p>
<h3>Why is this bad?</h3>
<p>There are some types which are perfectly safe to use concurrently from
a memory access perspective, but that will cause bugs at runtime if
they are held in such a way.</p>
<h3>Example</h3>
<pre><code class="language-toml">await-holding-invalid-types = [
  # You can specify a type name
  "CustomLockType",
  # You can (optionally) specify a reason
  { path = "OtherCustomLockType", reason = "Relies on a thread local" }
]
</code></pre>
<pre><code class="language-rust">struct CustomLockType;
struct OtherCustomLockType;
async fn foo() {
  let _x = CustomLockType;
  let _y = OtherCustomLockType;
  baz().await; // Lint violation
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>await-holding-invalid-types</code>:  The list of types which may not be held across an await point.</p>
<p>(default: <code>[]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+await_holding_invalid_type">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/await_holding_invalid.rs#L137">View Source</a></div></div></div></article><article id="await_holding_lock"><input id="label-await_holding_lock" type="checkbox"><label for="label-await_holding_lock"><h2 class="lint-title"><div class="panel-title-name" id="lint-await_holding_lock">await_holding_lock
<a href="#await_holding_lock" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>await</code> while holding a non-async-aware
<code>MutexGuard</code>.</p>
<h3>Why is this bad?</h3>
<p>The Mutex types found in <a href="https://doc.rust-lang.org/stable/std/sync/"><code>std::sync</code></a> and
<a href="https://docs.rs/parking_lot/latest/parking_lot/"><code>parking_lot</code></a> are
not designed to operate in an async context across await points.</p>
<p>There are two potential solutions. One is to use an async-aware <code>Mutex</code>
type. Many asynchronous foundation crates provide such a <code>Mutex</code> type.
The other solution is to ensure the mutex is unlocked before calling
<code>await</code>, either by introducing a scope or an explicit call to
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop::drop</code></a>.</p>
<h3>Known problems</h3>
<p>Will report false positive for explicitly dropped guards
(<a href="https://github.com/rust-lang/rust-clippy/issues/6446">#6446</a>). A
workaround for this is to wrap the <code>.lock()</code> call in a block instead of
explicitly dropping the guard.</p>
<h3>Example</h3>
<pre><code class="language-rust">async fn foo(x: &amp;Mutex&lt;u32&gt;) {
  let mut guard = x.lock().unwrap();
  *guard += 1;
  baz().await;
}

async fn bar(x: &amp;Mutex&lt;u32&gt;) {
  let mut guard = x.lock().unwrap();
  *guard += 1;
  drop(guard); // explicit drop
  baz().await;
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">async fn foo(x: &amp;Mutex&lt;u32&gt;) {
  {
    let mut guard = x.lock().unwrap();
    *guard += 1;
  }
  baz().await;
}

async fn bar(x: &amp;Mutex&lt;u32&gt;) {
  {
    let mut guard = x.lock().unwrap();
    *guard += 1;
  } // guard dropped here at end of scope
  baz().await;
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.45.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+await_holding_lock">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/await_holding_invalid.rs#L13">View Source</a></div></div></div></article><article id="await_holding_refcell_ref"><input id="label-await_holding_refcell_ref" type="checkbox"><label for="label-await_holding_refcell_ref"><h2 class="lint-title"><div class="panel-title-name" id="lint-await_holding_refcell_ref">await_holding_refcell_ref
<a href="#await_holding_refcell_ref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>await</code> while holding a <code>RefCell</code>, <code>Ref</code>, or <code>RefMut</code>.</p>
<h3>Why is this bad?</h3>
<p><code>RefCell</code> refs only check for exclusive mutable access
at runtime. Holding a <code>RefCell</code> ref across an await suspension point
risks panics from a mutable ref shared while other refs are outstanding.</p>
<h3>Known problems</h3>
<p>Will report false positive for explicitly dropped refs
(<a href="https://github.com/rust-lang/rust-clippy/issues/6353">#6353</a>). A workaround for this is
to wrap the <code>.borrow[_mut]()</code> call in a block instead of explicitly dropping the ref.</p>
<h3>Example</h3>
<pre><code class="language-rust">async fn foo(x: &amp;RefCell&lt;u32&gt;) {
  let mut y = x.borrow_mut();
  *y += 1;
  baz().await;
}

async fn bar(x: &amp;RefCell&lt;u32&gt;) {
  let mut y = x.borrow_mut();
  *y += 1;
  drop(y); // explicit drop
  baz().await;
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">async fn foo(x: &amp;RefCell&lt;u32&gt;) {
  {
     let mut y = x.borrow_mut();
     *y += 1;
  }
  baz().await;
}

async fn bar(x: &amp;RefCell&lt;u32&gt;) {
  {
    let mut y = x.borrow_mut();
    *y += 1;
  } // y dropped here at end of scope
  baz().await;
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+await_holding_refcell_ref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/await_holding_invalid.rs#L79">View Source</a></div></div></div></article><article id="bad_bit_mask"><input id="label-bad_bit_mask" type="checkbox"><label for="label-bad_bit_mask"><h2 class="lint-title"><div class="panel-title-name" id="lint-bad_bit_mask">bad_bit_mask
<a href="#bad_bit_mask" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for incompatible bit masks in comparisons.</p>
<p>The formula for detecting if an expression of the type <code>_ &lt;bit_op&gt; m &lt;cmp_op&gt; c</code> (where <code>&lt;bit_op&gt;</code> is one of {<code>&amp;</code>, <code>|</code>} and <code>&lt;cmp_op&gt;</code> is one of
{<code>!=</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>!=</code>, <code>&gt;=</code>, <code>&gt;</code>}) can be determined from the following
table:</p>
<table class="table"><thead><tr><th>Comparison</th><th>Bit Op</th><th>Example</th><th>is always</th><th>Formula</th></tr></thead><tbody>
<tr><td><code>==</code> or <code>!=</code></td><td><code>&amp;</code></td><td><code>x &amp; 2 == 3</code></td><td><code>false</code></td><td><code>c &amp; m != c</code></td></tr>
<tr><td><code>&lt;</code>  or <code>&gt;=</code></td><td><code>&amp;</code></td><td><code>x &amp; 2 &lt; 3</code></td><td><code>true</code></td><td><code>m &lt; c</code></td></tr>
<tr><td><code>&gt;</code>  or <code>&lt;=</code></td><td><code>&amp;</code></td><td><code>x &amp; 1 &gt; 1</code></td><td><code>false</code></td><td><code>m &lt;= c</code></td></tr>
<tr><td><code>==</code> or <code>!=</code></td><td><code>|</code></td><td><code>x | 1 == 0</code></td><td><code>false</code></td><td><code>c | m != c</code></td></tr>
<tr><td><code>&lt;</code>  or <code>&gt;=</code></td><td><code>|</code></td><td><code>x | 1 &lt; 1</code></td><td><code>false</code></td><td><code>m &gt;= c</code></td></tr>
<tr><td><code>&lt;=</code> or <code>&gt;</code></td><td><code>|</code></td><td><code>x | 1 &gt; 0</code></td><td><code>true</code></td><td><code>m &gt; c</code></td></tr>
</tbody></table>
<h3>Why is this bad?</h3>
<p>If the bits that the comparison cares about are always
set to zero or one by the bit mask, the comparison is constant <code>true</code> or
<code>false</code> (depending on mask, compared value, and operators).</p>
<p>So the code is actively misleading, and the only reason someone would write
this intentionally is to win an underhanded Rust contest or create a
test-case for this lint.</p>
<h3>Example</h3>
<pre><code class="language-rust">if (x &amp; 1 == 2) { }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+bad_bit_mask">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L187">View Source</a></div></div></div></article><article id="big_endian_bytes"><input id="label-big_endian_bytes" type="checkbox"><label for="label-big_endian_bytes"><h2 class="lint-title"><div class="panel-title-name" id="lint-big_endian_bytes">big_endian_bytes
<a href="#big_endian_bytes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the usage of the <code>to_be_bytes</code> method and/or the function <code>from_be_bytes</code>.</p>
<h3>Why restrict this?</h3>
<p>To ensure use of little-endian or the target’s endianness rather than big-endian.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _x = 2i32.to_be_bytes();
let _y = 2i64.to_be_bytes();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+big_endian_bytes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/endian_bytes.rs#L48">View Source</a></div></div></div></article><article id="bind_instead_of_map"><input id="label-bind_instead_of_map" type="checkbox"><label for="label-bind_instead_of_map"><h2 class="lint-title"><div class="panel-title-name" id="lint-bind_instead_of_map">bind_instead_of_map
<a href="#bind_instead_of_map" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>_.and_then(|x| Some(y))</code>, <code>_.and_then(|x| Ok(y))</code>
or <code>_.or_else(|x| Err(y))</code>.</p>
<h3>Why is this bad?</h3>
<p>This can be written more concisely as <code>_.map(|x| y)</code> or <code>_.map_err(|x| y)</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = opt().and_then(|s| Some(s.len()));
let _ = res().and_then(|s| if s.len() == 42 { Ok(10) } else { Ok(20) });
let _ = res().or_else(|s| if s.len() == 42 { Err(10) } else { Err(20) });
</code></pre>
<p>The correct use would be:</p>
<pre><code class="language-rust">let _ = opt().map(|s| s.len());
let _ = res().map(|s| if s.len() == 42 { 10 } else { 20 });
let _ = res().map_err(|s| if s.len() == 42 { 10 } else { 20 });
</code></pre>
<h3>Past names</h3>
<ul>
<li>option_and_then_some</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.45.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+bind_instead_of_map">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L655">View Source</a></div></div></div></article><article id="blanket_clippy_restriction_lints"><input id="label-blanket_clippy_restriction_lints" type="checkbox"><label for="label-blanket_clippy_restriction_lints"><h2 class="lint-title"><div class="panel-title-name" id="lint-blanket_clippy_restriction_lints">blanket_clippy_restriction_lints
<a href="#blanket_clippy_restriction_lints" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>warn</code>/<code>deny</code>/<code>forbid</code> attributes targeting the whole clippy::restriction category.</p>
<h3>Why is this bad?</h3>
<p>Restriction lints sometimes are in contrast with other lints or even go against idiomatic rust.
These lints should only be enabled on a lint-by-lint basis and with careful consideration.</p>
<h3>Example</h3>
<pre><code class="language-rust">#![deny(clippy::restriction)]
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#![deny(clippy::as_conversions)]
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.47.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+blanket_clippy_restriction_lints">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/attrs/mod.rs#L130">View Source</a></div></div></div></article><article id="blocks_in_conditions"><input id="label-blocks_in_conditions" type="checkbox"><label for="label-blocks_in_conditions"><h2 class="lint-title"><div class="panel-title-name" id="lint-blocks_in_conditions">blocks_in_conditions
<a href="#blocks_in_conditions" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>if</code> and <code>match</code> conditions that use blocks containing an
expression, statements or conditions that use closures with blocks.</p>
<h3>Why is this bad?</h3>
<p>Style, using blocks in the condition makes it hard to read.</p>
<h3>Examples</h3>
<pre><code class="language-rust">if { true } { /* ... */ }

if { let x = somefunc(); x } { /* ... */ }

match { let e = somefunc(); e } {
    // ...
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if true { /* ... */ }

let res = { let x = somefunc(); x };
if res { /* ... */ }

let res = { let e = somefunc(); e };
match res {
    // ...
}
</code></pre>
<h3>Past names</h3>
<ul>
<li>block_in_if_condition_expr</li>
<li>block_in_if_condition_stmt</li>
<li>blocks_in_if_conditions</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.45.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+blocks_in_conditions">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/blocks_in_conditions.rs#L9">View Source</a></div></div></div></article><article id="bool_assert_comparison"><input id="label-bool_assert_comparison" type="checkbox"><label for="label-bool_assert_comparison"><h2 class="lint-title"><div class="panel-title-name" id="lint-bool_assert_comparison">bool_assert_comparison
<a href="#bool_assert_comparison" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint warns about boolean comparisons in assert-like macros.</p>
<h3>Why is this bad?</h3>
<p>It is shorter to use the equivalent.</p>
<h3>Example</h3>
<pre><code class="language-rust">assert_eq!("a".is_empty(), false);
assert_ne!("a".is_empty(), true);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">assert!(!"a".is_empty());
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.53.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+bool_assert_comparison">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/bool_assert_comparison.rs#L15">View Source</a></div></div></div></article><article id="bool_comparison"><input id="label-bool_comparison" type="checkbox"><label for="label-bool_comparison"><h2 class="lint-title"><div class="panel-title-name" id="lint-bool_comparison">bool_comparison
<a href="#bool_comparison" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for expressions of the form <code>x == true</code>,
<code>x != true</code> and order comparisons such as <code>x &lt; true</code> (or vice versa) and
suggest using the variable directly.</p>
<h3>Why is this bad?</h3>
<p>Unnecessary code.</p>
<h3>Example</h3>
<pre><code class="language-rust">if x == true {}
if y == false {}
</code></pre>
<p>use <code>x</code> directly:</p>
<pre><code class="language-rust">if x {}
if !y {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+bool_comparison">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/bool_comparison.rs#L12">View Source</a></div></div></div></article><article id="bool_to_int_with_if"><input id="label-bool_to_int_with_if" type="checkbox"><label for="label-bool_to_int_with_if"><h2 class="lint-title"><div class="panel-title-name" id="lint-bool_to_int_with_if">bool_to_int_with_if
<a href="#bool_to_int_with_if" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Instead of using an if statement to convert a bool to an int,
this lint suggests using a <code>from()</code> function or an <code>as</code> coercion.</p>
<h3>Why is this bad?</h3>
<p>Coercion or <code>from()</code> is another way to convert bool to a number.
Both methods are guaranteed to return 1 for true, and 0 for false.</p>
<p>See https://doc.rust-lang.org/std/primitive.bool.html#impl-From%3Cbool%3E</p>
<h3>Example</h3>
<pre><code class="language-rust">if condition {
    1_i64
} else {
    0
};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">i64::from(condition);
</code></pre>
<p>or</p>
<pre><code class="language-rust">condition as i64;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.65.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+bool_to_int_with_if">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/bool_to_int_with_if.rs#L11">View Source</a></div></div></div></article><article id="borrow_as_ptr"><input id="label-borrow_as_ptr" type="checkbox"><label for="label-borrow_as_ptr"><h2 class="lint-title"><div class="panel-title-name" id="lint-borrow_as_ptr">borrow_as_ptr
<a href="#borrow_as_ptr" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the usage of <code>&amp;expr as *const T</code> or
<code>&amp;mut expr as *mut T</code>, and suggest using <code>&amp;raw const</code> or
<code>&amp;raw mut</code> instead.</p>
<h3>Why is this bad?</h3>
<p>This would improve readability and avoid creating a reference
that points to an uninitialized value or unaligned place.
Read the <code>&amp;raw</code> explanation in the Reference for more information.</p>
<h3>Example</h3>
<pre><code class="language-rust">let val = 1;
let p = &amp;val as *const i32;

let mut val_mut = 1;
let p_mut = &amp;mut val_mut as *mut i32;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let val = 1;
let p = &amp;raw const val;

let mut val_mut = 1;
let p_mut = &amp;raw mut val_mut;
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.60.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+borrow_as_ptr">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L583">View Source</a></div></div></div></article><article id="borrow_deref_ref"><input id="label-borrow_deref_ref" type="checkbox"><label for="label-borrow_deref_ref"><h2 class="lint-title"><div class="panel-title-name" id="lint-borrow_deref_ref">borrow_deref_ref
<a href="#borrow_deref_ref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>&amp;*(&amp;T)</code>.</p>
<h3>Why is this bad?</h3>
<p>Dereferencing and then borrowing a reference value has no effect in most cases.</p>
<h3>Known problems</h3>
<p>False negative on such code:</p>
<pre><code class="language-rust">let x = &amp;12;
let addr_x = &amp;x as *const _ as usize;
let addr_y = &amp;&amp;*x as *const _ as usize; // assert ok now, and lint triggered.
                                        // But if we fix it, assert will fail.
assert_ne!(addr_x, addr_y);
</code></pre>
<h3>Example</h3>
<pre><code class="language-rust">let s = &amp;String::new();

let a: &amp;String = &amp;* s;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a: &amp;String = s;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.63.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+borrow_deref_ref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/borrow_deref_ref.rs#L13">View Source</a></div></div></div></article><article id="borrow_interior_mutable_const"><input id="label-borrow_interior_mutable_const" type="checkbox"><label for="label-borrow_interior_mutable_const"><h2 class="lint-title"><div class="panel-title-name" id="lint-borrow_interior_mutable_const">borrow_interior_mutable_const
<a href="#borrow_interior_mutable_const" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for a borrow of a named constant with interior mutability.</p>
<h3>Why is this bad?</h3>
<p>Named constants are copied at every use site which means any change to their value
will be lost after the newly created value is dropped. e.g.</p>
<pre><code class="language-rust">use core::sync::atomic::{AtomicUsize, Ordering};
const ATOMIC: AtomicUsize = AtomicUsize::new(0);
fn add_one() -&gt; usize {
    // This will always return `0` since `ATOMIC` is copied before it's borrowed
    // for use by `fetch_add`.
    ATOMIC.fetch_add(1, Ordering::AcqRel)
}
</code></pre>
<h3>Known problems</h3>
<p>This lint does not, and cannot in general, determine if the borrow of the constant
is used in a way which causes a mutation. e.g.</p>
<pre><code class="language-rust">use core::cell::Cell;
const CELL: Cell&lt;usize&gt; = Cell::new(0);
fn get_cell() -&gt; Cell&lt;usize&gt; {
    // This is fine. It borrows a copy of `CELL`, but never mutates it through the
    // borrow.
    CELL.clone()
}
</code></pre>
<p>There also exists types which contain private fields with interior mutability, but
no way to both create a value as a constant and modify any mutable field using the
type’s public interface (e.g. <code>bytes::Bytes</code>). As there is no reasonable way to
scan a crate’s interface to see if this is the case, all such types will be linted.
If this happens use the <code>ignore-interior-mutability</code> configuration option to allow
the type.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};
const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);

CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged
assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};
const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);

static STATIC_ATOM: AtomicUsize = CONST_ATOM;
STATIC_ATOM.store(9, SeqCst);
assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>ignore-interior-mutability</code>:  A list of paths to types that should be treated as if they do not contain interior mutability</p>
<p>(default: <code>["bytes::Bytes"]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+borrow_interior_mutable_const">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/non_copy_const.rs#L100">View Source</a></div></div></div></article><article id="borrowed_box"><input id="label-borrowed_box" type="checkbox"><label for="label-borrowed_box"><h2 class="lint-title"><div class="panel-title-name" id="lint-borrowed_box">borrowed_box
<a href="#borrowed_box" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>&amp;Box&lt;T&gt;</code> anywhere in the code.
Check the <a href="https://doc.rust-lang.org/std/boxed/index.html">Box documentation</a> for more information.</p>
<h3>Why is this bad?</h3>
<p>A <code>&amp;Box&lt;T&gt;</code> parameter requires the function caller to box <code>T</code> first before passing it to a function.
Using <code>&amp;T</code> defines a concrete type for the parameter and generalizes the function, this would also
auto-deref to <code>&amp;T</code> at the function call site if passed a <code>&amp;Box&lt;T&gt;</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(bar: &amp;Box&lt;T&gt;) { ... }
</code></pre>
<p>Better:</p>
<pre><code class="language-rust">fn foo(bar: &amp;T) { ... }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+borrowed_box">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/types/mod.rs#L163">View Source</a></div></div></div></article><article id="box_collection"><input id="label-box_collection" type="checkbox"><label for="label-box_collection"><h2 class="lint-title"><div class="panel-title-name" id="lint-box_collection">box_collection
<a href="#box_collection" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>Box&lt;T&gt;</code> where T is a collection such as Vec anywhere in the code.
Check the <a href="https://doc.rust-lang.org/std/boxed/index.html">Box documentation</a> for more information.</p>
<h3>Why is this bad?</h3>
<p>Collections already keeps their contents in a separate area on
the heap. So if you <code>Box</code> them, you just add another level of indirection
without any benefit whatsoever.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct X {
    values: Box&lt;Vec&lt;Foo&gt;&gt;,
}
</code></pre>
<p>Better:</p>
<pre><code class="language-rust">struct X {
    values: Vec&lt;Foo&gt;,
}
</code></pre>
<h3>Past names</h3>
<ul>
<li>box_vec</li>
</ul>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.57.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+box_collection">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/types/mod.rs#L25">View Source</a></div></div></div></article><article id="box_default"><input id="label-box_default" type="checkbox"><label for="label-box_default"><h2 class="lint-title"><div class="panel-title-name" id="lint-box_default">box_default
<a href="#box_default" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>checks for <code>Box::new(Default::default())</code>, which can be written as
<code>Box::default()</code>.</p>
<h3>Why is this bad?</h3>
<p><code>Box::default()</code> is equivalent and more concise.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: Box&lt;String&gt; = Box::new(Default::default());
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x: Box&lt;String&gt; = Box::default();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.66.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+box_default">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/box_default.rs#L14">View Source</a></div></div></div></article><article id="boxed_local"><input id="label-boxed_local" type="checkbox"><label for="label-boxed_local"><h2 class="lint-title"><div class="panel-title-name" id="lint-boxed_local">boxed_local
<a href="#boxed_local" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>Box&lt;T&gt;</code> where an unboxed <code>T</code> would
work fine.</p>
<h3>Why is this bad?</h3>
<p>This is an unnecessary allocation, and bad for
performance. It is only necessary to allocate if you wish to move the box
into something.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(x: Box&lt;u32&gt;) {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo(x: u32) {}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>too-large-for-stack</code>:  The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap</p>
<p>(default: <code>200</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+boxed_local">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/escape.rs#L28">View Source</a></div></div></div></article><article id="branches_sharing_code"><input id="label-branches_sharing_code" type="checkbox"><label for="label-branches_sharing_code"><h2 class="lint-title"><div class="panel-title-name" id="lint-branches_sharing_code">branches_sharing_code
<a href="#branches_sharing_code" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks if the <code>if</code> and <code>else</code> block contain shared code that can be
moved out of the blocks.</p>
<h3>Why is this bad?</h3>
<p>Duplicate code is less maintainable.</p>
<h3>Example</h3>
<pre><code class="language-rust">let foo = if … {
    println!("Hello World");
    13
} else {
    println!("Hello World");
    42
};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">println!("Hello World");
let foo = if … {
    13
} else {
    42
};
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.53.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+branches_sharing_code">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ifs/mod.rs#L116">View Source</a></div></div></div></article><article id="builtin_type_shadow"><input id="label-builtin_type_shadow" type="checkbox"><label for="label-builtin_type_shadow"><h2 class="lint-title"><div class="panel-title-name" id="lint-builtin_type_shadow">builtin_type_shadow
<a href="#builtin_type_shadow" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns if a generic shadows a built-in type.</p>
<h3>Why is this bad?</h3>
<p>This gives surprising type errors.</p>
<h3>Example</h3>
<pre><code class="language-rust">impl&lt;u32&gt; Foo&lt;u32&gt; {
    fn impl_func(&amp;self) -&gt; u32 {
        42
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+builtin_type_shadow">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/misc_early/mod.rs#L183">View Source</a></div></div></div></article><article id="byte_char_slices"><input id="label-byte_char_slices" type="checkbox"><label for="label-byte_char_slices"><h2 class="lint-title"><div class="panel-title-name" id="lint-byte_char_slices">byte_char_slices
<a href="#byte_char_slices" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for hard to read slices of byte characters, that could be more easily expressed as a
byte string.</p>
<h3>Why is this bad?</h3>
<p>Potentially makes the string harder to read.</p>
<h3>Example</h3>
<pre><code class="language-rust">&amp;[b'H', b'e', b'l', b'l', b'o'];
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">b"Hello"
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.81.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+byte_char_slices">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/byte_char_slices.rs#L8">View Source</a></div></div></div></article><article id="bytes_count_to_len"><input id="label-bytes_count_to_len" type="checkbox"><label for="label-bytes_count_to_len"><h2 class="lint-title"><div class="panel-title-name" id="lint-bytes_count_to_len">bytes_count_to_len
<a href="#bytes_count_to_len" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>It checks for <code>str::bytes().count()</code> and suggests replacing it with
<code>str::len()</code>.</p>
<h3>Why is this bad?</h3>
<p><code>str::bytes().count()</code> is longer and may not be as performant as using
<code>str::len()</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">"hello".bytes().count();
String::from("hello").bytes().count();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">"hello".len();
String::from("hello").len();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+bytes_count_to_len">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2620">View Source</a></div></div></div></article><article id="bytes_nth"><input id="label-bytes_nth" type="checkbox"><label for="label-bytes_nth"><h2 class="lint-title"><div class="panel-title-name" id="lint-bytes_nth">bytes_nth
<a href="#bytes_nth" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the use of <code>.bytes().nth()</code>.</p>
<h3>Why is this bad?</h3>
<p><code>.as_bytes().get()</code> is more efficient and more
readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">"Hello".bytes().nth(3);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">"Hello".as_bytes().get(3);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.52.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+bytes_nth">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2102">View Source</a></div></div></div></article><article id="cargo_common_metadata"><input id="label-cargo_common_metadata" type="checkbox"><label for="label-cargo_common_metadata"><h2 class="lint-title"><div class="panel-title-name" id="lint-cargo_common_metadata">cargo_common_metadata
<a href="#cargo_common_metadata" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-cargo">cargo</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks to see if all common metadata is defined in
<code>Cargo.toml</code>. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata</p>
<h3>Why is this bad?</h3>
<p>It will be more difficult for users to discover the
purpose of the crate, and key information related to it.</p>
<h3>Example</h3>
<pre><code class="language-toml">[package]
name = "clippy"
version = "0.0.212"
repository = "https://github.com/rust-lang/rust-clippy"
readme = "README.md"
license = "MIT OR Apache-2.0"
keywords = ["clippy", "lint", "plugin"]
categories = ["development-tools", "development-tools::cargo-plugins"]
</code></pre>
<p>Should include a description field like:</p>
<pre><code class="language-toml">[package]
name = "clippy"
version = "0.0.212"
description = "A bunch of helpful lints to avoid common pitfalls in Rust"
repository = "https://github.com/rust-lang/rust-clippy"
readme = "README.md"
license = "MIT OR Apache-2.0"
keywords = ["clippy", "lint", "plugin"]
categories = ["development-tools", "development-tools::cargo-plugins"]
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>cargo-ignore-publish</code>:  For internal testing only, ignores the current <code>publish</code> settings in the Cargo manifest.</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.32.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cargo_common_metadata">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/cargo/mod.rs#L17">View Source</a></div></div></div></article><article id="case_sensitive_file_extension_comparisons"><input id="label-case_sensitive_file_extension_comparisons" type="checkbox"><label for="label-case_sensitive_file_extension_comparisons"><h2 class="lint-title"><div class="panel-title-name" id="lint-case_sensitive_file_extension_comparisons">case_sensitive_file_extension_comparisons
<a href="#case_sensitive_file_extension_comparisons" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>ends_with</code> with possible file extensions
and suggests to use a case-insensitive approach instead.</p>
<h3>Why is this bad?</h3>
<p><code>ends_with</code> is case-sensitive and may not detect files with a valid extension.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn is_rust_file(filename: &amp;str) -&gt; bool {
    filename.ends_with(".rs")
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn is_rust_file(filename: &amp;str) -&gt; bool {
    let filename = std::path::Path::new(filename);
    filename.extension()
        .map_or(false, |ext| ext.eq_ignore_ascii_case("rs"))
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.51.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+case_sensitive_file_extension_comparisons">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2645">View Source</a></div></div></div></article><article id="cast_abs_to_unsigned"><input id="label-cast_abs_to_unsigned" type="checkbox"><label for="label-cast_abs_to_unsigned"><h2 class="lint-title"><div class="panel-title-name" id="lint-cast_abs_to_unsigned">cast_abs_to_unsigned
<a href="#cast_abs_to_unsigned" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of the <code>abs()</code> method that cast the result to unsigned.</p>
<h3>Why is this bad?</h3>
<p>The <code>unsigned_abs()</code> method avoids panic when called on the MIN value.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: i32 = -42;
let y: u32 = x.abs() as u32;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x: i32 = -42;
let y: u32 = x.unsigned_abs();
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cast_abs_to_unsigned">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L532">View Source</a></div></div></div></article><article id="cast_enum_constructor"><input id="label-cast_enum_constructor" type="checkbox"><label for="label-cast_enum_constructor"><h2 class="lint-title"><div class="panel-title-name" id="lint-cast_enum_constructor">cast_enum_constructor
<a href="#cast_enum_constructor" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for casts from an enum tuple constructor to an integer.</p>
<h3>Why is this bad?</h3>
<p>The cast is easily confused with casting a c-like enum value to an integer.</p>
<h3>Example</h3>
<pre><code class="language-rust">enum E { X(i32) };
let _ = E::X as usize;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.61.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cast_enum_constructor">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L514">View Source</a></div></div></div></article><article id="cast_enum_truncation"><input id="label-cast_enum_truncation" type="checkbox"><label for="label-cast_enum_truncation"><h2 class="lint-title"><div class="panel-title-name" id="lint-cast_enum_truncation">cast_enum_truncation
<a href="#cast_enum_truncation" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for casts from an enum type to an integral type that will definitely truncate the
value.</p>
<h3>Why is this bad?</h3>
<p>The resulting integral value will not match the value of the variant it came from.</p>
<h3>Example</h3>
<pre><code class="language-rust">enum E { X = 256 };
let _ = E::X as u8;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.61.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cast_enum_truncation">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L450">View Source</a></div></div></div></article><article id="cast_lossless"><input id="label-cast_lossless" type="checkbox"><label for="label-cast_lossless"><h2 class="lint-title"><div class="panel-title-name" id="lint-cast_lossless">cast_lossless
<a href="#cast_lossless" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for casts between numeric types that can be replaced by safe
conversion functions.</p>
<h3>Why is this bad?</h3>
<p>Rust’s <code>as</code> keyword will perform many kinds of conversions, including
silently lossy conversions. Conversion functions such as <code>i32::from</code>
will only perform lossless conversions. Using the conversion functions
prevents conversions from becoming silently lossy if the input types
ever change, and makes it clear for people reading the code that the
conversion is lossless.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn as_u64(x: u8) -&gt; u64 {
    x as u64
}
</code></pre>
<p>Using <code>::from</code> would look like this:</p>
<pre><code class="language-rust">fn as_u64(x: u8) -&gt; u64 {
    u64::from(x)
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cast_lossless">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L154">View Source</a></div></div></div></article><article id="cast_nan_to_int"><input id="label-cast_nan_to_int" type="checkbox"><label for="label-cast_nan_to_int"><h2 class="lint-title"><div class="panel-title-name" id="lint-cast_nan_to_int">cast_nan_to_int
<a href="#cast_nan_to_int" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for a known NaN float being cast to an integer</p>
<h3>Why is this bad?</h3>
<p>NaNs are cast into zero, so one could simply use this and make the
code more readable. The lint could also hint at a programmer error.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = (0.0_f32 / 0.0) as u64;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = 0_u64;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.66.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cast_nan_to_int">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L669">View Source</a></div></div></div></article><article id="cast_possible_truncation"><input id="label-cast_possible_truncation" type="checkbox"><label for="label-cast_possible_truncation"><h2 class="lint-title"><div class="panel-title-name" id="lint-cast_possible_truncation">cast_possible_truncation
<a href="#cast_possible_truncation" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for casts between numeric types that may
truncate large values. This is expected behavior, so the cast is <code>Allow</code> by
default. It suggests user either explicitly ignore the lint,
or use <code>try_from()</code> and handle the truncation, default, or panic explicitly.</p>
<h3>Why is this bad?</h3>
<p>In some problem domains, it is good practice to avoid
truncation. This lint can be activated to help assess where additional
checks could be beneficial.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn as_u8(x: u64) -&gt; u8 {
    x as u8
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn as_u8(x: u64) -&gt; u8 {
    if let Ok(x) = u8::try_from(x) {
        x
    } else {
        todo!();
    }
}
// Or
#[allow(clippy::cast_possible_truncation)]
fn as_u16(x: u64) -&gt; u16 {
    x as u16
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cast_possible_truncation">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L85">View Source</a></div></div></div></article><article id="cast_possible_wrap"><input id="label-cast_possible_wrap" type="checkbox"><label for="label-cast_possible_wrap"><h2 class="lint-title"><div class="panel-title-name" id="lint-cast_possible_wrap">cast_possible_wrap
<a href="#cast_possible_wrap" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for casts from an unsigned type to a signed type of
the same size, or possibly smaller due to target-dependent integers.
Performing such a cast is a no-op for the compiler (that is, nothing is
changed at the bit level), and the binary representation of the value is
reinterpreted. This can cause wrapping if the value is too big
for the target signed type. However, the cast works as defined, so this lint
is <code>Allow</code> by default.</p>
<h3>Why is this bad?</h3>
<p>While such a cast is not bad in itself, the results can
be surprising when this is not the intended behavior:</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = u32::MAX as i32; // will yield a value of `-1`
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = i32::try_from(u32::MAX).ok();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cast_possible_wrap">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L124">View Source</a></div></div></div></article><article id="cast_precision_loss"><input id="label-cast_precision_loss" type="checkbox"><label for="label-cast_precision_loss"><h2 class="lint-title"><div class="panel-title-name" id="lint-cast_precision_loss">cast_precision_loss
<a href="#cast_precision_loss" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for casts from any numeric type to a float type where
the receiving type cannot store all values from the original type without
rounding errors. This possible rounding is to be expected, so this lint is
<code>Allow</code> by default.</p>
<p>Basically, this warns on casting any integer with 32 or more bits to <code>f32</code>
or any 64-bit integer to <code>f64</code>.</p>
<h3>Why is this bad?</h3>
<p>It’s not bad at all. But in some applications it can be
helpful to know where precision loss can take place. This lint can help find
those places in the code.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = u64::MAX;
x as f64;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cast_precision_loss">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L37">View Source</a></div></div></div></article><article id="cast_ptr_alignment"><input id="label-cast_ptr_alignment" type="checkbox"><label for="label-cast_ptr_alignment"><h2 class="lint-title"><div class="panel-title-name" id="lint-cast_ptr_alignment">cast_ptr_alignment
<a href="#cast_ptr_alignment" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for casts, using <code>as</code> or <code>pointer::cast</code>, from a
less strictly aligned pointer to a more strictly aligned pointer.</p>
<h3>Why is this bad?</h3>
<p>Dereferencing the resulting pointer may be undefined behavior.</p>
<h3>Known problems</h3>
<p>Using <a href="https://doc.rust-lang.org/std/ptr/fn.read_unaligned.html"><code>std::ptr::read_unaligned</code></a> and <a href="https://doc.rust-lang.org/std/ptr/fn.write_unaligned.html"><code>std::ptr::write_unaligned</code></a> or
similar on the resulting pointer is fine. Is over-zealous: casts with
manual alignment checks or casts like <code>u64</code> -&gt; <code>u8</code> -&gt; <code>u16</code> can be
fine. Miri is able to do a more in-depth analysis.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = (&amp;1u8 as *const u8) as *const u16;
let _ = (&amp;mut 1u8 as *mut u8) as *mut u16;

(&amp;1u8 as *const u8).cast::&lt;u16&gt;();
(&amp;mut 1u8 as *mut u8).cast::&lt;u16&gt;();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cast_ptr_alignment">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L223">View Source</a></div></div></div></article><article id="cast_sign_loss"><input id="label-cast_sign_loss" type="checkbox"><label for="label-cast_sign_loss"><h2 class="lint-title"><div class="panel-title-name" id="lint-cast_sign_loss">cast_sign_loss
<a href="#cast_sign_loss" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for casts from a signed to an unsigned numeric
type. In this case, negative values wrap around to large positive values,
which can be quite surprising in practice. However, since the cast works as
defined, this lint is <code>Allow</code> by default.</p>
<h3>Why is this bad?</h3>
<p>Possibly surprising results. You can activate this lint
as a one-time check to see where numeric wrapping can arise.</p>
<h3>Example</h3>
<pre><code class="language-rust">let y: i8 = -1;
y as u64; // will return 18446744073709551615
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cast_sign_loss">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L63">View Source</a></div></div></div></article><article id="cast_slice_different_sizes"><input id="label-cast_slice_different_sizes" type="checkbox"><label for="label-cast_slice_different_sizes"><h2 class="lint-title"><div class="panel-title-name" id="lint-cast_slice_different_sizes">cast_slice_different_sizes
<a href="#cast_slice_different_sizes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>as</code> casts between raw pointers to slices with differently sized elements.</p>
<h3>Why is this bad?</h3>
<p>The produced raw pointer to a slice does not update its length metadata. The produced
pointer will point to a different number of bytes than the original pointer because the
length metadata of a raw slice pointer is in elements rather than bytes.
Producing a slice reference from the raw pointer will either create a slice with
less data (which can be surprising) or create a slice with more data and cause Undefined Behavior.</p>
<h3>Example</h3>
<p>// Missing data</p>
<pre><code class="language-rust">let a = [1_i32, 2, 3, 4];
let p = &amp;a as *const [i32] as *const [u8];
unsafe {
    println!("{:?}", &amp;*p);
}
</code></pre>
<p>// Undefined Behavior (note: also potential alignment issues)</p>
<pre><code class="language-rust">let a = [1_u8, 2, 3, 4];
let p = &amp;a as *const [u8] as *const [u32];
unsafe {
    println!("{:?}", &amp;*p);
}
</code></pre>
<p>Instead use <code>ptr::slice_from_raw_parts</code> to construct a slice from a data pointer and the correct length</p>
<pre><code class="language-rust">let a = [1_i32, 2, 3, 4];
let old_ptr = &amp;a as *const [i32];
// The data pointer is cast to a pointer to the target `u8` not `[u8]`
// The length comes from the known length of 4 i32s times the 4 bytes per i32
let new_ptr = core::ptr::slice_from_raw_parts(old_ptr as *const u8, 16);
unsafe {
    println!("{:?}", &amp;*new_ptr);
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.61.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cast_slice_different_sizes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L469">View Source</a></div></div></div></article><article id="cast_slice_from_raw_parts"><input id="label-cast_slice_from_raw_parts" type="checkbox"><label for="label-cast_slice_from_raw_parts"><h2 class="lint-title"><div class="panel-title-name" id="lint-cast_slice_from_raw_parts">cast_slice_from_raw_parts
<a href="#cast_slice_from_raw_parts" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for a raw slice being cast to a slice pointer</p>
<h3>Why is this bad?</h3>
<p>This can result in multiple <code>&amp;mut</code> references to the same location when only a pointer is
required.
<code>ptr::slice_from_raw_parts</code> is a safe alternative that doesn’t require
the same <a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html#safety">safety requirements</a> to be upheld.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _: *const [u8] = std::slice::from_raw_parts(ptr, len) as *const _;
let _: *mut [u8] = std::slice::from_raw_parts_mut(ptr, len) as *mut _;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _: *const [u8] = std::ptr::slice_from_raw_parts(ptr, len);
let _: *mut [u8] = std::ptr::slice_from_raw_parts_mut(ptr, len);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.65.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cast_slice_from_raw_parts">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L616">View Source</a></div></div></div></article><article id="cfg_not_test"><input id="label-cfg_not_test" type="checkbox"><label for="label-cfg_not_test"><h2 class="lint-title"><div class="panel-title-name" id="lint-cfg_not_test">cfg_not_test
<a href="#cfg_not_test" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>cfg</code> that excludes code from <code>test</code> builds. (i.e., <code>#[cfg(not(test))]</code>)</p>
<h3>Why is this bad?</h3>
<p>This may give the false impression that a codebase has 100% coverage, yet actually has untested code.
Enabling this also guards against excessive mockery as well, which is an anti-pattern.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[cfg(not(test))]
important_check(); // I'm not actually tested, but not including me will falsely increase coverage!
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">important_check();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.81.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cfg_not_test">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/cfg_not_test.rs#L8">View Source</a></div></div></div></article><article id="char_indices_as_byte_indices"><input id="label-char_indices_as_byte_indices" type="checkbox"><label for="label-char_indices_as_byte_indices"><h2 class="lint-title"><div class="panel-title-name" id="lint-char_indices_as_byte_indices">char_indices_as_byte_indices
<a href="#char_indices_as_byte_indices" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of a character position yielded by <code>.chars().enumerate()</code> in a context where a <strong>byte index</strong> is expected,
such as an argument to a specific <code>str</code> method or indexing into a <code>str</code> or <code>String</code>.</p>
<h3>Why is this bad?</h3>
<p>A character (more specifically, a Unicode scalar value) that is yielded by <code>str::chars</code> can take up multiple bytes,
so a character position does not necessarily have the same byte index at which the character is stored.
Thus, using the character position where a byte index is expected can unexpectedly return wrong values
or panic when the string consists of multibyte characters.</p>
<p>For example, the character <code>a</code> in <code>äa</code> is stored at byte index 2 but has the character position 1.
Using the character position 1 to index into the string will lead to a panic as it is in the middle of the first character.</p>
<p>Instead of <code>.chars().enumerate()</code>, the correct iterator to use is <code>.char_indices()</code>, which yields byte indices.</p>
<p>This pattern is technically fine if the strings are known to only use the ASCII subset,
though in those cases it would be better to use <code>bytes()</code> directly to make the intent clearer,
but there is also no downside to just using <code>.char_indices()</code> directly and supporting non-ASCII strings.</p>
<p>You may also want to read the <a href="https://doc.rust-lang.org/book/ch08-02-strings.html">chapter on strings in the Rust Book</a>
which goes into this in more detail.</p>
<h3>Example</h3>
<pre><code class="language-rust">for (idx, c) in s.chars().enumerate() {
    let _ = s[idx..]; // ⚠️ Panics for strings consisting of multibyte characters
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">for (idx, c) in s.char_indices() {
    let _ = s[idx..];
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.88.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+char_indices_as_byte_indices">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L745">View Source</a></div></div></div></article><article id="char_lit_as_u8"><input id="label-char_lit_as_u8" type="checkbox"><label for="label-char_lit_as_u8"><h2 class="lint-title"><div class="panel-title-name" id="lint-char_lit_as_u8">char_lit_as_u8
<a href="#char_lit_as_u8" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for expressions where a character literal is cast
to <code>u8</code> and suggests using a byte literal instead.</p>
<h3>Why is this bad?</h3>
<p>In general, casting values to smaller types is
error-prone and should be avoided where possible. In the particular case of
converting a character literal to <code>u8</code>, it is easy to avoid by just using a
byte literal instead. As an added bonus, <code>b'a'</code> is also slightly shorter
than <code>'a' as u8</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">'x' as u8
</code></pre>
<p>A better version, using the byte literal:</p>
<pre><code class="language-rust">b'x'
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+char_lit_as_u8">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L356">View Source</a></div></div></div></article><article id="chars_last_cmp"><input id="label-chars_last_cmp" type="checkbox"><label for="label-chars_last_cmp"><h2 class="lint-title"><div class="panel-title-name" id="lint-chars_last_cmp">chars_last_cmp
<a href="#chars_last_cmp" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>_.chars().last()</code> or
<code>_.chars().next_back()</code> on a <code>str</code> to check if it ends with a given char.</p>
<h3>Why is this bad?</h3>
<p>Readability, this can be written more concisely as
<code>_.ends_with(_)</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">name.chars().last() == Some('_') || name.chars().next_back() == Some('-');
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">name.ends_with('_') || name.ends_with('-');
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+chars_last_cmp">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1467">View Source</a></div></div></div></article><article id="chars_next_cmp"><input id="label-chars_next_cmp" type="checkbox"><label for="label-chars_next_cmp"><h2 class="lint-title"><div class="panel-title-name" id="lint-chars_next_cmp">chars_next_cmp
<a href="#chars_next_cmp" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.chars().next()</code> on a <code>str</code> to check
if it starts with a given char.</p>
<h3>Why is this bad?</h3>
<p>Readability, this can be written more concisely as
<code>_.starts_with(_)</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let name = "foo";
if name.chars().next() == Some('_') {};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let name = "foo";
if name.starts_with('_') {};
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+chars_next_cmp">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L896">View Source</a></div></div></div></article><article id="checked_conversions"><input id="label-checked_conversions" type="checkbox"><label for="label-checked_conversions"><h2 class="lint-title"><div class="panel-title-name" id="lint-checked_conversions">checked_conversions
<a href="#checked_conversions" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for explicit bounds checking when casting.</p>
<h3>Why is this bad?</h3>
<p>Reduces the readability of statements &amp; is error prone.</p>
<h3>Example</h3>
<pre><code class="language-rust">foo &lt;= i32::MAX as u32;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">i32::try_from(foo).is_ok();
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.37.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+checked_conversions">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/checked_conversions.rs#L12">View Source</a></div></div></div></article><article id="clear_with_drain"><input id="label-clear_with_drain" type="checkbox"><label for="label-clear_with_drain"><h2 class="lint-title"><div class="panel-title-name" id="lint-clear_with_drain">clear_with_drain
<a href="#clear_with_drain" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.drain(..)</code> for the sole purpose of clearing a container.</p>
<h3>Why is this bad?</h3>
<p>This creates an unnecessary iterator that is dropped immediately.</p>
<p>Calling <code>.clear()</code> also makes the intent clearer.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut v = vec![1, 2, 3];
v.drain(..);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut v = vec![1, 2, 3];
v.clear();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+clear_with_drain">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3395">View Source</a></div></div></div></article><article id="clone_on_copy"><input id="label-clone_on_copy" type="checkbox"><label for="label-clone_on_copy"><h2 class="lint-title"><div class="panel-title-name" id="lint-clone_on_copy">clone_on_copy
<a href="#clone_on_copy" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.clone()</code> on a <code>Copy</code> type.</p>
<h3>Why is this bad?</h3>
<p>The only reason <code>Copy</code> types implement <code>Clone</code> is for
generics, not for using the <code>clone</code> method on a concrete type.</p>
<h3>Example</h3>
<pre><code class="language-rust">42u64.clone();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+clone_on_copy">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1031">View Source</a></div></div></div></article><article id="clone_on_ref_ptr"><input id="label-clone_on_ref_ptr" type="checkbox"><label for="label-clone_on_ref_ptr"><h2 class="lint-title"><div class="panel-title-name" id="lint-clone_on_ref_ptr">clone_on_ref_ptr
<a href="#clone_on_ref_ptr" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.clone()</code> on a ref-counted pointer,
(<code>Rc</code>, <code>Arc</code>, <code>rc::Weak</code>, or <code>sync::Weak</code>), and suggests calling Clone via unified
function syntax instead (e.g., <code>Rc::clone(foo)</code>).</p>
<h3>Why restrict this?</h3>
<p>Calling <code>.clone()</code> on an <code>Rc</code>, <code>Arc</code>, or <code>Weak</code>
can obscure the fact that only the pointer is being cloned, not the underlying
data.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = Rc::new(1);

x.clone();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">Rc::clone(&amp;x);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+clone_on_ref_ptr">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1049">View Source</a></div></div></div></article><article id="cloned_instead_of_copied"><input id="label-cloned_instead_of_copied" type="checkbox"><label for="label-cloned_instead_of_copied"><h2 class="lint-title"><div class="panel-title-name" id="lint-cloned_instead_of_copied">cloned_instead_of_copied
<a href="#cloned_instead_of_copied" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>cloned()</code> on an <code>Iterator</code> or <code>Option</code> where
<code>copied()</code> could be used instead.</p>
<h3>Why is this bad?</h3>
<p><code>copied()</code> is better because it guarantees that the type being cloned
implements <code>Copy</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">[1, 2, 3].iter().cloned();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">[1, 2, 3].iter().copied();
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.53.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cloned_instead_of_copied">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L166">View Source</a></div></div></div></article><article id="cloned_ref_to_slice_refs"><input id="label-cloned_ref_to_slice_refs" type="checkbox"><label for="label-cloned_ref_to_slice_refs"><h2 class="lint-title"><div class="panel-title-name" id="lint-cloned_ref_to_slice_refs">cloned_ref_to_slice_refs
<a href="#cloned_ref_to_slice_refs" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for slice references with cloned references such as <code>&amp;[f.clone()]</code>.</p>
<h3>Why is this bad</h3>
<p>A reference does not need to be owned in order to be used as a slice.</p>
<h3>Known problems</h3>
<p>This lint does not know whether or not a clone implementation has side effects.</p>
<h3>Example</h3>
<pre><code class="language-rust">let data = 10;
let data_ref = &amp;data;
take_slice(&amp;[data_ref.clone()]);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::slice;
let data = 10;
let data_ref = &amp;data;
take_slice(slice::from_ref(data_ref));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.89.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cloned_ref_to_slice_refs">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/cloned_ref_to_slice_refs.rs#L14">View Source</a></div></div></div></article><article id="cmp_null"><input id="label-cmp_null" type="checkbox"><label for="label-cmp_null"><h2 class="lint-title"><div class="panel-title-name" id="lint-cmp_null">cmp_null
<a href="#cmp_null" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint checks for equality comparisons with <code>ptr::null</code> or <code>ptr::null_mut</code></p>
<h3>Why is this bad?</h3>
<p>It’s easier and more readable to use the inherent
<code>.is_null()</code>
method instead</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::ptr;

if x == ptr::null() {
    // ..
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if x.is_null() {
    // ..
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cmp_null">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ptr/mod.rs#L46">View Source</a></div></div></div></article><article id="cmp_owned"><input id="label-cmp_owned" type="checkbox"><label for="label-cmp_owned"><h2 class="lint-title"><div class="panel-title-name" id="lint-cmp_owned">cmp_owned
<a href="#cmp_owned" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for conversions to owned values just for the sake
of a comparison.</p>
<h3>Why is this bad?</h3>
<p>The comparison can operate on a reference, so creating
an owned value effectively throws it away directly afterwards, which is
needlessly consuming code and heap space.</p>
<h3>Example</h3>
<pre><code class="language-rust">if x.to_owned() == y {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if x == y {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cmp_owned">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L545">View Source</a></div></div></div></article><article id="coerce_container_to_any"><input id="label-coerce_container_to_any" type="checkbox"><label for="label-coerce_container_to_any"><h2 class="lint-title"><div class="panel-title-name" id="lint-coerce_container_to_any">coerce_container_to_any
<a href="#coerce_container_to_any" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Protects against unintended coercion of references to container types to <code>&amp;dyn Any</code> when the
container type dereferences to a <code>dyn Any</code> which could be directly referenced instead.</p>
<h3>Why is this bad?</h3>
<p>The intention is usually to get a reference to the <code>dyn Any</code> the value dereferences to,
rather than coercing a reference to the container itself to <code>&amp;dyn Any</code>.</p>
<h3>Example</h3>
<p>Because <code>Box&lt;dyn Any&gt;</code> itself implements <code>Any</code>, <code>&amp;Box&lt;dyn Any&gt;</code>
can be coerced to an <code>&amp;dyn Any</code> which refers to <em>the <code>Box</code> itself</em>, rather than the
inner <code>dyn Any</code>.</p>
<pre><code class="language-rust">let x: Box&lt;dyn Any&gt; = Box::new(0u32);
let dyn_any_of_box: &amp;dyn Any = &amp;x;

// Fails as we have a &amp;dyn Any to the Box, not the u32
assert_eq!(dyn_any_of_box.downcast_ref::&lt;u32&gt;(), None);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x: Box&lt;dyn Any&gt; = Box::new(0u32);
let dyn_any_of_u32: &amp;dyn Any = &amp;*x;

// Succeeds since we have a &amp;dyn Any to the inner u32!
assert_eq!(dyn_any_of_u32.downcast_ref::&lt;u32&gt;(), Some(&amp;0u32));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.89.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+coerce_container_to_any">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/coerce_container_to_any.rs#L11">View Source</a></div></div></div></article><article id="cognitive_complexity"><input id="label-cognitive_complexity" type="checkbox"><label for="label-cognitive_complexity"><h2 class="lint-title"><div class="panel-title-name" id="lint-cognitive_complexity">cognitive_complexity
<a href="#cognitive_complexity" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>We used to think it measured how hard a method is to understand.</p>
<h3>Why is this bad?</h3>
<p>Ideally, we would like to be able to measure how hard a function is
to understand given its context (what we call its Cognitive Complexity).
But that’s not what this lint does. See “Known problems”</p>
<h3>Known problems</h3>
<p>The true Cognitive Complexity of a method is not something we can
calculate using modern technology. This lint has been left in
<code>restriction</code> so as to not mislead users into using this lint as a
measurement tool.</p>
<p>For more detailed information, see <a href="https://github.com/rust-lang/rust-clippy/issues/3793">rust-clippy#3793</a></p>
<h3>Lints to consider instead of this</h3>
<ul>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#excessive_nesting"><code>excessive_nesting</code></a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html#too_many_lines"><code>too_many_lines</code></a></li>
</ul>
<h3>Past names</h3>
<ul>
<li>cyclomatic_complexity</li>
</ul>
<h3>Configuration</h3>
<ul>
<li>
<p><code>cognitive-complexity-threshold</code>:  The maximum cognitive complexity a function can have</p>
<p>(default: <code>25</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.35.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+cognitive_complexity">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/cognitive_complexity.rs#L15">View Source</a></div></div></div></article><article id="collapsible_else_if"><input id="label-collapsible_else_if" type="checkbox"><label for="label-collapsible_else_if"><h2 class="lint-title"><div class="panel-title-name" id="lint-collapsible_else_if">collapsible_else_if
<a href="#collapsible_else_if" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for collapsible <code>else { if ... }</code> expressions
that can be collapsed to <code>else if ...</code>.</p>
<h3>Why is this bad?</h3>
<p>Each <code>if</code>-statement adds one level of nesting, which
makes code look more complex than it really is.</p>
<h3>Example</h3>
<pre><code class="language-rust">
if x {
    …
} else {
    if y {
        …
    }
}
</code></pre>
<p>Should be written:</p>
<pre><code class="language-rust">if x {
    …
} else if y {
    …
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>lint-commented-code</code>:  Whether collapsible <code>if</code> and <code>else if</code> chains are linted if they contain comments inside the parts
that would be collapsed.</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.51.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+collapsible_else_if">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/collapsible_if.rs#L47">View Source</a></div></div></div></article><article id="collapsible_if"><input id="label-collapsible_if" type="checkbox"><label for="label-collapsible_if"><h2 class="lint-title"><div class="panel-title-name" id="lint-collapsible_if">collapsible_if
<a href="#collapsible_if" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for nested <code>if</code> statements which can be collapsed
by <code>&amp;&amp;</code>-combining their conditions.</p>
<h3>Why is this bad?</h3>
<p>Each <code>if</code>-statement adds one level of nesting, which
makes code look more complex than it really is.</p>
<h3>Example</h3>
<pre><code class="language-rust">if x {
    if y {
        // …
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if x &amp;&amp; y {
    // …
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>lint-commented-code</code>:  Whether collapsible <code>if</code> and <code>else if</code> chains are linted if they contain comments inside the parts
that would be collapsed.</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+collapsible_if">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/collapsible_if.rs#L15">View Source</a></div></div></div></article><article id="collapsible_match"><input id="label-collapsible_match" type="checkbox"><label for="label-collapsible_match"><h2 class="lint-title"><div class="panel-title-name" id="lint-collapsible_match">collapsible_match
<a href="#collapsible_match" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Finds nested <code>match</code> or <code>if let</code> expressions where the patterns may be “collapsed” together
without adding any branches.</p>
<p>Note that this lint is not intended to find <em>all</em> cases where nested match patterns can be merged, but only
cases where merging would most likely make the code more readable.</p>
<h3>Why is this bad?</h3>
<p>It is unnecessarily verbose and complex.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn func(opt: Option&lt;Result&lt;u64, String&gt;&gt;) {
    let n = match opt {
        Some(n) =&gt; match n {
            Ok(n) =&gt; n,
            _ =&gt; return,
        }
        None =&gt; return,
    };
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn func(opt: Option&lt;Result&lt;u64, String&gt;&gt;) {
    let n = match opt {
        Some(Ok(n)) =&gt; n,
        _ =&gt; return,
    };
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.50.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+collapsible_match">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L659">View Source</a></div></div></div></article><article id="collapsible_str_replace"><input id="label-collapsible_str_replace" type="checkbox"><label for="label-collapsible_str_replace"><h2 class="lint-title"><div class="panel-title-name" id="lint-collapsible_str_replace">collapsible_str_replace
<a href="#collapsible_str_replace" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for consecutive calls to <code>str::replace</code> (2 or more)
that can be collapsed into a single call.</p>
<h3>Why is this bad?</h3>
<p>Consecutive <code>str::replace</code> calls scan the string multiple times
with repetitive code.</p>
<h3>Example</h3>
<pre><code class="language-rust">let hello = "hesuo worpd"
    .replace('s', "l")
    .replace("u", "l")
    .replace('p', "l");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let hello = "hesuo worpd".replace(['s', 'u', 'p'], "l");
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.65.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+collapsible_str_replace">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L189">View Source</a></div></div></div></article><article id="collection_is_never_read"><input id="label-collection_is_never_read" type="checkbox"><label for="label-collection_is_never_read"><h2 class="lint-title"><div class="panel-title-name" id="lint-collection_is_never_read">collection_is_never_read
<a href="#collection_is_never_read" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for collections that are never queried.</p>
<h3>Why is this bad?</h3>
<p>Putting effort into constructing a collection but then never querying it might indicate that
the author forgot to do whatever they intended to do with the collection. Example: Clone
a vector, sort it for iteration, but then mistakenly iterate the original vector
instead.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut sorted_samples = samples.clone();
sorted_samples.sort();
for sample in &amp;samples { // Oops, meant to use `sorted_samples`.
    println!("{sample}");
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut sorted_samples = samples.clone();
sorted_samples.sort();
for sample in &amp;sorted_samples {
    println!("{sample}");
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+collection_is_never_read">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/collection_is_never_read.rs#L11">View Source</a></div></div></div></article><article id="comparison_chain"><input id="label-comparison_chain" type="checkbox"><label for="label-comparison_chain"><h2 class="lint-title"><div class="panel-title-name" id="lint-comparison_chain">comparison_chain
<a href="#comparison_chain" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks comparison chains written with <code>if</code> that can be
rewritten with <code>match</code> and <code>cmp</code>.</p>
<h3>Why is this bad?</h3>
<p><code>if</code> is not guaranteed to be exhaustive and conditionals can get
repetitive</p>
<h3>Known problems</h3>
<p>The match statement may be slower due to the compiler
not inlining the call to cmp. See issue <a href="https://github.com/rust-lang/rust-clippy/issues/5354">#5354</a></p>
<h3>Example</h3>
<pre><code class="language-rust">fn f(x: u8, y: u8) {
    if x &gt; y {
        a()
    } else if x &lt; y {
        b()
    } else {
        c()
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::cmp::Ordering;
fn f(x: u8, y: u8) {
     match x.cmp(&amp;y) {
         Ordering::Greater =&gt; a(),
         Ordering::Less =&gt; b(),
         Ordering::Equal =&gt; c()
     }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.40.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+comparison_chain">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/comparison_chain.rs#L11">View Source</a></div></div></div></article><article id="comparison_to_empty"><input id="label-comparison_to_empty" type="checkbox"><label for="label-comparison_to_empty"><h2 class="lint-title"><div class="panel-title-name" id="lint-comparison_to_empty">comparison_to_empty
<a href="#comparison_to_empty" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for comparing to an empty slice such as <code>""</code> or <code>[]</code>,
and suggests using <code>.is_empty()</code> where applicable.</p>
<h3>Why is this bad?</h3>
<p>Some structures can answer <code>.is_empty()</code> much faster
than checking for equality. So it is good to get into the habit of using
<code>.is_empty()</code>, and having it is cheap.
Besides, it makes the intent clearer than a manual comparison in some contexts.</p>
<h3>Example</h3>
<pre><code class="language-rust">if s == "" {
    ..
}

if arr == [] {
    ..
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if s.is_empty() {
    ..
}

if arr.is_empty() {
    ..
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+comparison_to_empty">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/len_zero.rs#L54">View Source</a></div></div></div></article><article id="confusing_method_to_numeric_cast"><input id="label-confusing_method_to_numeric_cast" type="checkbox"><label for="label-confusing_method_to_numeric_cast"><h2 class="lint-title"><div class="panel-title-name" id="lint-confusing_method_to_numeric_cast">confusing_method_to_numeric_cast
<a href="#confusing_method_to_numeric_cast" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for casts of a primitive method pointer like <code>max</code>/<code>min</code> to any integer type.</p>
<h3>Why restrict this?</h3>
<p>Casting a function pointer to an integer can have surprising results and can occur
accidentally if parentheses are omitted from a function call. If you aren’t doing anything
low-level with function pointers then you can opt out of casting functions to integers in
order to avoid mistakes. Alternatively, you can use this lint to audit all uses of function
pointer casts in your code.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = u16::max as usize;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = u16::MAX as usize;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.89.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+confusing_method_to_numeric_cast">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L791">View Source</a></div></div></div></article><article id="const_is_empty"><input id="label-const_is_empty" type="checkbox"><label for="label-const_is_empty"><h2 class="lint-title"><div class="panel-title-name" id="lint-const_is_empty">const_is_empty
<a href="#const_is_empty" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>It identifies calls to <code>.is_empty()</code> on constant values.</p>
<h3>Why is this bad?</h3>
<p>String literals and constant values are known at compile time. Checking if they
are empty will always return the same value. This might not be the intention of
the expression.</p>
<h3>Example</h3>
<pre><code class="language-rust">let value = "";
if value.is_empty() {
    println!("the string is empty");
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">println!("the string is empty");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.79.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+const_is_empty">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4139">View Source</a></div></div></div></article><article id="copy_iterator"><input id="label-copy_iterator" type="checkbox"><label for="label-copy_iterator"><h2 class="lint-title"><div class="panel-title-name" id="lint-copy_iterator">copy_iterator
<a href="#copy_iterator" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for types that implement <code>Copy</code> as well as
<code>Iterator</code>.</p>
<h3>Why is this bad?</h3>
<p>Implicit copies can be confusing when working with
iterator combinators.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[derive(Copy, Clone)]
struct Countdown(u8);

impl Iterator for Countdown {
    // ...
}

let a: Vec&lt;_&gt; = my_iterator.take(1).collect();
let b: Vec&lt;_&gt; = my_iterator.collect();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.30.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+copy_iterator">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/copy_iterator.rs#L8">View Source</a></div></div></div></article><article id="crate_in_macro_def"><input id="label-crate_in_macro_def" type="checkbox"><label for="label-crate_in_macro_def"><h2 class="lint-title"><div class="panel-title-name" id="lint-crate_in_macro_def">crate_in_macro_def
<a href="#crate_in_macro_def" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>crate</code> as opposed to <code>$crate</code> in a macro definition.</p>
<h3>Why is this bad?</h3>
<p><code>crate</code> refers to the macro call’s crate, whereas <code>$crate</code> refers to the macro definition’s
crate. Rarely is the former intended. See:
https://doc.rust-lang.org/reference/macros-by-example.html#hygiene</p>
<h3>Example</h3>
<pre><code class="language-rust">#[macro_export]
macro_rules! print_message {
    () =&gt; {
        println!("{}", crate::MESSAGE);
    };
}
pub const MESSAGE: &amp;str = "Hello!";
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[macro_export]
macro_rules! print_message {
    () =&gt; {
        println!("{}", $crate::MESSAGE);
    };
}
pub const MESSAGE: &amp;str = "Hello!";
</code></pre>
<p>Note that if the use of <code>crate</code> is intentional, an <code>allow</code> attribute can be applied to the
macro definition, e.g.:</p>
<pre><code class="language-rust">#[allow(clippy::crate_in_macro_def)]
macro_rules! ok { ... crate::foo ... }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+crate_in_macro_def">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/crate_in_macro_def.rs#L11">View Source</a></div></div></div></article><article id="create_dir"><input id="label-create_dir" type="checkbox"><label for="label-create_dir"><h2 class="lint-title"><div class="panel-title-name" id="lint-create_dir">create_dir
<a href="#create_dir" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks usage of <code>std::fs::create_dir</code> and suggest using <code>std::fs::create_dir_all</code> instead.</p>
<h3>Why restrict this?</h3>
<p>Sometimes <code>std::fs::create_dir</code> is mistakenly chosen over <code>std::fs::create_dir_all</code>,
resulting in failure when more than one directory needs to be created or when the directory already exists.
Crates which never need to specifically create a single directory may wish to prevent this mistake.</p>
<h3>Example</h3>
<pre><code class="language-rust">std::fs::create_dir("foo");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">std::fs::create_dir_all("foo");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.48.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+create_dir">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/create_dir.rs#L8">View Source</a></div></div></div></article><article id="crosspointer_transmute"><input id="label-crosspointer_transmute" type="checkbox"><label for="label-crosspointer_transmute"><h2 class="lint-title"><div class="panel-title-name" id="lint-crosspointer_transmute">crosspointer_transmute
<a href="#crosspointer_transmute" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for transmutes between a type <code>T</code> and <code>*T</code>.</p>
<h3>Why is this bad?</h3>
<p>It’s easy to mistakenly transmute between a type and a
pointer to that type.</p>
<h3>Example</h3>
<pre><code class="language-rust">core::intrinsics::transmute(t) // where the result type is the same as
                               // `*t` or `&amp;t`'s
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+crosspointer_transmute">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/transmute/mod.rs#L96">View Source</a></div></div></div></article><article id="dbg_macro"><input id="label-dbg_macro" type="checkbox"><label for="label-dbg_macro"><h2 class="lint-title"><div class="panel-title-name" id="lint-dbg_macro">dbg_macro
<a href="#dbg_macro" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of the <a href="https://doc.rust-lang.org/std/macro.dbg.html"><code>dbg!</code></a> macro.</p>
<h3>Why restrict this?</h3>
<p>The <code>dbg!</code> macro is intended as a debugging tool. It should not be present in released
software or committed to a version control system.</p>
<h3>Example</h3>
<pre><code class="language-rust">dbg!(true)
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">true
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allow-dbg-in-tests</code>:  Whether <code>dbg!</code> should be allowed in test functions or <code>#[cfg(test)]</code></p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.34.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+dbg_macro">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/dbg_macro.rs#L13">View Source</a></div></div></div></article><article id="debug_assert_with_mut_call"><input id="label-debug_assert_with_mut_call" type="checkbox"><label for="label-debug_assert_with_mut_call"><h2 class="lint-title"><div class="panel-title-name" id="lint-debug_assert_with_mut_call">debug_assert_with_mut_call
<a href="#debug_assert_with_mut_call" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for function/method calls with a mutable
parameter in <code>debug_assert!</code>, <code>debug_assert_eq!</code> and <code>debug_assert_ne!</code> macros.</p>
<h3>Why is this bad?</h3>
<p>In release builds <code>debug_assert!</code> macros are optimized out by the
compiler.
Therefore mutating something in a <code>debug_assert!</code> macro results in different behavior
between a release and debug build.</p>
<h3>Example</h3>
<pre><code class="language-rust">debug_assert_eq!(vec![3].pop(), Some(3));

// or

debug_assert!(takes_a_mut_parameter(&amp;mut x));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.40.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+debug_assert_with_mut_call">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/mutable_debug_assertion.rs#L12">View Source</a></div></div></div></article><article id="decimal_bitwise_operands"><input id="label-decimal_bitwise_operands" type="checkbox"><label for="label-decimal_bitwise_operands"><h2 class="lint-title"><div class="panel-title-name" id="lint-decimal_bitwise_operands">decimal_bitwise_operands
<a href="#decimal_bitwise_operands" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for decimal literals used as bit masks in bitwise operations.</p>
<h3>Why is this bad?</h3>
<p>Using decimal literals for bit masks can make the code less readable and obscure the intended bit pattern.
Binary, hexadecimal, or octal literals make the bit pattern more explicit and easier to understand at a glance.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = 14 &amp; 6; // Bit pattern is not immediately clear
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a = 0b1110 &amp; 0b0110;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.93.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+decimal_bitwise_operands">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L939">View Source</a></div></div></div></article><article id="decimal_literal_representation"><input id="label-decimal_literal_representation" type="checkbox"><label for="label-decimal_literal_representation"><h2 class="lint-title"><div class="panel-title-name" id="lint-decimal_literal_representation">decimal_literal_representation
<a href="#decimal_literal_representation" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns if there is a better representation for a numeric literal.</p>
<h3>Why restrict this?</h3>
<p>Especially for big powers of 2, a hexadecimal representation is usually more
readable than a decimal representation.</p>
<h3>Example</h3>
<pre><code class="language-text">`255` =&gt; `0xFF`
`65_535` =&gt; `0xFFFF`
`4_042_322_160` =&gt; `0xF0F0_F0F0`
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>literal-representation-threshold</code>:  The lower bound for linting decimal literals</p>
<p>(default: <code>16384</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+decimal_literal_representation">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/literal_representation.rs#L128">View Source</a></div></div></div></article><article id="declare_interior_mutable_const"><input id="label-declare_interior_mutable_const" type="checkbox"><label for="label-declare_interior_mutable_const"><h2 class="lint-title"><div class="panel-title-name" id="lint-declare_interior_mutable_const">declare_interior_mutable_const
<a href="#declare_interior_mutable_const" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the declaration of named constant which contain interior mutability.</p>
<h3>Why is this bad?</h3>
<p>Named constants are copied at every use site which means any change to their value
will be lost after the newly created value is dropped. e.g.</p>
<pre><code class="language-rust">use core::sync::atomic::{AtomicUsize, Ordering};
const ATOMIC: AtomicUsize = AtomicUsize::new(0);
fn add_one() -&gt; usize {
    // This will always return `0` since `ATOMIC` is copied before it's used.
    ATOMIC.fetch_add(1, Ordering::AcqRel)
}
</code></pre>
<p>If shared modification of the value is desired, a <code>static</code> item is needed instead.
If that is not desired, a <code>const fn</code> constructor should be used to make it obvious
at the use site that a new value is created.</p>
<h3>Known problems</h3>
<p>Prior to <code>const fn</code> stabilization this was the only way to provide a value which
could initialize a <code>static</code> item (e.g. the <code>std::sync::ONCE_INIT</code> constant). In
this case the use of <code>const</code> is required and this lint should be suppressed.</p>
<p>There also exists types which contain private fields with interior mutability, but
no way to both create a value as a constant and modify any mutable field using the
type’s public interface (e.g. <code>bytes::Bytes</code>). As there is no reasonable way to
scan a crate’s interface to see if this is the case, all such types will be linted.
If this happens use the <code>ignore-interior-mutability</code> configuration option to allow
the type.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};

const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);
CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged
assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">static STATIC_ATOM: AtomicUsize = AtomicUsize::new(15);
STATIC_ATOM.store(9, SeqCst);
assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>ignore-interior-mutability</code>:  A list of paths to types that should be treated as if they do not contain interior mutability</p>
<p>(default: <code>["bytes::Bytes"]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+declare_interior_mutable_const">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/non_copy_const.rs#L45">View Source</a></div></div></div></article><article id="default_constructed_unit_structs"><input id="label-default_constructed_unit_structs" type="checkbox"><label for="label-default_constructed_unit_structs"><h2 class="lint-title"><div class="panel-title-name" id="lint-default_constructed_unit_structs">default_constructed_unit_structs
<a href="#default_constructed_unit_structs" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for construction on unit struct using <code>default</code>.</p>
<h3>Why is this bad?</h3>
<p>This adds code complexity and an unnecessary function call.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[derive(Default)]
struct S&lt;T&gt; {
    _marker: PhantomData&lt;T&gt;
}

let _: S&lt;i32&gt; = S {
    _marker: PhantomData::default()
};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct S&lt;T&gt; {
    _marker: PhantomData&lt;T&gt;
}

let _: S&lt;i32&gt; = S {
    _marker: PhantomData
};
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.71.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+default_constructed_unit_structs">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/default_constructed_unit_structs.rs#L13">View Source</a></div></div></div></article><article id="default_instead_of_iter_empty"><input id="label-default_instead_of_iter_empty" type="checkbox"><label for="label-default_instead_of_iter_empty"><h2 class="lint-title"><div class="panel-title-name" id="lint-default_instead_of_iter_empty">default_instead_of_iter_empty
<a href="#default_instead_of_iter_empty" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>It checks for <code>std::iter::Empty::default()</code> and suggests replacing it with
<code>std::iter::empty()</code>.</p>
<h3>Why is this bad?</h3>
<p><code>std::iter::empty()</code> is the more idiomatic way.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = std::iter::Empty::&lt;usize&gt;::default();
let iter: std::iter::Empty&lt;usize&gt; = std::iter::Empty::default();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = std::iter::empty::&lt;usize&gt;();
let iter: std::iter::Empty&lt;usize&gt; = std::iter::empty();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.64.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+default_instead_of_iter_empty">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/default_instead_of_iter_empty.rs#L10">View Source</a></div></div></div></article><article id="default_numeric_fallback"><input id="label-default_numeric_fallback" type="checkbox"><label for="label-default_numeric_fallback"><h2 class="lint-title"><div class="panel-title-name" id="lint-default_numeric_fallback">default_numeric_fallback
<a href="#default_numeric_fallback" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of unconstrained numeric literals which may cause default numeric fallback in type
inference.</p>
<p>Default numeric fallback means that if numeric types have not yet been bound to concrete
types at the end of type inference, then integer type is bound to <code>i32</code>, and similarly
floating type is bound to <code>f64</code>.</p>
<p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0212-restore-int-fallback.md">RFC0212</a> for more information about the fallback.</p>
<h3>Why restrict this?</h3>
<p>To ensure that every numeric type is chosen explicitly rather than implicitly.</p>
<h3>Known problems</h3>
<p>This lint is implemented using a custom algorithm independent of rustc’s inference,
which results in many false positives and false negatives.</p>
<h3>Example</h3>
<pre><code class="language-rust">let i = 10;
let f = 1.23;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let i = 10_i32;
let f = 1.23_f64;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.52.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+default_numeric_fallback">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/default_numeric_fallback.rs#L16">View Source</a></div></div></div></article><article id="default_trait_access"><input id="label-default_trait_access" type="checkbox"><label for="label-default_trait_access"><h2 class="lint-title"><div class="panel-title-name" id="lint-default_trait_access">default_trait_access
<a href="#default_trait_access" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for literal calls to <code>Default::default()</code>.</p>
<h3>Why is this bad?</h3>
<p>It’s easier for the reader if the name of the type is used, rather than the
generic <code>Default</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let s: String = Default::default();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let s = String::default();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+default_trait_access">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/default.rs#L15">View Source</a></div></div></div></article><article id="default_union_representation"><input id="label-default_union_representation" type="checkbox"><label for="label-default_union_representation"><h2 class="lint-title"><div class="panel-title-name" id="lint-default_union_representation">default_union_representation
<a href="#default_union_representation" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Displays a warning when a union is declared with the default representation (without a <code>#[repr(C)]</code> attribute).</p>
<h3>Why restrict this?</h3>
<p>Unions in Rust have unspecified layout by default, despite many people thinking that they
lay out each field at the start of the union (like C does). That is, there are no guarantees
about the offset of the fields for unions with multiple non-ZST fields without an explicitly
specified layout. These cases may lead to undefined behavior in unsafe blocks.</p>
<h3>Example</h3>
<pre><code class="language-rust">union Foo {
    a: i32,
    b: u32,
}

fn main() {
    let _x: u32 = unsafe {
        Foo { a: 0_i32 }.b // Undefined behavior: `b` is allowed to be padding
    };
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[repr(C)]
union Foo {
    a: i32,
    b: u32,
}

fn main() {
    let _x: u32 = unsafe {
        Foo { a: 0_i32 }.b // Now defined behavior, this is just an i32 -&gt; u32 transmute
    };
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.60.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+default_union_representation">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/default_union_representation.rs#L9">View Source</a></div></div></div></article><article id="deprecated_cfg_attr"><input id="label-deprecated_cfg_attr" type="checkbox"><label for="label-deprecated_cfg_attr"><h2 class="lint-title"><div class="panel-title-name" id="lint-deprecated_cfg_attr">deprecated_cfg_attr
<a href="#deprecated_cfg_attr" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>#[cfg_attr(rustfmt, rustfmt_skip)]</code> and suggests to replace it
with <code>#[rustfmt::skip]</code>.</p>
<h3>Why is this bad?</h3>
<p>Since tool_attributes (<a href="https://github.com/rust-lang/rust/issues/44690">rust-lang/rust#44690</a>)
are stable now, they should be used instead of the old <code>cfg_attr(rustfmt)</code> attributes.</p>
<h3>Known problems</h3>
<p>This lint doesn’t detect crate level inner attributes, because they get
processed before the PreExpansionPass lints get executed. See
<a href="https://github.com/rust-lang/rust-clippy/pull/3123#issuecomment-422321765">#3123</a></p>
<h3>Example</h3>
<pre><code class="language-rust">#[cfg_attr(rustfmt, rustfmt_skip)]
fn main() { }
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[rustfmt::skip]
fn main() { }
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.32.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+deprecated_cfg_attr">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/attrs/mod.rs#L153">View Source</a></div></div></div></article><article id="deprecated_clippy_cfg_attr"><input id="label-deprecated_clippy_cfg_attr" type="checkbox"><label for="label-deprecated_clippy_cfg_attr"><h2 class="lint-title"><div class="panel-title-name" id="lint-deprecated_clippy_cfg_attr">deprecated_clippy_cfg_attr
<a href="#deprecated_clippy_cfg_attr" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>#[cfg_attr(feature = "cargo-clippy", ...)]</code> and for
<code>#[cfg(feature = "cargo-clippy")]</code> and suggests to replace it with
<code>#[cfg_attr(clippy, ...)]</code> or <code>#[cfg(clippy)]</code>.</p>
<h3>Why is this bad?</h3>
<p>This feature has been deprecated for years and shouldn’t be used anymore.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[cfg(feature = "cargo-clippy")]
struct Bar;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[cfg(clippy)]
struct Bar;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.78.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+deprecated_clippy_cfg_attr">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/attrs/mod.rs#L339">View Source</a></div></div></div></article><article id="deprecated_semver"><input id="label-deprecated_semver" type="checkbox"><label for="label-deprecated_semver"><h2 class="lint-title"><div class="panel-title-name" id="lint-deprecated_semver">deprecated_semver
<a href="#deprecated_semver" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>#[deprecated]</code> annotations with a <code>since</code>
field that is not a valid semantic version. Also allows “TBD” to signal
future deprecation.</p>
<h3>Why is this bad?</h3>
<p>For checking the version of the deprecation, it must be
a valid semver. Failing that, the contained information is useless.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[deprecated(since = "forever")]
fn something_else() { /* ... */ }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+deprecated_semver">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/attrs/mod.rs#L109">View Source</a></div></div></div></article><article id="deref_addrof"><input id="label-deref_addrof" type="checkbox"><label for="label-deref_addrof"><h2 class="lint-title"><div class="panel-title-name" id="lint-deref_addrof">deref_addrof
<a href="#deref_addrof" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>*&amp;</code> and <code>*&amp;mut</code> in expressions.</p>
<h3>Why is this bad?</h3>
<p>Immediately dereferencing a reference is no-op and
makes the code less clear.</p>
<h3>Known problems</h3>
<p>Multiple dereference/addrof pairs are not handled so
the suggested fix for <code>x = **&amp;&amp;y</code> is <code>x = *&amp;y</code>, which is still incorrect.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = f(*&amp;mut b);
let c = *&amp;d;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a = f(b);
let c = d;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+deref_addrof">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/reference.rs#L10">View Source</a></div></div></div></article><article id="deref_by_slicing"><input id="label-deref_by_slicing" type="checkbox"><label for="label-deref_by_slicing"><h2 class="lint-title"><div class="panel-title-name" id="lint-deref_by_slicing">deref_by_slicing
<a href="#deref_by_slicing" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for slicing expressions which are equivalent to dereferencing the
value.</p>
<h3>Why restrict this?</h3>
<p>Some people may prefer to dereference rather than slice.</p>
<h3>Example</h3>
<pre><code class="language-rust">let vec = vec![1, 2, 3];
let slice = &amp;vec[..];
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let vec = vec![1, 2, 3];
let slice = &amp;*vec;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.61.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+deref_by_slicing">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/redundant_slicing.rs#L45">View Source</a></div></div></div></article><article id="derivable_impls"><input id="label-derivable_impls" type="checkbox"><label for="label-derivable_impls"><h2 class="lint-title"><div class="panel-title-name" id="lint-derivable_impls">derivable_impls
<a href="#derivable_impls" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects manual <code>std::default::Default</code> implementations that are identical to a derived implementation.</p>
<h3>Why is this bad?</h3>
<p>It is less concise.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Foo {
    bar: bool
}

impl Default for Foo {
    fn default() -&gt; Self {
        Self {
            bar: false
        }
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[derive(Default)]
struct Foo {
    bar: bool
}
</code></pre>
<h3>Known problems</h3>
<p>Derive macros <a href="https://github.com/rust-lang/rust/issues/26925">sometimes use incorrect bounds</a>
in generic types and the user defined <code>impl</code> may be more generalized or
specialized than what derive will produce. This lint can’t detect the manual <code>impl</code>
has exactly equal bounds, and therefore this lint is disabled for types with
generic parameters.</p>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.57.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+derivable_impls">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/derivable_impls.rs#L17">View Source</a></div></div></div></article><article id="derive_ord_xor_partial_ord"><input id="label-derive_ord_xor_partial_ord" type="checkbox"><label for="label-derive_ord_xor_partial_ord"><h2 class="lint-title"><div class="panel-title-name" id="lint-derive_ord_xor_partial_ord">derive_ord_xor_partial_ord
<a href="#derive_ord_xor_partial_ord" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Lints against manual <code>PartialOrd</code> and <code>Ord</code> implementations for types with a derived <code>Ord</code>
or <code>PartialOrd</code> implementation.</p>
<h3>Why is this bad?</h3>
<p>The implementation of these traits must agree (for
example for use with <code>sort</code>) so it’s probably a bad idea to use a
default-generated <code>Ord</code> implementation with an explicitly defined
<code>PartialOrd</code>. In particular, the following must hold for any type
implementing <code>Ord</code>:</p>
<pre><code class="language-text">k1.cmp(&amp;k2) == k1.partial_cmp(&amp;k2).unwrap()
</code></pre>
<h3>Example</h3>
<pre><code class="language-rust">#[derive(Ord, PartialEq, Eq)]
struct Foo;

impl PartialOrd for Foo {
    ...
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[derive(PartialEq, Eq)]
struct Foo;

impl PartialOrd for Foo {
    fn partial_cmp(&amp;self, other: &amp;Foo) -&gt; Option&lt;Ordering&gt; {
       Some(self.cmp(other))
    }
}

impl Ord for Foo {
    ...
}
</code></pre>
<p>or, if you don’t need a custom ordering:</p>
<pre><code class="language-rust">#[derive(Ord, PartialOrd, PartialEq, Eq)]
struct Foo;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.47.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+derive_ord_xor_partial_ord">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/derive/mod.rs#L43">View Source</a></div></div></div></article><article id="derive_partial_eq_without_eq"><input id="label-derive_partial_eq_without_eq" type="checkbox"><label for="label-derive_partial_eq_without_eq"><h2 class="lint-title"><div class="panel-title-name" id="lint-derive_partial_eq_without_eq">derive_partial_eq_without_eq
<a href="#derive_partial_eq_without_eq" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for types that derive <code>PartialEq</code> and could implement <code>Eq</code>.</p>
<h3>Why is this bad?</h3>
<p>If a type <code>T</code> derives <code>PartialEq</code> and all of its members implement <code>Eq</code>,
then <code>T</code> can always implement <code>Eq</code>. Implementing <code>Eq</code> allows <code>T</code> to be used
in APIs that require <code>Eq</code> types. It also allows structs containing <code>T</code> to derive
<code>Eq</code> themselves.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[derive(PartialEq)]
struct Foo {
    i_am_eq: i32,
    i_am_eq_too: Vec&lt;String&gt;,
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[derive(PartialEq, Eq)]
struct Foo {
    i_am_eq: i32,
    i_am_eq_too: Vec&lt;String&gt;,
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.63.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+derive_partial_eq_without_eq">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/derive/mod.rs#L155">View Source</a></div></div></div></article><article id="derived_hash_with_manual_eq"><input id="label-derived_hash_with_manual_eq" type="checkbox"><label for="label-derived_hash_with_manual_eq"><h2 class="lint-title"><div class="panel-title-name" id="lint-derived_hash_with_manual_eq">derived_hash_with_manual_eq
<a href="#derived_hash_with_manual_eq" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Lints against manual <code>PartialEq</code> implementations for types with a derived <code>Hash</code>
implementation.</p>
<h3>Why is this bad?</h3>
<p>The implementation of these traits must agree (for
example for use with <code>HashMap</code>) so it’s probably a bad idea to use a
default-generated <code>Hash</code> implementation with an explicitly defined
<code>PartialEq</code>. In particular, the following must hold for any type:</p>
<pre><code class="language-text">k1 == k2 ⇒ hash(k1) == hash(k2)
</code></pre>
<h3>Example</h3>
<pre><code class="language-rust">#[derive(Hash)]
struct Foo;

impl PartialEq for Foo {
    ...
}
</code></pre>
<h3>Past names</h3>
<ul>
<li>derive_hash_xor_eq</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+derived_hash_with_manual_eq">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/derive/mod.rs#L13">View Source</a></div></div></div></article><article id="disallowed_macros"><input id="label-disallowed_macros" type="checkbox"><label for="label-disallowed_macros"><h2 class="lint-title"><div class="panel-title-name" id="lint-disallowed_macros">disallowed_macros
<a href="#disallowed_macros" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Denies the configured macros in clippy.toml</p>
<p>Note: Even though this lint is warn-by-default, it will only trigger if
macros are defined in the clippy.toml file.</p>
<h3>Why is this bad?</h3>
<p>Some macros are undesirable in certain contexts, and it’s beneficial to
lint for them as needed.</p>
<h3>Example</h3>
<p>An example clippy.toml configuration:</p>
<pre><code class="language-toml">disallowed-macros = [
    # Can use a string as the path of the disallowed macro.
    "std::print",
    # Can also use an inline table with a `path` key.
    { path = "std::println" },
    # When using an inline table, can add a `reason` for why the macro
    # is disallowed.
    { path = "serde::Serialize", reason = "no serializing" },
    # This would normally error if the path is incorrect, but with `allow-invalid` = `true`,
    # it will be silently ignored
    { path = "std::invalid_macro", reason = "use alternative instead", allow-invalid = true }
]
</code></pre>
<pre><code class="language-rust">use serde::Serialize;

println!("warns");

// The diagnostic will contain the message "no serializing"
#[derive(Serialize)]
struct Data {
    name: String,
    value: usize,
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li><code>disallowed-macros</code>:  The list of disallowed macros, written as fully qualified paths.</li>
</ul>
<p><strong>Fields:</strong></p>
<ul>
<li>
<p><code>path</code> (required): the fully qualified path to the macro that should be disallowed</p>
</li>
<li>
<p><code>reason</code> (optional): explanation why this macro is disallowed</p>
</li>
<li>
<p><code>replacement</code> (optional): suggested alternative macro</p>
</li>
<li>
<p><code>allow-invalid</code> (optional, <code>false</code> by default): when set to <code>true</code>, it will ignore this entry
if the path doesn’t exist, instead of emitting an error</p>
<p>(default: <code>[]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.66.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+disallowed_macros">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/disallowed_macros.rs#L20">View Source</a></div></div></div></article><article id="disallowed_methods"><input id="label-disallowed_methods" type="checkbox"><label for="label-disallowed_methods"><h2 class="lint-title"><div class="panel-title-name" id="lint-disallowed_methods">disallowed_methods
<a href="#disallowed_methods" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Denies the configured methods and functions in clippy.toml</p>
<p>Note: Even though this lint is warn-by-default, it will only trigger if
methods are defined in the clippy.toml file.</p>
<h3>Why is this bad?</h3>
<p>Some methods are undesirable in certain contexts, and it’s beneficial to
lint for them as needed.</p>
<h3>Example</h3>
<p>An example clippy.toml configuration:</p>
<pre><code class="language-toml">disallowed-methods = [
    # Can use a string as the path of the disallowed method.
    "std::boxed::Box::new",
    # Can also use an inline table with a `path` key.
    { path = "std::time::Instant::now" },
    # When using an inline table, can add a `reason` for why the method
    # is disallowed.
    { path = "std::vec::Vec::leak", reason = "no leaking memory" },
    # Can also add a `replacement` that will be offered as a suggestion.
    { path = "std::sync::Mutex::new", reason = "prefer faster &amp; simpler non-poisonable mutex", replacement = "parking_lot::Mutex::new" },
    # This would normally error if the path is incorrect, but with `allow-invalid` = `true`,
    # it will be silently ignored
    { path = "std::fs::InvalidPath", reason = "use alternative instead", allow-invalid = true },
]
</code></pre>
<pre><code class="language-rust">let xs = vec![1, 2, 3, 4];
xs.leak(); // Vec::leak is disallowed in the config.
// The diagnostic contains the message "no leaking memory".

let _now = Instant::now(); // Instant::now is disallowed in the config.

let _box = Box::new(3); // Box::new is disallowed in the config.
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut xs = Vec::new(); // Vec::new is _not_ disallowed in the config.
xs.push(123); // Vec::push is _not_ disallowed in the config.
</code></pre>
<h3>Past names</h3>
<ul>
<li>disallowed_method</li>
</ul>
<h3>Configuration</h3>
<ul>
<li><code>disallowed-methods</code>:  The list of disallowed methods, written as fully qualified paths.</li>
</ul>
<p><strong>Fields:</strong></p>
<ul>
<li>
<p><code>path</code> (required): the fully qualified path to the method that should be disallowed</p>
</li>
<li>
<p><code>reason</code> (optional): explanation why this method is disallowed</p>
</li>
<li>
<p><code>replacement</code> (optional): suggested alternative method</p>
</li>
<li>
<p><code>allow-invalid</code> (optional, <code>false</code> by default): when set to <code>true</code>, it will ignore this entry
if the path doesn’t exist, instead of emitting an error</p>
<p>(default: <code>[]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+disallowed_methods">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/disallowed_methods.rs#L12">View Source</a></div></div></div></article><article id="disallowed_names"><input id="label-disallowed_names" type="checkbox"><label for="label-disallowed_names"><h2 class="lint-title"><div class="panel-title-name" id="lint-disallowed_names">disallowed_names
<a href="#disallowed_names" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of disallowed names for variables, such
as <code>foo</code>.</p>
<h3>Why is this bad?</h3>
<p>These names are usually placeholder names and should be
avoided.</p>
<h3>Example</h3>
<pre><code class="language-rust">let foo = 3.14;
</code></pre>
<h3>Past names</h3>
<ul>
<li>blacklisted_name</li>
</ul>
<h3>Configuration</h3>
<ul>
<li>
<p><code>disallowed-names</code>:  The list of disallowed names to lint about. NB: <code>bar</code> is not here since it has legitimate uses. The value
<code>".."</code> can be used as part of the list to indicate that the configured values should be appended to the
default configuration of Clippy. By default, any configuration will replace the default value.</p>
<p>(default: <code>["foo", "baz", "quux"]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+disallowed_names">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/disallowed_names.rs#L10">View Source</a></div></div></div></article><article id="disallowed_script_idents"><input id="label-disallowed_script_idents" type="checkbox"><label for="label-disallowed_script_idents"><h2 class="lint-title"><div class="panel-title-name" id="lint-disallowed_script_idents">disallowed_script_idents
<a href="#disallowed_script_idents" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of unicode scripts other than those explicitly allowed
by the lint config.</p>
<p>This lint doesn’t take into account non-text scripts such as <code>Unknown</code> and <code>Linear_A</code>.
It also ignores the <code>Common</code> script type.
While configuring, be sure to use official script name <a href="http://www.unicode.org/reports/tr24/tr24-31.html#Script_Value_Aliases">aliases</a> from
<a href="https://www.unicode.org/iso15924/iso15924-codes.html">the list of supported scripts</a>.</p>
<p>See also: <a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#non-ascii-idents"><code>non_ascii_idents</code></a>.</p>
<h3>Why restrict this?</h3>
<p>It may be not desired to have many different scripts for
identifiers in the codebase.</p>
<p>Note that if you only want to allow typical English, you might want to use
built-in <a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#non-ascii-idents"><code>non_ascii_idents</code></a> lint instead.</p>
<h3>Example</h3>
<pre><code class="language-rust">// Assuming that `clippy.toml` contains the following line:
// allowed-scripts = ["Latin", "Cyrillic"]
let counter = 10; // OK, latin is allowed.
let счётчик = 10; // OK, cyrillic is allowed.
let zähler = 10; // OK, it's still latin.
let カウンタ = 10; // Will spawn the lint.
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allowed-scripts</code>:  The list of unicode scripts allowed to be used in the scope.</p>
<p>(default: <code>["Latin"]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.55.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+disallowed_script_idents">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/disallowed_script_idents.rs#L9">View Source</a></div></div></div></article><article id="disallowed_types"><input id="label-disallowed_types" type="checkbox"><label for="label-disallowed_types"><h2 class="lint-title"><div class="panel-title-name" id="lint-disallowed_types">disallowed_types
<a href="#disallowed_types" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Denies the configured types in clippy.toml.</p>
<p>Note: Even though this lint is warn-by-default, it will only trigger if
types are defined in the clippy.toml file.</p>
<h3>Why is this bad?</h3>
<p>Some types are undesirable in certain contexts.</p>
<h3>Example:</h3>
<p>An example clippy.toml configuration:</p>
<pre><code class="language-toml">disallowed-types = [
    # Can use a string as the path of the disallowed type.
    "std::collections::BTreeMap",
    # Can also use an inline table with a `path` key.
    { path = "std::net::TcpListener" },
    # When using an inline table, can add a `reason` for why the type
    # is disallowed.
    { path = "std::net::Ipv4Addr", reason = "no IPv4 allowed" },
    # Can also add a `replacement` that will be offered as a suggestion.
    { path = "std::sync::Mutex", reason = "prefer faster &amp; simpler non-poisonable mutex", replacement = "parking_lot::Mutex" },
    # This would normally error if the path is incorrect, but with `allow-invalid` = `true`,
    # it will be silently ignored
    { path = "std::invalid::Type", reason = "use alternative instead", allow-invalid = true }
]
</code></pre>
<pre><code class="language-rust">use std::collections::BTreeMap;
// or its use
let x = std::collections::BTreeMap::new();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// A similar type that is allowed by the config
use std::collections::HashMap;
</code></pre>
<h3>Past names</h3>
<ul>
<li>disallowed_type</li>
</ul>
<h3>Configuration</h3>
<ul>
<li><code>disallowed-types</code>:  The list of disallowed types, written as fully qualified paths.</li>
</ul>
<p><strong>Fields:</strong></p>
<ul>
<li>
<p><code>path</code> (required): the fully qualified path to the type that should be disallowed</p>
</li>
<li>
<p><code>reason</code> (optional): explanation why this type is disallowed</p>
</li>
<li>
<p><code>replacement</code> (optional): suggested alternative type</p>
</li>
<li>
<p><code>allow-invalid</code> (optional, <code>false</code> by default): when set to <code>true</code>, it will ignore this entry
if the path doesn’t exist, instead of emitting an error</p>
<p>(default: <code>[]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.55.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+disallowed_types">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/disallowed_types.rs#L14">View Source</a></div></div></div></article><article id="diverging_sub_expression"><input id="label-diverging_sub_expression" type="checkbox"><label for="label-diverging_sub_expression"><h2 class="lint-title"><div class="panel-title-name" id="lint-diverging_sub_expression">diverging_sub_expression
<a href="#diverging_sub_expression" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for diverging calls that are not match arms or
statements.</p>
<h3>Why is this bad?</h3>
<p>It is often confusing to read. In addition, the
sub-expression evaluation order for Rust is not well documented.</p>
<h3>Known problems</h3>
<p>Someone might want to use <code>some_bool || panic!()</code> as a
shorthand.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = b() || panic!() || c();
// `c()` is dead, `panic!()` is only called if `b()` returns `false`
let x = (a, b, c, panic!());
// can simply be replaced by `panic!()`
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+diverging_sub_expression">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/mixed_read_write_in_expression.rs#L54">View Source</a></div></div></div></article><article id="doc_broken_link"><input id="label-doc_broken_link" type="checkbox"><label for="label-doc_broken_link"><h2 class="lint-title"><div class="panel-title-name" id="lint-doc_broken_link">doc_broken_link
<a href="#doc_broken_link" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks the doc comments have unbroken links, mostly caused
by bad formatted links such as broken across multiple lines.</p>
<h3>Why is this bad?</h3>
<p>Because documentation generated by rustdoc will be broken
since expected links won’t be links and just text.</p>
<h3>Examples</h3>
<p>This link is broken:</p>
<pre><code class="language-rust">/// [example of a bad link](https://
/// github.com/rust-lang/rust-clippy/)
pub fn do_something() {}
</code></pre>
<p>It shouldn’t be broken across multiple lines to work:</p>
<pre><code class="language-rust">/// [example of a good link](https://github.com/rust-lang/rust-clippy/)
pub fn do_something() {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.90.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+doc_broken_link">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L299">View Source</a></div></div></div></article><article id="doc_comment_double_space_linebreaks"><input id="label-doc_comment_double_space_linebreaks" type="checkbox"><label for="label-doc_comment_double_space_linebreaks"><h2 class="lint-title"><div class="panel-title-name" id="lint-doc_comment_double_space_linebreaks">doc_comment_double_space_linebreaks
<a href="#doc_comment_double_space_linebreaks" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects doc comment linebreaks that use double spaces to separate lines, instead of back-slash (<code>\</code>).</p>
<h3>Why is this bad?</h3>
<p>Double spaces, when used as doc comment linebreaks, can be difficult to see, and may
accidentally be removed during automatic formatting or manual refactoring. The use of a back-slash (<code>\</code>)
is clearer in this regard.</p>
<h3>Example</h3>
<p>The two replacement dots in this example represent a double space.</p>
<pre><code class="language-rust">/// This command takes two numbers as inputs and··
/// adds them together, and then returns the result.
fn add(l: i32, r: i32) -&gt; i32 {
    l + r
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">/// This command takes two numbers as inputs and\
/// adds them together, and then returns the result.
fn add(l: i32, r: i32) -&gt; i32 {
    l + r
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.87.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+doc_comment_double_space_linebreaks">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L610">View Source</a></div></div></div></article><article id="doc_include_without_cfg"><input id="label-doc_include_without_cfg" type="checkbox"><label for="label-doc_include_without_cfg"><h2 class="lint-title"><div class="panel-title-name" id="lint-doc_include_without_cfg">doc_include_without_cfg
<a href="#doc_include_without_cfg" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks if included files in doc comments are included only for <code>cfg(doc)</code>.</p>
<h3>Why restrict this?</h3>
<p>These files are not useful for compilation but will still be included.
Also, if any of these non-source code file is updated, it will trigger a
recompilation.</p>
<h3>Known problems</h3>
<p>Excluding this will currently result in the file being left out if
the item’s docs are inlined from another crate. This may be fixed in a
future version of rustdoc.</p>
<h3>Example</h3>
<pre><code class="language-rust">#![doc = include_str!("some_file.md")]
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#![cfg_attr(doc, doc = include_str!("some_file.md"))]
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.85.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+doc_include_without_cfg">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L555">View Source</a></div></div></div></article><article id="doc_lazy_continuation"><input id="label-doc_lazy_continuation" type="checkbox"><label for="label-doc_lazy_continuation"><h2 class="lint-title"><div class="panel-title-name" id="lint-doc_lazy_continuation">doc_lazy_continuation
<a href="#doc_lazy_continuation" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>In CommonMark Markdown, the language used to write doc comments, a
paragraph nested within a list or block quote does not need any line
after the first one to be indented or marked. The specification calls
this a “lazy paragraph continuation.”</p>
<h3>Why is this bad?</h3>
<p>This is easy to write but hard to read. Lazy continuations makes
unintended markers hard to see, and make it harder to deduce the
document’s intended structure.</p>
<h3>Example</h3>
<p>This table is probably intended to have two rows,
but it does not. It has zero rows, and is followed by
a block quote.</p>
<pre><code class="language-rust">/// Range | Description
/// ----- | -----------
/// &gt;= 1  | fully opaque
/// &lt; 1   | partially see-through
fn set_opacity(opacity: f32) {}
</code></pre>
<p>Fix it by escaping the marker:</p>
<pre><code class="language-rust">/// Range | Description
/// ----- | -----------
/// \&gt;= 1 | fully opaque
/// &lt; 1   | partially see-through
fn set_opacity(opacity: f32) {}
</code></pre>
<p>This example is actually intended to be a list:</p>
<pre><code class="language-rust">/// * Do nothing.
/// * Then do something. Whatever it is needs done,
/// it should be done right now.
</code></pre>
<p>Fix it by indenting the list contents:</p>
<pre><code class="language-rust">/// * Do nothing.
/// * Then do something. Whatever it is needs done,
///   it should be done right now.
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.80.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+doc_lazy_continuation">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L434">View Source</a></div></div></div></article><article id="doc_link_code"><input id="label-doc_link_code" type="checkbox"><label for="label-doc_link_code"><h2 class="lint-title"><div class="panel-title-name" id="lint-doc_link_code">doc_link_code
<a href="#doc_link_code" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for links with code directly adjacent to code text:
<code>[`MyItem`]`&lt;`[`u32`]`&gt;`</code>.</p>
<h3>Why is this bad?</h3>
<p>It can be written more simply using HTML-style <code>&lt;code&gt;</code> tags.</p>
<h3>Example</h3>
<pre><code class="language-rust">//! [`first`](x)`second`
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">//! &lt;code&gt;[first](x)second&lt;/code&gt;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.87.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+doc_link_code">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L84">View Source</a></div></div></div></article><article id="doc_link_with_quotes"><input id="label-doc_link_with_quotes" type="checkbox"><label for="label-doc_link_with_quotes"><h2 class="lint-title"><div class="panel-title-name" id="lint-doc_link_with_quotes">doc_link_with_quotes
<a href="#doc_link_with_quotes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects the syntax <code>['foo']</code> in documentation comments (notice quotes instead of backticks)
outside of code blocks</p>
<h3>Why is this bad?</h3>
<p>It is likely a typo when defining an intra-doc link</p>
<h3>Example</h3>
<pre><code class="language-rust">/// See also: ['foo']
fn bar() {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">/// See also: [`foo`]
fn bar() {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.63.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+doc_link_with_quotes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L276">View Source</a></div></div></div></article><article id="doc_markdown"><input id="label-doc_markdown" type="checkbox"><label for="label-doc_markdown"><h2 class="lint-title"><div class="panel-title-name" id="lint-doc_markdown">doc_markdown
<a href="#doc_markdown" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the presence of <code>_</code>, <code>::</code> or camel-case words
outside ticks in documentation.</p>
<h3>Why is this bad?</h3>
<p><em>Rustdoc</em> supports markdown formatting, <code>_</code>, <code>::</code> and
camel-case probably indicates some code which should be included between
ticks. <code>_</code> can also be used for emphasis in markdown, this lint tries to
consider that.</p>
<h3>Known problems</h3>
<p>Lots of bad docs won’t be fixed, what the lint checks
for is limited, and there are still false positives. HTML elements and their
content are not linted.</p>
<p>In addition, when writing documentation comments, including <code>[]</code> brackets
inside a link text would trip the parser. Therefore, documenting link with
<code>[</code>SmallVec&lt;[T; INLINE_CAPACITY]&gt;<code>]</code> and then [<code>SmallVec&lt;[T; INLINE_CAPACITY]&gt;</code>]: SmallVec
would fail.</p>
<h3>Examples</h3>
<pre><code class="language-rust">/// Do something with the foo_bar parameter. See also
/// that::other::module::foo.
// ^ `foo_bar` and `that::other::module::foo` should be ticked.
fn doit(foo_bar: usize) {}
</code></pre>
<pre><code class="language-rust">// Link text with `[]` brackets should be written as following:
/// Consume the array and return the inner
/// [`SmallVec&lt;[T; INLINE_CAPACITY]&gt;`][SmallVec].
/// [SmallVec]: SmallVec
fn main() {}
</code></pre>
<h3>Configuration</h3>
<ul>
<li><code>doc-valid-idents</code>:  The list of words this lint should not consider as identifiers needing ticks. The value
<code>".."</code> can be used as part of the list to indicate, that the configured values should be appended to the
default configuration of Clippy. By default, any configuration will replace the default value. For example:</li>
</ul>
<ul>
<li>
<p><code>doc-valid-idents = ["ClipPy"]</code> would replace the default list with <code>["ClipPy"]</code>.</p>
</li>
<li>
<p><code>doc-valid-idents = ["ClipPy", ".."]</code> would append <code>ClipPy</code> to the default list.</p>
<p>(default: <code>["KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "MHz", "GHz", "THz", "AccessKit", "CoAP", "CoreFoundation", "CoreGraphics", "CoreText", "DevOps", "Direct2D", "Direct3D", "DirectWrite", "DirectX", "ECMAScript", "GPLv2", "GPLv3", "GitHub", "GitLab", "IPv4", "IPv6", "InfiniBand", "RoCE", "ClojureScript", "CoffeeScript", "JavaScript", "PostScript", "PureScript", "TypeScript", "PowerPC", "WebAssembly", "NaN", "NaNs", "OAuth", "GraphQL", "OCaml", "OpenAL", "OpenDNS", "OpenGL", "OpenMP", "OpenSSH", "OpenSSL", "OpenStreetMap", "OpenTelemetry", "OpenType", "WebGL", "WebGL2", "WebGPU", "WebRTC", "WebSocket", "WebTransport", "WebP", "OpenExr", "YCbCr", "sRGB", "TensorFlow", "TrueType", "iOS", "macOS", "FreeBSD", "NetBSD", "OpenBSD", "NixOS", "TeX", "LaTeX", "BibTeX", "BibLaTeX", "MinGW", "CamelCase"]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+doc_markdown">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L42">View Source</a></div></div></div></article><article id="doc_nested_refdefs"><input id="label-doc_nested_refdefs" type="checkbox"><label for="label-doc_nested_refdefs"><h2 class="lint-title"><div class="panel-title-name" id="lint-doc_nested_refdefs">doc_nested_refdefs
<a href="#doc_nested_refdefs" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns if a link reference definition appears at the start of a
list item or quote.</p>
<h3>Why is this bad?</h3>
<p>This is probably intended as an intra-doc link. If it is really
supposed to be a reference definition, it can be written outside
of the list item or quote.</p>
<h3>Example</h3>
<pre><code class="language-rust">//! - [link]: description
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">//! - [link][]: description (for intra-doc link)
//!
//! [link]: destination (for link reference definition)
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.85.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+doc_nested_refdefs">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L584">View Source</a></div></div></div></article><article id="doc_overindented_list_items"><input id="label-doc_overindented_list_items" type="checkbox"><label for="label-doc_overindented_list_items"><h2 class="lint-title"><div class="panel-title-name" id="lint-doc_overindented_list_items">doc_overindented_list_items
<a href="#doc_overindented_list_items" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects overindented list items in doc comments where the continuation
lines are indented more than necessary.</p>
<h3>Why is this bad?</h3>
<p>Overindented list items in doc comments can lead to inconsistent and
poorly formatted documentation when rendered. Excessive indentation may
cause the text to be misinterpreted as a nested list item or code block,
affecting readability and the overall structure of the documentation.</p>
<h3>Example</h3>
<pre><code class="language-rust">/// - This is the first item in a list
///      and this line is overindented.
</code></pre>
<p>Fixes this into:</p>
<pre><code class="language-rust">/// - This is the first item in a list
///   and this line is overindented.
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.86.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+doc_overindented_list_items">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L491">View Source</a></div></div></div></article><article id="doc_paragraphs_missing_punctuation"><input id="label-doc_paragraphs_missing_punctuation" type="checkbox"><label for="label-doc_paragraphs_missing_punctuation"><h2 class="lint-title"><div class="panel-title-name" id="lint-doc_paragraphs_missing_punctuation">doc_paragraphs_missing_punctuation
<a href="#doc_paragraphs_missing_punctuation" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for doc comments whose paragraphs do not end with a period or another punctuation mark.
Various Markdowns constructs are taken into account to avoid false positives.</p>
<h3>Why is this bad?</h3>
<p>A project may wish to enforce consistent doc comments by making sure paragraphs end with a
punctuation mark.</p>
<h3>Example</h3>
<pre><code class="language-rust">/// Returns a random number
///
/// It was chosen by a fair dice roll
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">/// Returns a random number.
///
/// It was chosen by a fair dice roll.
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.93.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+doc_paragraphs_missing_punctuation">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L674">View Source</a></div></div></div></article><article id="doc_suspicious_footnotes"><input id="label-doc_suspicious_footnotes" type="checkbox"><label for="label-doc_suspicious_footnotes"><h2 class="lint-title"><div class="panel-title-name" id="lint-doc_suspicious_footnotes">doc_suspicious_footnotes
<a href="#doc_suspicious_footnotes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects syntax that looks like a footnote reference.</p>
<p>Rustdoc footnotes are compatible with GitHub-Flavored Markdown (GFM).
GFM does not parse a footnote reference unless its definition also
exists. This lint checks for footnote references with missing
definitions, unless it thinks you’re writing a regex.</p>
<h3>Why is this bad?</h3>
<p>This probably means that a footnote was meant to exist,
but was not written.</p>
<h3>Example</h3>
<pre><code class="language-rust">/// This is not a footnote[^1], because no definition exists.
fn my_fn() {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">/// This is a footnote[^1].
///
/// [^1]: defined here
fn my_fn() {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.89.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+doc_suspicious_footnotes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L643">View Source</a></div></div></div></article><article id="double_comparisons"><input id="label-double_comparisons" type="checkbox"><label for="label-double_comparisons"><h2 class="lint-title"><div class="panel-title-name" id="lint-double_comparisons">double_comparisons
<a href="#double_comparisons" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for double comparisons that could be simplified to a single expression.</p>
<h3>Why is this bad?</h3>
<p>Readability.</p>
<h3>Example</h3>
<pre><code class="language-rust">if x == y || x &lt; y {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if x &lt;= y {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+double_comparisons">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L292">View Source</a></div></div></div></article><article id="double_ended_iterator_last"><input id="label-double_ended_iterator_last" type="checkbox"><label for="label-double_ended_iterator_last"><h2 class="lint-title"><div class="panel-title-name" id="lint-double_ended_iterator_last">double_ended_iterator_last
<a href="#double_ended_iterator_last" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>Iterator::last</code> being called on a  <code>DoubleEndedIterator</code>, which can be replaced
with <code>DoubleEndedIterator::next_back</code>.</p>
<h3>Why is this bad?</h3>
<p><code>Iterator::last</code> is implemented by consuming the iterator, which is unnecessary if
the iterator is a <code>DoubleEndedIterator</code>. Since Rust traits do not allow specialization,
<code>Iterator::last</code> cannot be optimized for <code>DoubleEndedIterator</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let last_arg = "echo hello world".split(' ').last();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let last_arg = "echo hello world".split(' ').next_back();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.86.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+double_ended_iterator_last">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4354">View Source</a></div></div></div></article><article id="double_must_use"><input id="label-double_must_use" type="checkbox"><label for="label-double_must_use"><h2 class="lint-title"><div class="panel-title-name" id="lint-double_must_use">double_must_use
<a href="#double_must_use" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for a <code>#[must_use]</code> attribute without
further information on functions and methods that return a type already
marked as <code>#[must_use]</code>.</p>
<h3>Why is this bad?</h3>
<p>The attribute isn’t needed. Not using the result
will already be reported. Alternatively, one can add some text to the
attribute to improve the lint message.</p>
<h3>Examples</h3>
<pre><code class="language-rust">#[must_use]
fn double_must_use() -&gt; Result&lt;(), ()&gt; {
    unimplemented!();
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.40.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+double_must_use">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/functions/mod.rs#L173">View Source</a></div></div></div></article><article id="double_parens"><input id="label-double_parens" type="checkbox"><label for="label-double_parens"><h2 class="lint-title"><div class="panel-title-name" id="lint-double_parens">double_parens
<a href="#double_parens" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for unnecessary double parentheses.</p>
<h3>Why is this bad?</h3>
<p>This makes code harder to read and might indicate a
mistake.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn simple_double_parens() -&gt; i32 {
    ((0))
}

foo((0));
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn simple_no_parens() -&gt; i32 {
    (0)
}

foo(0);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+double_parens">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/double_parens.rs#L8">View Source</a></div></div></div></article><article id="drain_collect"><input id="label-drain_collect" type="checkbox"><label for="label-drain_collect"><h2 class="lint-title"><div class="panel-title-name" id="lint-drain_collect">drain_collect
<a href="#drain_collect" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>.drain()</code> that clear the collection, immediately followed by a call to <code>.collect()</code>.</p>
<blockquote>
<p>“Collection” in this context refers to any type with a <code>drain</code> method:
<code>Vec</code>, <code>VecDeque</code>, <code>BinaryHeap</code>, <code>HashSet</code>,<code>HashMap</code>, <code>String</code></p>
</blockquote>
<h3>Why is this bad?</h3>
<p>Using <code>mem::take</code> is faster as it avoids the allocation.
When using <code>mem::take</code>, the old collection is replaced with an empty one and ownership of
the old collection is returned.</p>
<h3>Known issues</h3>
<p><code>mem::take(&amp;mut vec)</code> is almost equivalent to <code>vec.drain(..).collect()</code>, except that
it also moves the <strong>capacity</strong>. The user might have explicitly written it this way
to keep the capacity on the original <code>Vec</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn remove_all(v: &amp;mut Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    v.drain(..).collect()
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::mem;
fn remove_all(v: &amp;mut Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    mem::take(v)
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+drain_collect">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3443">View Source</a></div></div></div></article><article id="drop_non_drop"><input id="label-drop_non_drop" type="checkbox"><label for="label-drop_non_drop"><h2 class="lint-title"><div class="panel-title-name" id="lint-drop_non_drop">drop_non_drop
<a href="#drop_non_drop" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>std::mem::drop</code> with a value that does not implement <code>Drop</code>.</p>
<h3>Why is this bad?</h3>
<p>Calling <code>std::mem::drop</code> is no different than dropping such a type. A different value may
have been intended.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Foo;
let x = Foo;
std::mem::drop(x);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+drop_non_drop">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/drop_forget_ref.rs#L11">View Source</a></div></div></div></article><article id="duplicate_mod"><input id="label-duplicate_mod" type="checkbox"><label for="label-duplicate_mod"><h2 class="lint-title"><div class="panel-title-name" id="lint-duplicate_mod">duplicate_mod
<a href="#duplicate_mod" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for files that are included as modules multiple times.</p>
<h3>Why is this bad?</h3>
<p>Loading a file as a module more than once causes it to be compiled
multiple times, taking longer and putting duplicate content into the
module tree.</p>
<h3>Example</h3>
<pre><code class="language-rust">// lib.rs
mod a;
mod b;
</code></pre>
<pre><code class="language-rust">// a.rs
#[path = "./b.rs"]
mod b;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// lib.rs
mod a;
mod b;
</code></pre>
<pre><code class="language-rust">// a.rs
use crate::b;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.63.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+duplicate_mod">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/duplicate_mod.rs#L11">View Source</a></div></div></div></article><article id="duplicate_underscore_argument"><input id="label-duplicate_underscore_argument" type="checkbox"><label for="label-duplicate_underscore_argument"><h2 class="lint-title"><div class="panel-title-name" id="lint-duplicate_underscore_argument">duplicate_underscore_argument
<a href="#duplicate_underscore_argument" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for function arguments having the similar names
differing by an underscore.</p>
<h3>Why is this bad?</h3>
<p>It affects code readability.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(a: i32, _a: i32) {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn bar(a: i32, _b: i32) {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+duplicate_underscore_argument">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/functions/mod.rs#L24">View Source</a></div></div></div></article><article id="duplicated_attributes"><input id="label-duplicated_attributes" type="checkbox"><label for="label-duplicated_attributes"><h2 class="lint-title"><div class="panel-title-name" id="lint-duplicated_attributes">duplicated_attributes
<a href="#duplicated_attributes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for attributes that appear two or more times.</p>
<h3>Why is this bad?</h3>
<p>Repeating an attribute on the same item (or globally on the same crate)
is unnecessary and doesn’t have an effect.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[allow(dead_code)]
#[allow(dead_code)]
fn foo() {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[allow(dead_code)]
fn foo() {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.79.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+duplicated_attributes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/attrs/mod.rs#L426">View Source</a></div></div></div></article><article id="duration_suboptimal_units"><input id="label-duration_suboptimal_units" type="checkbox"><label for="label-duration_suboptimal_units"><h2 class="lint-title"><div class="panel-title-name" id="lint-duration_suboptimal_units">duration_suboptimal_units
<a href="#duration_suboptimal_units" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for instances where a <code>std::time::Duration</code> is constructed using a smaller time unit
when the value could be expressed more clearly using a larger unit.</p>
<h3>Why is this bad?</h3>
<p>Using a smaller unit for a duration that is evenly divisible by a larger unit reduces
readability. Readers have to mentally convert values, which can be error-prone and makes
the code less clear.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::time::Duration;

let dur = Duration::from_millis(5_000);
let dur = Duration::from_secs(180);
let dur = Duration::from_mins(10 * 60);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::time::Duration;

let dur = Duration::from_secs(5);
let dur = Duration::from_mins(3);
let dur = Duration::from_hours(10);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.95.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+duration_suboptimal_units">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/duration_suboptimal_units.rs#L16">View Source</a></div></div></div></article><article id="duration_subsec"><input id="label-duration_subsec" type="checkbox"><label for="label-duration_subsec"><h2 class="lint-title"><div class="panel-title-name" id="lint-duration_subsec">duration_subsec
<a href="#duration_subsec" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calculation of subsecond microseconds or milliseconds
from other <code>Duration</code> methods.</p>
<h3>Why is this bad?</h3>
<p>It’s more concise to call <code>Duration::subsec_micros()</code> or
<code>Duration::subsec_millis()</code> than to calculate them.</p>
<h3>Example</h3>
<pre><code class="language-rust">let micros = duration.subsec_nanos() / 1_000;
let millis = duration.subsec_nanos() / 1_000_000;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let micros = duration.subsec_micros();
let millis = duration.subsec_millis();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+duration_subsec">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L359">View Source</a></div></div></div></article><article id="eager_transmute"><input id="label-eager_transmute" type="checkbox"><label for="label-eager_transmute"><h2 class="lint-title"><div class="panel-title-name" id="lint-eager_transmute">eager_transmute
<a href="#eager_transmute" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for integer validity checks, followed by a transmute that is (incorrectly) evaluated
eagerly (e.g. using <code>bool::then_some</code>).</p>
<h3>Why is this bad?</h3>
<p>Eager evaluation means that the <code>transmute</code> call is executed regardless of whether the condition is true or false.
This can introduce unsoundness and other subtle bugs.</p>
<h3>Example</h3>
<p>Consider the following function which is meant to convert an unsigned integer to its enum equivalent via transmute.</p>
<pre><code class="language-rust">#[repr(u8)]
enum Opcode {
    Add = 0,
    Sub = 1,
    Mul = 2,
    Div = 3
}

fn int_to_opcode(op: u8) -&gt; Option&lt;Opcode&gt; {
    (op &lt; 4).then_some(unsafe { std::mem::transmute(op) })
}
</code></pre>
<p>This may appear fine at first given that it checks that the <code>u8</code> is within the validity range of the enum,
<em>however</em> the transmute is evaluated eagerly, meaning that it executes even if <code>op &gt;= 4</code>!</p>
<p>This makes the function unsound, because it is possible for the caller to cause undefined behavior
(creating an enum with an invalid bitpattern) entirely in safe code only by passing an incorrect value,
which is normally only a bug that is possible in unsafe code.</p>
<p>One possible way in which this can go wrong practically is that the compiler sees it as:</p>
<pre><code class="language-rust">let temp: Foo = unsafe { std::mem::transmute(op) };
(0 &lt; 4).then_some(temp)
</code></pre>
<p>and optimizes away the <code>(0 &lt; 4)</code> check based on the assumption that since a <code>Foo</code> was created from <code>op</code> with the validity range <code>0..3</code>,
it is <strong>impossible</strong> for this condition to be false.</p>
<p>In short, it is possible for this function to be optimized in a way that makes it <a href="https://godbolt.org/z/ocrcenevq">never return <code>None</code></a>,
even if passed the value <code>4</code>.</p>
<p>This can be avoided by instead using lazy evaluation. For the example above, this should be written:</p>
<pre><code class="language-rust">fn int_to_opcode(op: u8) -&gt; Option&lt;Opcode&gt; {
    (op &lt; 4).then(|| unsafe { std::mem::transmute(op) })
             ^^^^ ^^ `bool::then` only executes the closure if the condition is true!
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.77.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+eager_transmute">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/transmute/mod.rs#L364">View Source</a></div></div></div></article><article id="elidable_lifetime_names"><input id="label-elidable_lifetime_names" type="checkbox"><label for="label-elidable_lifetime_names"><h2 class="lint-title"><div class="panel-title-name" id="lint-elidable_lifetime_names">elidable_lifetime_names
<a href="#elidable_lifetime_names" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for lifetime annotations which can be replaced with anonymous lifetimes (<code>'_</code>).</p>
<h3>Why is this bad?</h3>
<p>The additional lifetimes can make the code look more complicated.</p>
<h3>Known problems</h3>
<p>This lint ignores functions with <code>where</code> clauses that reference
lifetimes to prevent false positives.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn f&lt;'a&gt;(x: &amp;'a str) -&gt; Chars&lt;'a&gt; {
    x.chars()
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn f(x: &amp;str) -&gt; Chars&lt;'_&gt; {
    x.chars()
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.87.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+elidable_lifetime_names">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/lifetimes.rs#L65">View Source</a></div></div></div></article><article id="else_if_without_else"><input id="label-else_if_without_else" type="checkbox"><label for="label-else_if_without_else"><h2 class="lint-title"><div class="panel-title-name" id="lint-else_if_without_else">else_if_without_else
<a href="#else_if_without_else" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of if expressions with an <code>else if</code> branch,
but without a final <code>else</code> branch.</p>
<h3>Why restrict this?</h3>
<p>Some coding guidelines require this (e.g., MISRA-C:2004 Rule 14.10).</p>
<h3>Example</h3>
<pre><code class="language-rust">if x.is_positive() {
    a();
} else if x.is_negative() {
    b();
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if x.is_positive() {
    a();
} else if x.is_negative() {
    b();
} else {
    // We don't care about zero.
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+else_if_without_else">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/else_if_without_else.rs#L6">View Source</a></div></div></div></article><article id="empty_docs"><input id="label-empty_docs" type="checkbox"><label for="label-empty_docs"><h2 class="lint-title"><div class="panel-title-name" id="lint-empty_docs">empty_docs
<a href="#empty_docs" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects documentation that is empty.</p>
<h3>Why is this bad?</h3>
<p>Empty docs clutter code without adding value, reducing readability and maintainability.</p>
<h3>Example</h3>
<pre><code class="language-rust">///
fn returns_true() -&gt; bool {
    true
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn returns_true() -&gt; bool {
    true
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.78.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+empty_docs">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L410">View Source</a></div></div></div></article><article id="empty_drop"><input id="label-empty_drop" type="checkbox"><label for="label-empty_drop"><h2 class="lint-title"><div class="panel-title-name" id="lint-empty_drop">empty_drop
<a href="#empty_drop" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for empty <code>Drop</code> implementations.</p>
<h3>Why restrict this?</h3>
<p>Empty <code>Drop</code> implementations have no effect when dropping an instance of the type. They are
most likely useless. However, an empty <code>Drop</code> implementation prevents a type from being
destructured, which might be the intention behind adding the implementation as a marker.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct S;

impl Drop for S {
    fn drop(&amp;mut self) {}
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct S;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+empty_drop">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/empty_drop.rs#L8">View Source</a></div></div></div></article><article id="empty_enum_variants_with_brackets"><input id="label-empty_enum_variants_with_brackets" type="checkbox"><label for="label-empty_enum_variants_with_brackets"><h2 class="lint-title"><div class="panel-title-name" id="lint-empty_enum_variants_with_brackets">empty_enum_variants_with_brackets
<a href="#empty_enum_variants_with_brackets" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Finds enum variants without fields that are declared with empty brackets.</p>
<h3>Why restrict this?</h3>
<p>Empty brackets after a enum variant declaration are redundant and can be omitted,
and it may be desirable to do so consistently for style.</p>
<p>However, removing the brackets also introduces a public constant named after the variant,
so this is not just a syntactic simplification but an API change, and adding them back
is a <em>breaking</em> API change.</p>
<h3>Example</h3>
<pre><code class="language-rust">enum MyEnum {
    HasData(u8),
    HasNoData(),       // redundant parentheses
    NoneHereEither {}, // redundant braces
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">enum MyEnum {
    HasData(u8),
    HasNoData,
    NoneHereEither,
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.77.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+empty_enum_variants_with_brackets">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/empty_with_brackets.rs#L45">View Source</a></div></div></div></article><article id="empty_enums"><input id="label-empty_enums" type="checkbox"><label for="label-empty_enums"><h2 class="lint-title"><div class="panel-title-name" id="lint-empty_enums">empty_enums
<a href="#empty_enums" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>enum</code>s with no variants, which therefore are uninhabited types
(cannot be instantiated).</p>
<p>As of this writing, the <code>never_type</code> is still a nightly-only experimental API.
Therefore, this lint is only triggered if <code>#![feature(never_type)]</code> is enabled.</p>
<h3>Why is this bad?</h3>
<ul>
<li>
<p>If you only want a type which can’t be instantiated, you should use <a href="https://doc.rust-lang.org/std/primitive.never.html"><code>!</code></a>
(the primitive type “never”), because <a href="https://doc.rust-lang.org/std/primitive.never.html"><code>!</code></a> has more extensive compiler support
(type inference, etc.) and implementations of common traits.</p>
</li>
<li>
<p>If you need to introduce a distinct type, consider using a <a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction">newtype</a> <code>struct</code>
containing <a href="https://doc.rust-lang.org/std/primitive.never.html"><code>!</code></a> instead (<code>struct MyType(pub !)</code>), because it is more idiomatic
to use a <code>struct</code> rather than an <code>enum</code> when an <code>enum</code> is unnecessary.</p>
<p>If you do this, note that the <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">visibility</a> of the <a href="https://doc.rust-lang.org/std/primitive.never.html"><code>!</code></a> field determines whether
the uninhabitedness is visible in documentation, and whether it can be pattern
matched to mark code unreachable. If the field is not visible, then the struct
acts like any other struct with private fields.</p>
</li>
</ul>
<p>For further information, visit
<a href="https://doc.rust-lang.org/std/primitive.never.html">the never type’s documentation</a>.</p>
<h3>Example</h3>
<pre><code class="language-rust">enum CannotExist {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#![feature(never_type)]

/// Use the `!` type directly...
type CannotExist = !;

/// ...or define a newtype which is distinct.
struct CannotExist2(pub !);
</code></pre>
<h3>Past names</h3>
<ul>
<li>empty_enum</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+empty_enums">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/empty_enums.rs#L7">View Source</a></div></div></div></article><article id="empty_line_after_doc_comments"><input id="label-empty_line_after_doc_comments" type="checkbox"><label for="label-empty_line_after_doc_comments"><h2 class="lint-title"><div class="panel-title-name" id="lint-empty_line_after_doc_comments">empty_line_after_doc_comments
<a href="#empty_line_after_doc_comments" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for empty lines after doc comments.</p>
<h3>Why is this bad?</h3>
<p>The doc comment may have meant to be an inner doc comment, regular
comment or applied to some old code that is now commented out. If it was
intended to be a doc comment, then the empty line should be removed.</p>
<h3>Example</h3>
<pre><code class="language-rust">/// Some doc comment with a blank line after it.

fn f() {}

/// Docs for `old_code`
// fn old_code() {}

fn new_code() {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">//! Convert it to an inner doc comment

// Or a regular comment

/// Or remove the empty line
fn f() {}

// /// Docs for `old_code`
// fn old_code() {}

fn new_code() {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+empty_line_after_doc_comments">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/empty_line_after.rs#L50">View Source</a></div></div></div></article><article id="empty_line_after_outer_attr"><input id="label-empty_line_after_outer_attr" type="checkbox"><label for="label-empty_line_after_outer_attr"><h2 class="lint-title"><div class="panel-title-name" id="lint-empty_line_after_outer_attr">empty_line_after_outer_attr
<a href="#empty_line_after_outer_attr" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for empty lines after outer attributes</p>
<h3>Why is this bad?</h3>
<p>The attribute may have meant to be an inner attribute (<code>#![attr]</code>). If
it was meant to be an outer attribute (<code>#[attr]</code>) then the empty line
should be removed</p>
<h3>Example</h3>
<pre><code class="language-rust">#[allow(dead_code)]

fn not_quite_good_code() {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// Good (as inner attribute)
#![allow(dead_code)]

fn this_is_fine() {}

// or

// Good (as outer attribute)
#[allow(dead_code)]
fn this_is_fine_too() {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+empty_line_after_outer_attr">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/empty_line_after.rs#L15">View Source</a></div></div></div></article><article id="empty_loop"><input id="label-empty_loop" type="checkbox"><label for="label-empty_loop"><h2 class="lint-title"><div class="panel-title-name" id="lint-empty_loop">empty_loop
<a href="#empty_loop" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for empty <code>loop</code> expressions.</p>
<h3>Why is this bad?</h3>
<p>These busy loops burn CPU cycles without doing
anything. It is <em>almost always</em> a better idea to <code>panic!</code> than to have
a busy loop.</p>
<p>If panicking isn’t possible, think of the environment and either:</p>
<ul>
<li>block on something</li>
<li>sleep the thread for some microseconds</li>
<li>yield or pause the thread</li>
</ul>
<p>For <code>std</code> targets, this can be done with
<a href="https://doc.rust-lang.org/std/thread/fn.sleep.html"><code>std::thread::sleep</code></a>
or <a href="https://doc.rust-lang.org/std/thread/fn.yield_now.html"><code>std::thread::yield_now</code></a>.</p>
<p>For <code>no_std</code> targets, doing this is more complicated, especially because
<code>#[panic_handler]</code>s can’t panic. To stop/pause the thread, you will
probably need to invoke some target-specific intrinsic. Examples include:</p>
<ul>
<li><a href="https://docs.rs/x86_64/0.12.2/x86_64/instructions/fn.hlt.html"><code>x86_64::instructions::hlt</code></a></li>
<li><a href="https://docs.rs/cortex-m/0.6.3/cortex_m/asm/fn.wfi.html"><code>cortex_m::asm::wfi</code></a></li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">loop {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+empty_loop">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L250">View Source</a></div></div></div></article><article id="empty_structs_with_brackets"><input id="label-empty_structs_with_brackets" type="checkbox"><label for="label-empty_structs_with_brackets"><h2 class="lint-title"><div class="panel-title-name" id="lint-empty_structs_with_brackets">empty_structs_with_brackets
<a href="#empty_structs_with_brackets" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Finds structs without fields (a so-called “empty struct”) that are declared with brackets.</p>
<h3>Why restrict this?</h3>
<p>Empty brackets after a struct declaration can be omitted,
and it may be desirable to do so consistently for style.</p>
<p>However, removing the brackets also introduces a public constant named after the struct,
so this is not just a syntactic simplification but an API change, and adding them back
is a <em>breaking</em> API change.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Cookie {}
struct Biscuit();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct Cookie;
struct Biscuit;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+empty_structs_with_brackets">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/empty_with_brackets.rs#L17">View Source</a></div></div></div></article><article id="enum_clike_unportable_variant"><input id="label-enum_clike_unportable_variant" type="checkbox"><label for="label-enum_clike_unportable_variant"><h2 class="lint-title"><div class="panel-title-name" id="lint-enum_clike_unportable_variant">enum_clike_unportable_variant
<a href="#enum_clike_unportable_variant" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for C-like enumerations that are
<code>repr(isize/usize)</code> and have values that don’t fit into an <code>i32</code>.</p>
<h3>Why is this bad?</h3>
<p>This will truncate the variant value on 32 bit
architectures, but works fine on 64 bit.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[repr(usize)]
enum NonPortable {
    X = 0x1_0000_0000,
    Y = 0,
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+enum_clike_unportable_variant">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/enum_clike.rs#L9">View Source</a></div></div></div></article><article id="enum_glob_use"><input id="label-enum_glob_use" type="checkbox"><label for="label-enum_glob_use"><h2 class="lint-title"><div class="panel-title-name" id="lint-enum_glob_use">enum_glob_use
<a href="#enum_glob_use" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>use Enum::*</code>.</p>
<h3>Why is this bad?</h3>
<p>It is usually better style to use the prefixed name of
an enumeration variant, rather than importing variants.</p>
<h3>Known problems</h3>
<p>Old-style enumerations that prefix the variants are
still around.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::cmp::Ordering::*;

foo(Less);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::cmp::Ordering;

foo(Ordering::Less)
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+enum_glob_use">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/wildcard_imports.rs#L15">View Source</a></div></div></div></article><article id="enum_variant_names"><input id="label-enum_variant_names" type="checkbox"><label for="label-enum_variant_names"><h2 class="lint-title"><div class="panel-title-name" id="lint-enum_variant_names">enum_variant_names
<a href="#enum_variant_names" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects enumeration variants that are prefixed or suffixed
by the same characters.</p>
<h3>Why is this bad?</h3>
<p>Enumeration variant names should specify their variant,
not repeat the enumeration name.</p>
<h3>Limitations</h3>
<p>Characters with no casing will be considered when comparing prefixes/suffixes
This applies to numbers and non-ascii characters without casing
e.g. <code>Foo1</code> and <code>Foo2</code> is considered to have different prefixes
(the prefixes are <code>Foo1</code> and <code>Foo2</code> respectively), as also <code>Bar螃</code>, <code>Bar蟹</code></p>
<h3>Example</h3>
<pre><code class="language-rust">enum Cake {
    BlackForestCake,
    HummingbirdCake,
    BattenbergCake,
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">enum Cake {
    BlackForest,
    Hummingbird,
    Battenberg,
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
<li>
<p><code>enum-variant-name-threshold</code>:  The minimum number of enum variants for the lints about variant names to trigger</p>
<p>(default: <code>3</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+enum_variant_names">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/item_name_repetitions.rs#L11">View Source</a></div></div></div></article><article id="eq_op"><input id="label-eq_op" type="checkbox"><label for="label-eq_op"><h2 class="lint-title"><div class="panel-title-name" id="lint-eq_op">eq_op
<a href="#eq_op" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for equal operands to comparison, logical and
bitwise, difference and division binary operators (<code>==</code>, <code>&gt;</code>, etc., <code>&amp;&amp;</code>,
<code>||</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>-</code> and <code>/</code>).</p>
<h3>Why is this bad?</h3>
<p>This is usually just a typo or a copy and paste error.</p>
<h3>Known problems</h3>
<p>False negatives: We had some false positives regarding
calls (notably <a href="https://github.com/phildawes/racer">racer</a> had one instance
of <code>x.pop() &amp;&amp; x.pop()</code>), so we removed matching any function or method
calls. We may introduce a list of known pure functions in the future.</p>
<h3>Example</h3>
<pre><code class="language-rust">if x + 1 == x + 1 {}

// or

assert_eq!(a, a);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+eq_op">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L389">View Source</a></div></div></div></article><article id="equatable_if_let"><input id="label-equatable_if_let" type="checkbox"><label for="label-equatable_if_let"><h2 class="lint-title"><div class="panel-title-name" id="lint-equatable_if_let">equatable_if_let
<a href="#equatable_if_let" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for pattern matchings that can be expressed using equality.</p>
<h3>Why is this bad?</h3>
<ul>
<li>It reads better and has less cognitive load because equality won’t cause binding.</li>
<li>It is a <a href="https://en.wikipedia.org/wiki/Yoda_conditions">Yoda condition</a>. Yoda conditions are widely
criticized for increasing the cognitive load of reading the code.</li>
<li>Equality is a simple bool expression and can be merged with <code>&amp;&amp;</code> and <code>||</code> and
reuse if blocks</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">if let Some(2) = x {
    do_thing();
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if x == Some(2) {
    do_thing();
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.57.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+equatable_if_let">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/equatable_if_let.rs#L11">View Source</a></div></div></div></article><article id="erasing_op"><input id="label-erasing_op" type="checkbox"><label for="label-erasing_op"><h2 class="lint-title"><div class="panel-title-name" id="lint-erasing_op">erasing_op
<a href="#erasing_op" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for erasing operations, e.g., <code>x * 0</code>.</p>
<h3>Why is this bad?</h3>
<p>The whole expression can be replaced by zero.
This is most likely not the intended outcome and should probably be
corrected</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = 1;
0 / x;
0 * x;
x &amp; 0;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+erasing_op">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L445">View Source</a></div></div></div></article><article id="err_expect"><input id="label-err_expect" type="checkbox"><label for="label-err_expect"><h2 class="lint-title"><div class="panel-title-name" id="lint-err_expect">err_expect
<a href="#err_expect" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>.err().expect()</code> calls on the <code>Result</code> type.</p>
<h3>Why is this bad?</h3>
<p><code>.expect_err()</code> can be called directly to avoid the extra type conversion from <code>err()</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: Result&lt;u32, &amp;str&gt; = Ok(10);
x.err().expect("Testing err().expect()");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x: Result&lt;u32, &amp;str&gt; = Ok(10);
x.expect_err("Testing expect_err");
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+err_expect">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L504">View Source</a></div></div></div></article><article id="error_impl_error"><input id="label-error_impl_error" type="checkbox"><label for="label-error_impl_error"><h2 class="lint-title"><div class="panel-title-name" id="lint-error_impl_error">error_impl_error
<a href="#error_impl_error" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for types named <code>Error</code> that implement <code>Error</code>.</p>
<h3>Why restrict this?</h3>
<p>It can become confusing when a codebase has 20 types all named <code>Error</code>, requiring either
aliasing them in the <code>use</code> statement or qualifying them like <code>my_module::Error</code>. This
hinders comprehension, as it requires you to memorize every variation of importing <code>Error</code>
used across a codebase.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[derive(Debug)]
pub enum Error { ... }

impl std::fmt::Display for Error { ... }

impl std::error::Error for Error { ... }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+error_impl_error">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/error_impl_error.rs#L11">View Source</a></div></div></div></article><article id="excessive_nesting"><input id="label-excessive_nesting" type="checkbox"><label for="label-excessive_nesting"><h2 class="lint-title"><div class="panel-title-name" id="lint-excessive_nesting">excessive_nesting
<a href="#excessive_nesting" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for blocks which are nested beyond a certain threshold.</p>
<p>Note: Even though this lint is warn-by-default, it will only trigger if a maximum nesting level is defined in the clippy.toml file.</p>
<h3>Why is this bad?</h3>
<p>It can severely hinder readability.</p>
<h3>Example</h3>
<p>An example clippy.toml configuration:</p>
<pre><code class="language-toml">excessive-nesting-threshold = 3
</code></pre>
<pre><code class="language-rust">// lib.rs
pub mod a {
    pub struct X;
    impl X {
        pub fn run(&amp;self) {
            if true {
                // etc...
            }
        }
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// a.rs
fn private_run(x: &amp;X) {
    if true {
        // etc...
    }
}

pub struct X;
impl X {
    pub fn run(&amp;self) {
        private_run(self);
    }
}
</code></pre>
<pre><code class="language-rust">// lib.rs
pub mod a;
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>excessive-nesting-threshold</code>:  The maximum amount of nesting a block can reside in</p>
<p>(default: <code>0</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+excessive_nesting">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/excessive_nesting.rs#L11">View Source</a></div></div></div></article><article id="excessive_precision"><input id="label-excessive_precision" type="checkbox"><label for="label-excessive_precision"><h2 class="lint-title"><div class="panel-title-name" id="lint-excessive_precision">excessive_precision
<a href="#excessive_precision" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for float literals with a precision greater
than that supported by the underlying type.</p>
<p>The lint is suppressed for literals with over <code>const_literal_digits_threshold</code> digits.</p>
<h3>Why is this bad?</h3>
<p>Rust will truncate the literal silently.</p>
<h3>Example</h3>
<pre><code class="language-rust">let v: f32 = 0.123_456_789_9;
println!("{}", v); //  0.123_456_789
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let v: f64 = 0.123_456_789_9;
println!("{}", v); //  0.123_456_789_9
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>const-literal-digits-threshold</code>:  The minimum digits a const float literal must have to supress the <code>excessive_precicion</code> lint</p>
<p>(default: <code>30</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+excessive_precision">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/float_literal.rs#L12">View Source</a></div></div></div></article><article id="exhaustive_enums"><input id="label-exhaustive_enums" type="checkbox"><label for="label-exhaustive_enums"><h2 class="lint-title"><div class="panel-title-name" id="lint-exhaustive_enums">exhaustive_enums
<a href="#exhaustive_enums" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns on any exported <code>enum</code>s that are not tagged <code>#[non_exhaustive]</code></p>
<h3>Why restrict this?</h3>
<p>Making an <code>enum</code> exhaustive is a stability commitment: adding a variant is a breaking change.
A project may wish to ensure that there are no exhaustive enums or that every exhaustive
<code>enum</code> is explicitly <code>#[allow]</code>ed.</p>
<h3>Example</h3>
<pre><code class="language-rust">enum Foo {
    Bar,
    Baz
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[non_exhaustive]
enum Foo {
    Bar,
    Baz
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.51.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+exhaustive_enums">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/exhaustive_items.rs#L9">View Source</a></div></div></div></article><article id="exhaustive_structs"><input id="label-exhaustive_structs" type="checkbox"><label for="label-exhaustive_structs"><h2 class="lint-title"><div class="panel-title-name" id="lint-exhaustive_structs">exhaustive_structs
<a href="#exhaustive_structs" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns on any exported <code>struct</code>s that are not tagged <code>#[non_exhaustive]</code></p>
<h3>Why restrict this?</h3>
<p>Making a <code>struct</code> exhaustive is a stability commitment: adding a field is a breaking change.
A project may wish to ensure that there are no exhaustive structs or that every exhaustive
<code>struct</code> is explicitly <code>#[allow]</code>ed.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Foo {
    bar: u8,
    baz: String,
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[non_exhaustive]
struct Foo {
    bar: u8,
    baz: String,
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.51.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+exhaustive_structs">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/exhaustive_items.rs#L39">View Source</a></div></div></div></article><article id="exit"><input id="label-exit" type="checkbox"><label for="label-exit"><h2 class="lint-title"><div class="panel-title-name" id="lint-exit">exit
<a href="#exit" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects calls to the <code>exit()</code> function that are not in the <code>main</code> function. Calls to <code>exit()</code>
immediately terminate the program.</p>
<h3>Why restrict this?</h3>
<p><code>exit()</code> immediately terminates the program with no information other than an exit code.
This provides no means to troubleshoot a problem, and may be an unexpected side effect.</p>
<p>Codebases may use this lint to require that all exits are performed either by panicking
(which produces a message, a code location, and optionally a backtrace)
or by calling <code>exit()</code> from <code>main()</code> (which is a single place to look).</p>
<h3>Good example</h3>
<pre><code class="language-rust">fn main() {
    std::process::exit(0);
}
</code></pre>
<h3>Bad example</h3>
<pre><code class="language-rust">fn main() {
    other_function();
}

fn other_function() {
    std::process::exit(0);
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// To provide a stacktrace and additional information
panic!("message");

// or a main method with a return
fn main() -&gt; Result&lt;(), i32&gt; {
    Ok(())
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.41.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+exit">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/exit.rs#L7">View Source</a></div></div></div></article><article id="expect_fun_call"><input id="label-expect_fun_call" type="checkbox"><label for="label-expect_fun_call"><h2 class="lint-title"><div class="panel-title-name" id="lint-expect_fun_call">expect_fun_call
<a href="#expect_fun_call" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>.expect(&amp;format!(...))</code>, <code>.expect(foo(..))</code>,
etc., and suggests to use <code>unwrap_or_else</code> instead</p>
<h3>Why is this bad?</h3>
<p>The function will always be called.</p>
<h3>Known problems</h3>
<p>If the function has side-effects, not calling it will
change the semantics of the program, but you shouldn’t rely on that anyway.</p>
<h3>Example</h3>
<pre><code class="language-rust">foo.expect(&amp;format!("Err {}: {}", err_code, err_msg));

// or

foo.expect(format!("Err {}: {}", err_code, err_msg).as_str());
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">foo.unwrap_or_else(|| panic!("Err {}: {}", err_code, err_msg));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+expect_fun_call">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L993">View Source</a></div></div></div></article><article id="expect_used"><input id="label-expect_used" type="checkbox"><label for="label-expect_used"><h2 class="lint-title"><div class="panel-title-name" id="lint-expect_used">expect_used
<a href="#expect_used" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>.expect()</code> or <code>.expect_err()</code> calls on <code>Result</code>s and <code>.expect()</code> call on <code>Option</code>s.</p>
<h3>Why restrict this?</h3>
<p>Usually it is better to handle the <code>None</code> or <code>Err</code> case.
Still, for a lot of quick-and-dirty code, <code>expect</code> is a good choice, which is why
this lint is <code>Allow</code> by default.</p>
<p><code>result.expect()</code> will let the thread panic on <code>Err</code>
values. Normally, you want to implement more sophisticated error handling,
and propagate errors upwards with <code>?</code> operator.</p>
<h3>Examples</h3>
<pre><code class="language-rust">option.expect("one");
result.expect("one");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">option?;

// or

result?;
</code></pre>
<h3>Past names</h3>
<ul>
<li>option_expect_used</li>
<li>result_expect_used</li>
</ul>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allow-expect-in-consts</code>:  Whether <code>expect</code> should be allowed in code always evaluated at compile time</p>
<p>(default: <code>true</code>)</p>
</li>
<li>
<p><code>allow-expect-in-tests</code>:  Whether <code>expect</code> should be allowed in test functions or <code>#[cfg(test)]</code></p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.45.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+expect_used">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L349">View Source</a></div></div></div></article><article id="expl_impl_clone_on_copy"><input id="label-expl_impl_clone_on_copy" type="checkbox"><label for="label-expl_impl_clone_on_copy"><h2 class="lint-title"><div class="panel-title-name" id="lint-expl_impl_clone_on_copy">expl_impl_clone_on_copy
<a href="#expl_impl_clone_on_copy" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for explicit <code>Clone</code> implementations for <code>Copy</code>
types.</p>
<h3>Why is this bad?</h3>
<p>To avoid surprising behavior, these traits should
agree and the behavior of <code>Copy</code> cannot be overridden. In almost all
situations a <code>Copy</code> type should have a <code>Clone</code> implementation that does
nothing more than copy the object, which is what <code>#[derive(Copy, Clone)]</code>
gets you.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[derive(Copy)]
struct Foo;

impl Clone for Foo {
    // ..
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+expl_impl_clone_on_copy">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/derive/mod.rs#L94">View Source</a></div></div></div></article><article id="explicit_auto_deref"><input id="label-explicit_auto_deref" type="checkbox"><label for="label-explicit_auto_deref"><h2 class="lint-title"><div class="panel-title-name" id="lint-explicit_auto_deref">explicit_auto_deref
<a href="#explicit_auto_deref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for dereferencing expressions which would be covered by auto-deref.</p>
<h3>Why is this bad?</h3>
<p>This unnecessarily complicates the code.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = String::new();
let y: &amp;str = &amp;*x;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = String::new();
let y: &amp;str = &amp;x;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.64.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+explicit_auto_deref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/dereference.rs#L123">View Source</a></div></div></div></article><article id="explicit_counter_loop"><input id="label-explicit_counter_loop" type="checkbox"><label for="label-explicit_counter_loop"><h2 class="lint-title"><div class="panel-title-name" id="lint-explicit_counter_loop">explicit_counter_loop
<a href="#explicit_counter_loop" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks <code>for</code> loops over slices with an explicit counter
and suggests the use of <code>.enumerate()</code>.</p>
<h3>Why is this bad?</h3>
<p>Using <code>.enumerate()</code> makes the intent more clear,
declutters the code and may be faster in some instances.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut i = 0;
for item in &amp;v {
    bar(i, *item);
    i += 1;
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">for (i, item) in v.iter().enumerate() { bar(i, *item); }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+explicit_counter_loop">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L218">View Source</a></div></div></div></article><article id="explicit_deref_methods"><input id="label-explicit_deref_methods" type="checkbox"><label for="label-explicit_deref_methods"><h2 class="lint-title"><div class="panel-title-name" id="lint-explicit_deref_methods">explicit_deref_methods
<a href="#explicit_deref_methods" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for explicit <code>deref()</code> or <code>deref_mut()</code> method calls.</p>
<p>Doesn’t lint inside the implementation of the <code>Deref</code> or <code>DerefMut</code> traits.</p>
<h3>Why is this bad?</h3>
<p>Dereferencing by <code>&amp;*x</code> or <code>&amp;mut *x</code> is clearer and more concise,
when not part of a method chain.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::ops::Deref;
let a: &amp;mut String = &amp;mut String::from("foo");
let b: &amp;str = a.deref();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a: &amp;mut String = &amp;mut String::from("foo");
let b = &amp;*a;
</code></pre>
<p>This lint excludes all of:</p>
<pre><code class="language-rust">let _ = d.unwrap().deref();
let _ = Foo::deref(&amp;foo);
let _ = &lt;Foo as Deref&gt;::deref(&amp;foo);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.44.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+explicit_deref_methods">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/dereference.rs#L26">View Source</a></div></div></div></article><article id="explicit_into_iter_loop"><input id="label-explicit_into_iter_loop" type="checkbox"><label for="label-explicit_into_iter_loop"><h2 class="lint-title"><div class="panel-title-name" id="lint-explicit_into_iter_loop">explicit_into_iter_loop
<a href="#explicit_into_iter_loop" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for loops on <code>y.into_iter()</code> where <code>y</code> will do, and
suggests the latter.</p>
<h3>Why is this bad?</h3>
<p>Readability.</p>
<h3>Example</h3>
<pre><code class="language-rust">// with `y` a `Vec` or slice:
for x in y.into_iter() {
    // ..
}
</code></pre>
<p>can be rewritten to</p>
<pre><code class="language-rust">for x in y {
    // ..
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+explicit_into_iter_loop">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L132">View Source</a></div></div></div></article><article id="explicit_iter_loop"><input id="label-explicit_iter_loop" type="checkbox"><label for="label-explicit_iter_loop"><h2 class="lint-title"><div class="panel-title-name" id="lint-explicit_iter_loop">explicit_iter_loop
<a href="#explicit_iter_loop" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for loops on <code>x.iter()</code> where <code>&amp;x</code> will do, and
suggests the latter.</p>
<h3>Why is this bad?</h3>
<p>Readability.</p>
<h3>Known problems</h3>
<p>False negatives. We currently only warn on some known
types.</p>
<h3>Example</h3>
<pre><code class="language-rust">// with `y` a `Vec` or slice:
for x in y.iter() {
    // ..
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">for x in &amp;y {
    // ..
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li><code>enforce-iter-loop-reborrow</code>:  Whether to recommend using implicit into iter for reborrowed values.</li>
</ul>
<h4>Example</h4>
<pre><code class="language-rust">let mut vec = vec![1, 2, 3];
let rmvec = &amp;mut vec;
for _ in rmvec.iter() {}
for _ in rmvec.iter_mut() {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut vec = vec![1, 2, 3];
let rmvec = &amp;mut vec;
for _ in &amp;*rmvec {}
for _ in &amp;mut *rmvec {}
</code></pre>
<p>(default: <code>false</code>)</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+explicit_iter_loop">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L98">View Source</a></div></div></div></article><article id="explicit_write"><input id="label-explicit_write" type="checkbox"><label for="label-explicit_write"><h2 class="lint-title"><div class="panel-title-name" id="lint-explicit_write">explicit_write
<a href="#explicit_write" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>write!()</code> / <code>writeln()!</code> which can be
replaced with <code>(e)print!()</code> / <code>(e)println!()</code></p>
<h3>Why is this bad?</h3>
<p>Using <code>(e)println!</code> is clearer and more concise</p>
<h3>Example</h3>
<pre><code class="language-rust">writeln!(&amp;mut std::io::stderr(), "foo: {:?}", bar).unwrap();
writeln!(&amp;mut std::io::stdout(), "foo: {:?}", bar).unwrap();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">eprintln!("foo: {:?}", bar);
println!("foo: {:?}", bar);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+explicit_write">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/explicit_write.rs#L13">View Source</a></div></div></div></article><article id="extend_from_slice"><input id="label-extend_from_slice" type="checkbox"><label for="label-extend_from_slice"><h2 class="lint-title"><div class="panel-title-name" id="lint-extend_from_slice">extend_from_slice
<a href="#extend_from_slice" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p><code>Vec::extend_from_slice</code> is no longer faster than <code>Vec::extend</code> due to specialization.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+extend_from_slice">Related Issues</a></div></div></div></article><article id="extend_with_drain"><input id="label-extend_with_drain" type="checkbox"><label for="label-extend_with_drain"><h2 class="lint-title"><div class="panel-title-name" id="lint-extend_with_drain">extend_with_drain
<a href="#extend_with_drain" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for occurrences where one vector gets extended instead of append</p>
<h3>Why is this bad?</h3>
<p>Using <code>append</code> instead of <code>extend</code> is more concise and faster</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut a = vec![1, 2, 3];
let mut b = vec![4, 5, 6];

a.extend(b.drain(..));
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut a = vec![1, 2, 3];
let mut b = vec![4, 5, 6];

a.append(&amp;mut b);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.55.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+extend_with_drain">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1385">View Source</a></div></div></div></article><article id="extra_unused_lifetimes"><input id="label-extra_unused_lifetimes" type="checkbox"><label for="label-extra_unused_lifetimes"><h2 class="lint-title"><div class="panel-title-name" id="lint-extra_unused_lifetimes">extra_unused_lifetimes
<a href="#extra_unused_lifetimes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for lifetimes in generics that are never used
anywhere else.</p>
<h3>Why is this bad?</h3>
<p>The additional lifetimes make the code look more
complicated, while there is nothing out of the ordinary going on. Removing
them leads to more readable code.</p>
<h3>Example</h3>
<pre><code class="language-rust">// unnecessary lifetimes
fn unused_lifetime&lt;'a&gt;(x: u8) {
    // ..
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn no_lifetime(x: u8) {
    // ...
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+extra_unused_lifetimes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/lifetimes.rs#L97">View Source</a></div></div></div></article><article id="extra_unused_type_parameters"><input id="label-extra_unused_type_parameters" type="checkbox"><label for="label-extra_unused_type_parameters"><h2 class="lint-title"><div class="panel-title-name" id="lint-extra_unused_type_parameters">extra_unused_type_parameters
<a href="#extra_unused_type_parameters" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for type parameters in generics that are never used anywhere else.</p>
<h3>Why is this bad?</h3>
<p>Functions cannot infer the value of unused type parameters; therefore, calling them
requires using a turbofish, which serves no purpose but to satisfy the compiler.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn unused_ty&lt;T&gt;(x: u8) {
    // ..
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn no_unused_ty(x: u8) {
    // ..
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.69.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+extra_unused_type_parameters">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/extra_unused_type_parameters.rs#L17">View Source</a></div></div></div></article><article id="fallible_impl_from"><input id="label-fallible_impl_from" type="checkbox"><label for="label-fallible_impl_from"><h2 class="lint-title"><div class="panel-title-name" id="lint-fallible_impl_from">fallible_impl_from
<a href="#fallible_impl_from" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for impls of <code>From&lt;..&gt;</code> that contain <code>panic!()</code> or <code>unwrap()</code></p>
<h3>Why is this bad?</h3>
<p><code>TryFrom</code> should be used if there’s a possibility of failure.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Foo(i32);

impl From&lt;String&gt; for Foo {
    fn from(s: String) -&gt; Self {
        Foo(s.parse().unwrap())
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct Foo(i32);

impl TryFrom&lt;String&gt; for Foo {
    type Error = ();
    fn try_from(s: String) -&gt; Result&lt;Self, Self::Error&gt; {
        if let Ok(parsed) = s.parse() {
            Ok(Foo(parsed))
        } else {
            Err(())
        }
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+fallible_impl_from">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/fallible_impl_from.rs#L11">View Source</a></div></div></div></article><article id="field_reassign_with_default"><input id="label-field_reassign_with_default" type="checkbox"><label for="label-field_reassign_with_default"><h2 class="lint-title"><div class="panel-title-name" id="lint-field_reassign_with_default">field_reassign_with_default
<a href="#field_reassign_with_default" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for immediate reassignment of fields initialized
with Default::default().</p>
<h3>Why is this bad?</h3>
<p>It’s more idiomatic to use the <a href="https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax">functional update syntax</a>.</p>
<h3>Known problems</h3>
<p>Assignments to patterns that are of tuple type are not linted.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut a: A = Default::default();
a.i = 42;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a = A {
    i: 42,
    .. Default::default()
};
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+field_reassign_with_default">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/default.rs#L38">View Source</a></div></div></div></article><article id="field_scoped_visibility_modifiers"><input id="label-field_scoped_visibility_modifiers" type="checkbox"><label for="label-field_scoped_visibility_modifiers"><h2 class="lint-title"><div class="panel-title-name" id="lint-field_scoped_visibility_modifiers">field_scoped_visibility_modifiers
<a href="#field_scoped_visibility_modifiers" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of scoped visibility modifiers, like <code>pub(crate)</code>, on fields. These
make a field visible within a scope between public and private.</p>
<h3>Why restrict this?</h3>
<p>Scoped visibility modifiers cause a field to be accessible within some scope between
public and private, potentially within an entire crate. This allows for fields to be
non-private while upholding internal invariants, but can be a code smell. Scoped visibility
requires checking a greater area, potentially an entire crate, to verify that an invariant
is upheld, and global analysis requires a lot of effort.</p>
<h3>Example</h3>
<pre><code class="language-rust">pub mod public_module {
    struct MyStruct {
        pub(crate) first_field: bool,
        pub(super) second_field: bool
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">pub mod public_module {
    struct MyStruct {
        first_field: bool,
        second_field: bool
    }
    impl MyStruct {
        pub(crate) fn get_first_field(&amp;self) -&gt; bool {
            self.first_field
        }
        pub(super) fn get_second_field(&amp;self) -&gt; bool {
            self.second_field
        }
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.81.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+field_scoped_visibility_modifiers">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/field_scoped_visibility_modifiers.rs#L6">View Source</a></div></div></div></article><article id="filetype_is_file"><input id="label-filetype_is_file" type="checkbox"><label for="label-filetype_is_file"><h2 class="lint-title"><div class="panel-title-name" id="lint-filetype_is_file">filetype_is_file
<a href="#filetype_is_file" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>FileType::is_file()</code>.</p>
<h3>Why restrict this?</h3>
<p>When people testing a file type with <code>FileType::is_file</code>
they are testing whether a path is something they can get bytes from. But
<code>is_file</code> doesn’t cover special file types in unix-like systems, and doesn’t cover
symlink in windows. Using <code>!FileType::is_dir()</code> is a better way to that intention.</p>
<h3>Example</h3>
<pre><code class="language-rust">let metadata = std::fs::metadata("foo.txt")?;
let filetype = metadata.file_type();

if filetype.is_file() {
    // read file
}
</code></pre>
<p>should be written as:</p>
<pre><code class="language-rust">let metadata = std::fs::metadata("foo.txt")?;
let filetype = metadata.file_type();

if !filetype.is_dir() {
    // read file
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.42.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+filetype_is_file">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1803">View Source</a></div></div></div></article><article id="filter_map_bool_then"><input id="label-filter_map_bool_then" type="checkbox"><label for="label-filter_map_bool_then"><h2 class="lint-title"><div class="panel-title-name" id="lint-filter_map_bool_then">filter_map_bool_then
<a href="#filter_map_bool_then" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>bool::then</code> in <code>Iterator::filter_map</code>.</p>
<h3>Why is this bad?</h3>
<p>This can be written with <code>filter</code> then <code>map</code> instead, which would reduce nesting and
separates the filtering from the transformation phase. This comes with no cost to
performance and is just cleaner.</p>
<h3>Limitations</h3>
<p>Does not lint <code>bool::then_some</code>, as it eagerly evaluates its arguments rather than lazily.
This can create differing behavior, so better safe than sorry.</p>
<h3>Example</h3>
<pre><code class="language-rust">_ = v.into_iter().filter_map(|i| (i % 2 == 0).then(|| really_expensive_fn(i)));
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">_ = v.into_iter().filter(|i| i % 2 == 0).map(|i| really_expensive_fn(i));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+filter_map_bool_then">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3623">View Source</a></div></div></div></article><article id="filter_map_identity"><input id="label-filter_map_identity" type="checkbox"><label for="label-filter_map_identity"><h2 class="lint-title"><div class="panel-title-name" id="lint-filter_map_identity">filter_map_identity
<a href="#filter_map_identity" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>filter_map(|x| x)</code>.</p>
<h3>Why is this bad?</h3>
<p>Readability, this can be written more concisely by using <code>flatten</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">iter.filter_map(|x| x);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">iter.flatten();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.52.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+filter_map_identity">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2056">View Source</a></div></div></div></article><article id="filter_map_next"><input id="label-filter_map_next" type="checkbox"><label for="label-filter_map_next"><h2 class="lint-title"><div class="panel-title-name" id="lint-filter_map_next">filter_map_next
<a href="#filter_map_next" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>_.filter_map(_).next()</code>.</p>
<h3>Why is this bad?</h3>
<p>Readability, this can be written more concisely as
<code>_.find_map(_)</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust"> (0..3).filter_map(|x| if x == 2 { Some(x) } else { None }).next();
</code></pre>
<p>Can be written as</p>
<pre><code class="language-rust"> (0..3).find_map(|x| if x == 2 { Some(x) } else { None });
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.36.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+filter_map_next">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L819">View Source</a></div></div></div></article><article id="filter_next"><input id="label-filter_next" type="checkbox"><label for="label-filter_next"><h2 class="lint-title"><div class="panel-title-name" id="lint-filter_next">filter_next
<a href="#filter_next" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>_.filter(_).next()</code>.</p>
<h3>Why is this bad?</h3>
<p>Readability, this can be written more concisely as
<code>_.find(_)</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">vec.iter().filter(|x| **x == 0).next();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">vec.iter().find(|x| **x == 0);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+filter_next">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L687">View Source</a></div></div></div></article><article id="flat_map_identity"><input id="label-flat_map_identity" type="checkbox"><label for="label-flat_map_identity"><h2 class="lint-title"><div class="panel-title-name" id="lint-flat_map_identity">flat_map_identity
<a href="#flat_map_identity" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>flat_map(|x| x)</code>.</p>
<h3>Why is this bad?</h3>
<p>Readability, this can be written more concisely by using <code>flatten</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">iter.flat_map(|x| x);
</code></pre>
<p>Can be written as</p>
<pre><code class="language-rust">iter.flatten();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.39.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+flat_map_identity">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L842">View Source</a></div></div></div></article><article id="flat_map_option"><input id="label-flat_map_option" type="checkbox"><label for="label-flat_map_option"><h2 class="lint-title"><div class="panel-title-name" id="lint-flat_map_option">flat_map_option
<a href="#flat_map_option" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>Iterator::flat_map()</code> where <code>filter_map()</code> could be
used instead.</p>
<h3>Why is this bad?</h3>
<p><code>filter_map()</code> is known to always produce 0 or 1 output items per input item,
rather than however many the inner iterator type produces.
Therefore, it maintains the upper bound in <code>Iterator::size_hint()</code>,
and communicates to the reader that the input items are not being expanded into
multiple output items without their having to notice that the mapping function
returns an <code>Option</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let nums: Vec&lt;i32&gt; = ["1", "2", "whee!"].iter().flat_map(|x| x.parse().ok()).collect();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let nums: Vec&lt;i32&gt; = ["1", "2", "whee!"].iter().filter_map(|x| x.parse().ok()).collect();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.53.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+flat_map_option">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L246">View Source</a></div></div></div></article><article id="float_arithmetic"><input id="label-float_arithmetic" type="checkbox"><label for="label-float_arithmetic"><h2 class="lint-title"><div class="panel-title-name" id="lint-float_arithmetic">float_arithmetic
<a href="#float_arithmetic" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for float arithmetic.</p>
<h3>Why restrict this?</h3>
<p>For some embedded systems or kernel development, it
can be useful to rule out floating-point numbers.</p>
<h3>Example</h3>
<pre><code class="language-rust">a + 1.0;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+float_arithmetic">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L106">View Source</a></div></div></div></article><article id="float_cmp"><input id="label-float_cmp" type="checkbox"><label for="label-float_cmp"><h2 class="lint-title"><div class="panel-title-name" id="lint-float_cmp">float_cmp
<a href="#float_cmp" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for (in-)equality comparisons on floating-point
values (apart from zero), except in functions called <code>*eq*</code> (which probably
implement equality for a type involving floats).</p>
<h3>Why is this bad?</h3>
<p>Floating point calculations are usually imprecise, so asking if two values are <em>exactly</em>
equal is asking for trouble because arriving at the same logical result via different
routes (e.g. calculation versus constant) may yield different values.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a: f64 = 1000.1;
let b: f64 = 0.2;
let x = a + b;
let y = 1000.3; // Expected value.

// Actual value: 1000.3000000000001
println!("{x}");

let are_equal = x == y;
println!("{are_equal}"); // false
</code></pre>
<p>The correct way to compare floating point numbers is to define an allowed error margin. This
may be challenging if there is no “natural” error margin to permit. Broadly speaking, there
are two cases:</p>
<ol>
<li>If your values are in a known range and you can define a threshold for “close enough to
be equal”, it may be appropriate to define an absolute error margin. For example, if your
data is “length of vehicle in centimeters”, you may consider 0.1 cm to be “close enough”.</li>
<li>If your code is more general and you do not know the range of values, you should use a
relative error margin, accepting e.g. 0.1% of error regardless of specific values.</li>
</ol>
<p>For the scenario where you can define a meaningful absolute error margin, consider using:</p>
<pre><code class="language-rust">let a: f64 = 1000.1;
let b: f64 = 0.2;
let x = a + b;
let y = 1000.3; // Expected value.

const ALLOWED_ERROR_VEHICLE_LENGTH_CM: f64 = 0.1;
let within_tolerance = (x - y).abs() &lt; ALLOWED_ERROR_VEHICLE_LENGTH_CM;
println!("{within_tolerance}"); // true
</code></pre>
<p>NOTE: Do not use <code>f64::EPSILON</code> - while the error margin is often called “epsilon”, this is
a different use of the term that is not suitable for floating point equality comparison.
Indeed, for the example above using <code>f64::EPSILON</code> as the allowed error would return <code>false</code>.</p>
<p>For the scenario where no meaningful absolute error can be defined, refer to
<a href="https://www.floating-point-gui.de/errors/comparison">the floating point guide</a>
for a reference implementation of relative error based comparison of floating point values.
<code>MIN_NORMAL</code> in the reference implementation is equivalent to <code>MIN_POSITIVE</code> in Rust.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+float_cmp">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L574">View Source</a></div></div></div></article><article id="float_cmp_const"><input id="label-float_cmp_const" type="checkbox"><label for="label-float_cmp_const"><h2 class="lint-title"><div class="panel-title-name" id="lint-float_cmp_const">float_cmp_const
<a href="#float_cmp_const" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for (in-)equality comparisons on constant floating-point
values (apart from zero), except in functions called <code>*eq*</code> (which probably
implement equality for a type involving floats).</p>
<h3>Why restrict this?</h3>
<p>Floating point calculations are usually imprecise, so asking if two values are <em>exactly</em>
equal is asking for trouble because arriving at the same logical result via different
routes (e.g. calculation versus constant) may yield different values.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a: f64 = 1000.1;
let b: f64 = 0.2;
let x = a + b;
const Y: f64 = 1000.3; // Expected value.

// Actual value: 1000.3000000000001
println!("{x}");

let are_equal = x == Y;
println!("{are_equal}"); // false
</code></pre>
<p>The correct way to compare floating point numbers is to define an allowed error margin. This
may be challenging if there is no “natural” error margin to permit. Broadly speaking, there
are two cases:</p>
<ol>
<li>If your values are in a known range and you can define a threshold for “close enough to
be equal”, it may be appropriate to define an absolute error margin. For example, if your
data is “length of vehicle in centimeters”, you may consider 0.1 cm to be “close enough”.</li>
<li>If your code is more general and you do not know the range of values, you should use a
relative error margin, accepting e.g. 0.1% of error regardless of specific values.</li>
</ol>
<p>For the scenario where you can define a meaningful absolute error margin, consider using:</p>
<pre><code class="language-rust">let a: f64 = 1000.1;
let b: f64 = 0.2;
let x = a + b;
const Y: f64 = 1000.3; // Expected value.

const ALLOWED_ERROR_VEHICLE_LENGTH_CM: f64 = 0.1;
let within_tolerance = (x - Y).abs() &lt; ALLOWED_ERROR_VEHICLE_LENGTH_CM;
println!("{within_tolerance}"); // true
</code></pre>
<p>NOTE: Do not use <code>f64::EPSILON</code> - while the error margin is often called “epsilon”, this is
a different use of the term that is not suitable for floating point equality comparison.
Indeed, for the example above using <code>f64::EPSILON</code> as the allowed error would return <code>false</code>.</p>
<p>For the scenario where no meaningful absolute error can be defined, refer to
<a href="https://www.floating-point-gui.de/errors/comparison">the floating point guide</a>
for a reference implementation of relative error based comparison of floating point values.
<code>MIN_NORMAL</code> in the reference implementation is equivalent to <code>MIN_POSITIVE</code> in Rust.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+float_cmp_const">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L637">View Source</a></div></div></div></article><article id="float_equality_without_abs"><input id="label-float_equality_without_abs" type="checkbox"><label for="label-float_equality_without_abs"><h2 class="lint-title"><div class="panel-title-name" id="lint-float_equality_without_abs">float_equality_without_abs
<a href="#float_equality_without_abs" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for statements of the form <code>(a - b) &lt; f32::EPSILON</code> or
<code>(a - b) &lt; f64::EPSILON</code>. Note the missing <code>.abs()</code>.</p>
<h3>Why is this bad?</h3>
<p>The code without <code>.abs()</code> is more likely to have a bug.</p>
<h3>Known problems</h3>
<p>If the user can ensure that b is larger than a, the <code>.abs()</code> is
technically unnecessary. However, it will make the code more robust and doesn’t have any
large performance implications. If the abs call was deliberately left out for performance
reasons, it is probably better to state this explicitly in the code, which then can be done
with an allow.</p>
<h3>Example</h3>
<pre><code class="language-rust">pub fn is_roughly_equal(a: f32, b: f32) -&gt; bool {
    (a - b) &lt; f32::EPSILON
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">pub fn is_roughly_equal(a: f32, b: f32) -&gt; bool {
    (a - b).abs() &lt; f32::EPSILON
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.48.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+float_equality_without_abs">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L467">View Source</a></div></div></div></article><article id="fn_params_excessive_bools"><input id="label-fn_params_excessive_bools" type="checkbox"><label for="label-fn_params_excessive_bools"><h2 class="lint-title"><div class="panel-title-name" id="lint-fn_params_excessive_bools">fn_params_excessive_bools
<a href="#fn_params_excessive_bools" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for excessive use of
bools in function definitions.</p>
<h3>Why is this bad?</h3>
<p>Calls to such functions
are confusing and error prone, because it’s
hard to remember argument order and you have
no type system support to back you up. Using
two-variant enums instead of bools often makes
API easier to use.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn f(is_round: bool, is_hot: bool) { ... }
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">enum Shape {
    Round,
    Spiky,
}

enum Temperature {
    Hot,
    IceCold,
}

fn f(shape: Shape, temperature: Temperature) { ... }
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>max-fn-params-bools</code>:  The maximum number of bool parameters a function can have</p>
<p>(default: <code>3</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.43.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+fn_params_excessive_bools">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/excessive_bools.rs#L53">View Source</a></div></div></div></article><article id="fn_to_numeric_cast"><input id="label-fn_to_numeric_cast" type="checkbox"><label for="label-fn_to_numeric_cast"><h2 class="lint-title"><div class="panel-title-name" id="lint-fn_to_numeric_cast">fn_to_numeric_cast
<a href="#fn_to_numeric_cast" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for casts of function pointers to something other than <code>usize</code>.</p>
<h3>Why is this bad?</h3>
<p>Casting a function pointer to anything other than <code>usize</code>/<code>isize</code> is
not portable across architectures. If the target type is too small the
address would be truncated, and target types larger than <code>usize</code> are
unnecessary.</p>
<p>Casting to <code>isize</code> also doesn’t make sense, since addresses are never
signed.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn fun() -&gt; i32 { 1 }
let _ = fun as i64;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = fun as usize;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+fn_to_numeric_cast">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L251">View Source</a></div></div></div></article><article id="fn_to_numeric_cast_any"><input id="label-fn_to_numeric_cast_any" type="checkbox"><label for="label-fn_to_numeric_cast_any"><h2 class="lint-title"><div class="panel-title-name" id="lint-fn_to_numeric_cast_any">fn_to_numeric_cast_any
<a href="#fn_to_numeric_cast_any" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for casts of a function pointer to any integer type.</p>
<h3>Why restrict this?</h3>
<p>Casting a function pointer to an integer can have surprising results and can occur
accidentally if parentheses are omitted from a function call. If you aren’t doing anything
low-level with function pointers then you can opt out of casting functions to integers in
order to avoid mistakes. Alternatively, you can use this lint to audit all uses of function
pointer casts in your code.</p>
<h3>Example</h3>
<pre><code class="language-rust">// fn1 is cast as `usize`
fn fn1() -&gt; u16 {
    1
};
let _ = fn1 as usize;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// maybe you intended to call the function?
fn fn2() -&gt; u16 {
    1
};
let _ = fn2() as usize;

// or

// maybe you intended to cast it to a function type?
fn fn3() -&gt; u16 {
    1
}
let _ = fn3 as fn() -&gt; u16;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.58.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+fn_to_numeric_cast_any">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L314">View Source</a></div></div></div></article><article id="fn_to_numeric_cast_with_truncation"><input id="label-fn_to_numeric_cast_with_truncation" type="checkbox"><label for="label-fn_to_numeric_cast_with_truncation"><h2 class="lint-title"><div class="panel-title-name" id="lint-fn_to_numeric_cast_with_truncation">fn_to_numeric_cast_with_truncation
<a href="#fn_to_numeric_cast_with_truncation" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for casts of a function pointer to a numeric type not wide enough to
store an address.</p>
<h3>Why is this bad?</h3>
<p>Such a cast discards some bits of the function’s address. If this is intended, it would be more
clearly expressed by casting to <code>usize</code> first, then casting the <code>usize</code> to the intended type (with
a comment) to perform the truncation.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn fn1() -&gt; i16 {
    1
};
let _ = fn1 as i32;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// Cast to usize first, then comment with the reason for the truncation
fn fn1() -&gt; i16 {
    1
};
let fn_ptr = fn1 as usize;
let fn_ptr_truncated = fn_ptr as i32;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+fn_to_numeric_cast_with_truncation">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L281">View Source</a></div></div></div></article><article id="for_kv_map"><input id="label-for_kv_map" type="checkbox"><label for="label-for_kv_map"><h2 class="lint-title"><div class="panel-title-name" id="lint-for_kv_map">for_kv_map
<a href="#for_kv_map" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for iterating a map (<code>HashMap</code> or <code>BTreeMap</code>) and
ignoring either the keys or values.</p>
<h3>Why is this bad?</h3>
<p>Readability. There are <code>keys</code> and <code>values</code> methods that
can be used to express that don’t need the values or keys.</p>
<h3>Example</h3>
<pre><code class="language-rust">for (k, _) in &amp;map {
    ..
}
</code></pre>
<p>could be replaced by</p>
<pre><code class="language-rust">for k in map.keys() {
    ..
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+for_kv_map">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L311">View Source</a></div></div></div></article><article id="forget_non_drop"><input id="label-forget_non_drop" type="checkbox"><label for="label-forget_non_drop"><h2 class="lint-title"><div class="panel-title-name" id="lint-forget_non_drop">forget_non_drop
<a href="#forget_non_drop" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>std::mem::forget</code> with a value that does not implement <code>Drop</code>.</p>
<h3>Why is this bad?</h3>
<p>Calling <code>std::mem::forget</code> is no different than dropping such a type. A different value may
have been intended.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Foo;
let x = Foo;
std::mem::forget(x);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+forget_non_drop">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/drop_forget_ref.rs#L31">View Source</a></div></div></div></article><article id="format_collect"><input id="label-format_collect" type="checkbox"><label for="label-format_collect"><h2 class="lint-title"><div class="panel-title-name" id="lint-format_collect">format_collect
<a href="#format_collect" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.map(|_| format!(..)).collect::&lt;String&gt;()</code>.</p>
<h3>Why is this bad?</h3>
<p>This allocates a new string for every element in the iterator.
This can be done more efficiently by creating the <code>String</code> once and appending to it in <code>Iterator::fold</code>,
using either the <code>write!</code> macro which supports exactly the same syntax as the <code>format!</code> macro,
or concatenating with <code>+</code> in case the iterator yields <code>&amp;str</code>/<code>String</code>.</p>
<p>Note also that <code>write!</code>-ing into a <code>String</code> can never fail, despite the return type of <code>write!</code> being <code>std::fmt::Result</code>,
so it can be safely ignored or unwrapped.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn hex_encode(bytes: &amp;[u8]) -&gt; String {
    bytes.iter().map(|b| format!("{b:02X}")).collect()
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::fmt::Write;
fn hex_encode(bytes: &amp;[u8]) -&gt; String {
    bytes.iter().fold(String::new(), |mut output, b| {
        let _ = write!(output, "{b:02X}");
        output
    })
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+format_collect">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3567">View Source</a></div></div></div></article><article id="format_in_format_args"><input id="label-format_in_format_args" type="checkbox"><label for="label-format_in_format_args"><h2 class="lint-title"><div class="panel-title-name" id="lint-format_in_format_args">format_in_format_args
<a href="#format_in_format_args" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects <code>format!</code> within the arguments of another macro that does
formatting such as <code>format!</code> itself, <code>write!</code> or <code>println!</code>. Suggests
inlining the <code>format!</code> call.</p>
<h3>Why is this bad?</h3>
<p>The recommended code is both shorter and avoids a temporary allocation.</p>
<h3>Example</h3>
<pre><code class="language-rust">println!("error: {}", format!("something failed at {}", Location::caller()));
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">println!("error: something failed at {}", Location::caller());
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.58.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+format_in_format_args">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/format_args.rs#L35">View Source</a></div></div></div></article><article id="format_push_string"><input id="label-format_push_string" type="checkbox"><label for="label-format_push_string"><h2 class="lint-title"><div class="panel-title-name" id="lint-format_push_string">format_push_string
<a href="#format_push_string" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects cases where the result of a <code>format!</code> call is
appended to an existing <code>String</code>.</p>
<h3>Why is this bad?</h3>
<p>Introduces an extra, avoidable heap allocation.</p>
<h3>Known problems</h3>
<p><code>format!</code> returns a <code>String</code> but <code>write!</code> returns a <code>Result</code>.
Thus you are forced to ignore the <code>Err</code> variant to achieve the same API.</p>
<p>While using <code>write!</code> in the suggested way should never fail, this isn’t necessarily clear to the programmer.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut s = String::new();
s += &amp;format!("0x{:X}", 1024);
s.push_str(&amp;format!("0x{:X}", 1024));
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::fmt::Write as _; // import without risk of name clashing

let mut s = String::new();
let _ = write!(s, "0x{:X}", 1024);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+format_push_string">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/format_push_string.rs#L12">View Source</a></div></div></div></article><article id="four_forward_slashes"><input id="label-four_forward_slashes" type="checkbox"><label for="label-four_forward_slashes"><h2 class="lint-title"><div class="panel-title-name" id="lint-four_forward_slashes">four_forward_slashes
<a href="#four_forward_slashes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for outer doc comments written with 4 forward slashes (<code>////</code>).</p>
<h3>Why is this bad?</h3>
<p>This is (probably) a typo, and results in it not being a doc comment; just a regular
comment.</p>
<h3>Example</h3>
<pre><code class="language-rust">//// My amazing data structure
pub struct Foo {
    // ...
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">/// My amazing data structure
pub struct Foo {
    // ...
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+four_forward_slashes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/four_forward_slashes.rs#L10">View Source</a></div></div></div></article><article id="from_iter_instead_of_collect"><input id="label-from_iter_instead_of_collect" type="checkbox"><label for="label-from_iter_instead_of_collect"><h2 class="lint-title"><div class="panel-title-name" id="lint-from_iter_instead_of_collect">from_iter_instead_of_collect
<a href="#from_iter_instead_of_collect" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>from_iter()</code> function calls on types that implement the <code>FromIterator</code>
trait.</p>
<h3>Why is this bad?</h3>
<p>If it’s needed to create a collection from the contents of an iterator, the <code>Iterator::collect(_)</code>
method is preferred. However, when it’s needed to specify the container type,
<code>Vec::from_iter(_)</code> can be more readable than using a turbofish (e.g. <code>_.collect::&lt;Vec&lt;_&gt;&gt;()</code>). See
<a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html">FromIterator documentation</a></p>
<h3>Example</h3>
<pre><code class="language-rust">let five_fives = std::iter::repeat(5).take(5);

let v = Vec::from_iter(five_fives);

assert_eq!(v, vec![5, 5, 5, 5, 5]);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let five_fives = std::iter::repeat(5).take(5);

let v: Vec&lt;i32&gt; = five_fives.collect();

assert_eq!(v, vec![5, 5, 5, 5, 5]);
</code></pre>
<p>but prefer to use</p>
<pre><code class="language-rust">let numbers: Vec&lt;i32&gt; = FromIterator::from_iter(1..=5);
</code></pre>
<p>instead of</p>
<pre><code class="language-rust">let numbers = (1..=5).collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+from_iter_instead_of_collect">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1985">View Source</a></div></div></div></article><article id="from_over_into"><input id="label-from_over_into" type="checkbox"><label for="label-from_over_into"><h2 class="lint-title"><div class="panel-title-name" id="lint-from_over_into">from_over_into
<a href="#from_over_into" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Searches for implementations of the <code>Into&lt;..&gt;</code> trait and suggests to implement <code>From&lt;..&gt;</code> instead.</p>
<h3>Why is this bad?</h3>
<p>According the std docs implementing <code>From&lt;..&gt;</code> is preferred since it gives you <code>Into&lt;..&gt;</code> for free where the reverse isn’t true.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct StringWrapper(String);

impl Into&lt;StringWrapper&gt; for String {
    fn into(self) -&gt; StringWrapper {
        StringWrapper(self)
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct StringWrapper(String);

impl From&lt;String&gt; for StringWrapper {
    fn from(s: String) -&gt; StringWrapper {
        StringWrapper(s)
    }
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.51.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+from_over_into">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/from_over_into.rs#L22">View Source</a></div></div></div></article><article id="from_raw_with_void_ptr"><input id="label-from_raw_with_void_ptr" type="checkbox"><label for="label-from_raw_with_void_ptr"><h2 class="lint-title"><div class="panel-title-name" id="lint-from_raw_with_void_ptr">from_raw_with_void_ptr
<a href="#from_raw_with_void_ptr" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks if we’re passing a <code>c_void</code> raw pointer to <code>{Box,Rc,Arc,Weak}::from_raw(_)</code></p>
<h3>Why is this bad?</h3>
<p>When dealing with <code>c_void</code> raw pointers in FFI, it is easy to run into the pitfall of calling <code>from_raw</code> with the <code>c_void</code> pointer.
The type signature of <code>Box::from_raw</code> is <code>fn from_raw(raw: *mut T) -&gt; Box&lt;T&gt;</code>, so if you pass a <code>*mut c_void</code> you will get a <code>Box&lt;c_void&gt;</code> (and similarly for <code>Rc</code>, <code>Arc</code> and <code>Weak</code>).
For this to be safe, <code>c_void</code> would need to have the same memory layout as the original type, which is often not the case.</p>
<h3>Example</h3>
<pre><code class="language-rust">let ptr = Box::into_raw(Box::new(42usize)) as *mut c_void;
let _ = unsafe { Box::from_raw(ptr) };
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = unsafe { Box::from_raw(ptr as *mut usize) };
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.67.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+from_raw_with_void_ptr">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/from_raw_with_void_ptr.rs#L11">View Source</a></div></div></div></article><article id="from_str_radix_10"><input id="label-from_str_radix_10" type="checkbox"><label for="label-from_str_radix_10"><h2 class="lint-title"><div class="panel-title-name" id="lint-from_str_radix_10">from_str_radix_10
<a href="#from_str_radix_10" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for function invocations of the form <code>primitive::from_str_radix(s, 10)</code></p>
<h3>Why is this bad?</h3>
<p>This specific common use case can be rewritten as <code>s.parse::&lt;primitive&gt;()</code>
(and in most cases, the turbofish can be removed), which reduces code length
and complexity.</p>
<h3>Known problems</h3>
<p>This lint may suggest using <code>(&amp;&lt;expression&gt;).parse()</code> instead of <code>&lt;expression&gt;.parse()</code>
directly in some cases, which is correct but adds unnecessary complexity to the code.</p>
<h3>Example</h3>
<pre><code class="language-rust">let input: &amp;str = get_input();
let num = u16::from_str_radix(input, 10)?;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let input: &amp;str = get_input();
let num: u16 = input.parse()?;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.52.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+from_str_radix_10">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/from_str_radix_10.rs#L11">View Source</a></div></div></div></article><article id="future_not_send"><input id="label-future_not_send" type="checkbox"><label for="label-future_not_send"><h2 class="lint-title"><div class="panel-title-name" id="lint-future_not_send">future_not_send
<a href="#future_not_send" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint requires Future implementations returned from
functions and methods to implement the <code>Send</code> marker trait,
ignoring type parameters.</p>
<p>If a function is generic and its Future conditionally implements <code>Send</code>
based on a generic parameter then it is considered <code>Send</code> and no warning is emitted.</p>
<p>This can be used by library authors (public and internal) to ensure
their functions are compatible with both multi-threaded runtimes that require <code>Send</code> futures,
as well as single-threaded runtimes where callers may choose <code>!Send</code> types
for generic parameters.</p>
<h3>Why is this bad?</h3>
<p>A Future implementation captures some state that it
needs to eventually produce its final value. When targeting a multithreaded
executor (which is the norm on non-embedded devices) this means that this
state may need to be transported to other threads, in other words the
whole Future needs to implement the <code>Send</code> marker trait. If it does not,
then the resulting Future cannot be submitted to a thread pool in the
end user’s code.</p>
<p>Especially for generic functions it can be confusing to leave the
discovery of this problem to the end user: the reported error location
will be far from its cause and can in many cases not even be fixed without
modifying the library where the offending Future implementation is
produced.</p>
<h3>Example</h3>
<pre><code class="language-rust">async fn not_send(bytes: std::rc::Rc&lt;[u8]&gt;) {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">async fn is_send(bytes: std::sync::Arc&lt;[u8]&gt;) {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.44.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+future_not_send">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/future_not_send.rs#L19">View Source</a></div></div></div></article><article id="get_first"><input id="label-get_first" type="checkbox"><label for="label-get_first"><h2 class="lint-title"><div class="panel-title-name" id="lint-get_first">get_first
<a href="#get_first" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>x.get(0)</code> instead of
<code>x.first()</code> or <code>x.front()</code>.</p>
<h3>Why is this bad?</h3>
<p>Using <code>x.first()</code> for <code>Vec</code>s and slices or <code>x.front()</code>
for <code>VecDeque</code>s is easier to read and has the same result.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = vec![2, 3, 5];
let first_element = x.get(0);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = vec![2, 3, 5];
let first_element = x.first();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.63.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+get_first">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2673">View Source</a></div></div></div></article><article id="get_last_with_len"><input id="label-get_last_with_len" type="checkbox"><label for="label-get_last_with_len"><h2 class="lint-title"><div class="panel-title-name" id="lint-get_last_with_len">get_last_with_len
<a href="#get_last_with_len" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>x.get(x.len() - 1)</code> instead of
<code>x.last()</code>.</p>
<h3>Why is this bad?</h3>
<p>Using <code>x.last()</code> is easier to read and has the same
result.</p>
<p>Note that using <code>x[x.len() - 1]</code> is semantically different from
<code>x.last()</code>.  Indexing into the array will panic on out-of-bounds
accesses, while <code>x.get()</code> and <code>x.last()</code> will return <code>None</code>.</p>
<p>There is another lint (get_unwrap) that covers the case of using
<code>x.get(index).unwrap()</code> instead of <code>x[index]</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = vec![2, 3, 5];
let last_element = x.get(x.len() - 1);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = vec![2, 3, 5];
let last_element = x.last();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.37.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+get_last_with_len">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1315">View Source</a></div></div></div></article><article id="get_unwrap"><input id="label-get_unwrap" type="checkbox"><label for="label-get_unwrap"><h2 class="lint-title"><div class="panel-title-name" id="lint-get_unwrap">get_unwrap
<a href="#get_unwrap" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.get().unwrap()</code> (or
<code>.get_mut().unwrap</code>) on a standard library type which implements <code>Index</code></p>
<h3>Why restrict this?</h3>
<p>Using the Index trait (<code>[]</code>) is more clear and more
concise.</p>
<h3>Known problems</h3>
<p>Not a replacement for error handling: Using either
<code>.unwrap()</code> or the Index trait (<code>[]</code>) carries the risk of causing a <code>panic</code>
if the value being accessed is <code>None</code>. If the use of <code>.get().unwrap()</code> is a
temporary placeholder for dealing with the <code>Option</code> type, then this does
not mitigate the need for error handling. If there is a chance that <code>.get()</code>
will be <code>None</code> in your program, then it is advisable that the <code>None</code> case
is handled in a future refactor instead of using <code>.unwrap()</code> or the Index
trait.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut some_vec = vec![0, 1, 2, 3];
let last = some_vec.get(3).unwrap();
*some_vec.get_mut(0).unwrap() = 1;
</code></pre>
<p>The correct use would be:</p>
<pre><code class="language-rust">let mut some_vec = vec![0, 1, 2, 3];
let last = some_vec[3];
some_vec[0] = 1;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+get_unwrap">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1348">View Source</a></div></div></div></article><article id="host_endian_bytes"><input id="label-host_endian_bytes" type="checkbox"><label for="label-host_endian_bytes"><h2 class="lint-title"><div class="panel-title-name" id="lint-host_endian_bytes">host_endian_bytes
<a href="#host_endian_bytes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the usage of the <code>to_ne_bytes</code> method and/or the function <code>from_ne_bytes</code>.</p>
<h3>Why restrict this?</h3>
<p>To ensure use of explicitly chosen endianness rather than the target’s endianness,
such as when implementing network protocols or file formats rather than FFI.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _x = 2i32.to_ne_bytes();
let _y = 2i64.to_ne_bytes();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+host_endian_bytes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/endian_bytes.rs#L11">View Source</a></div></div></div></article><article id="identity_op"><input id="label-identity_op" type="checkbox"><label for="label-identity_op"><h2 class="lint-title"><div class="panel-title-name" id="lint-identity_op">identity_op
<a href="#identity_op" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for identity operations, e.g., <code>x + 0</code>.</p>
<h3>Why is this bad?</h3>
<p>This code can be removed without changing the
meaning. So it just obscures what’s going on. Delete it mercilessly.</p>
<h3>Example</h3>
<pre><code class="language-rust">x / 1 + 0 * 1 - 0 | 0;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+identity_op">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L500">View Source</a></div></div></div></article><article id="if_let_mutex"><input id="label-if_let_mutex" type="checkbox"><label for="label-if_let_mutex"><h2 class="lint-title"><div class="panel-title-name" id="lint-if_let_mutex">if_let_mutex
<a href="#if_let_mutex" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>Mutex::lock</code> calls in <code>if let</code> expression
with lock calls in any of the else blocks.</p>
<h3>Disabled starting in Edition 2024</h3>
<p>This lint is effectively disabled starting in
Edition 2024 as <code>if let ... else</code> scoping was reworked
such that this is no longer an issue. See
<a href="https://github.com/rust-lang/rust/issues/131154">Proposal: stabilize if_let_rescope for Edition 2024</a></p>
<h3>Why is this bad?</h3>
<p>The Mutex lock remains held for the whole
<code>if let ... else</code> block and deadlocks.</p>
<h3>Example</h3>
<pre><code class="language-rust">if let Ok(thing) = mutex.lock() {
    do_thing();
} else {
    mutex.lock();
}
</code></pre>
<p>Should be written</p>
<pre><code class="language-rust">let locked = mutex.lock();
if let Ok(thing) = locked {
    do_thing(thing);
} else {
    use_locked(locked);
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.45.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+if_let_mutex">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/if_let_mutex.rs#L12">View Source</a></div></div></div></article><article id="if_not_else"><input id="label-if_not_else" type="checkbox"><label for="label-if_not_else"><h2 class="lint-title"><div class="panel-title-name" id="lint-if_not_else">if_not_else
<a href="#if_not_else" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>!</code> or <code>!=</code> in an if condition with an
else branch.</p>
<h3>Why is this bad?</h3>
<p>Negations reduce the readability of statements.</p>
<h3>Example</h3>
<pre><code class="language-rust">if !v.is_empty() {
    a()
} else {
    b()
}
</code></pre>
<p>Could be written:</p>
<pre><code class="language-rust">if v.is_empty() {
    b()
} else {
    a()
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+if_not_else">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/if_not_else.rs#L11">View Source</a></div></div></div></article><article id="if_same_then_else"><input id="label-if_same_then_else" type="checkbox"><label for="label-if_same_then_else"><h2 class="lint-title"><div class="panel-title-name" id="lint-if_same_then_else">if_same_then_else
<a href="#if_same_then_else" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>if/else</code> with the same body as the <em>then</em> part
and the <em>else</em> part.</p>
<h3>Why is this bad?</h3>
<p>This is probably a copy &amp; paste error.</p>
<h3>Example</h3>
<pre><code class="language-rust">let foo = if … {
    42
} else {
    42
};
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+if_same_then_else">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ifs/mod.rs#L94">View Source</a></div></div></div></article><article id="if_then_some_else_none"><input id="label-if_then_some_else_none" type="checkbox"><label for="label-if_then_some_else_none"><h2 class="lint-title"><div class="panel-title-name" id="lint-if_then_some_else_none">if_then_some_else_none
<a href="#if_then_some_else_none" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for if-else that could be written using either <code>bool::then</code> or <code>bool::then_some</code>.</p>
<h3>Why restrict this?</h3>
<p>Looks a little redundant. Using <code>bool::then</code> is more concise and incurs no loss of clarity.
For simple calculations and known values, use <code>bool::then_some</code>, which is eagerly evaluated
in comparison to <code>bool::then</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = if v.is_empty() {
    println!("true!");
    Some(42)
} else {
    None
};
</code></pre>
<p>Could be written:</p>
<pre><code class="language-rust">let a = v.is_empty().then(|| {
    println!("true!");
    42
});
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.53.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+if_then_some_else_none">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/if_then_some_else_none.rs#L18">View Source</a></div></div></div></article><article id="ifs_same_cond"><input id="label-ifs_same_cond" type="checkbox"><label for="label-ifs_same_cond"><h2 class="lint-title"><div class="panel-title-name" id="lint-ifs_same_cond">ifs_same_cond
<a href="#ifs_same_cond" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for consecutive <code>if</code>s with the same condition.</p>
<h3>Why is this bad?</h3>
<p>This is probably a copy &amp; paste error.</p>
<h3>Example</h3>
<pre><code class="language-rust">if a == b {
    …
} else if a == b {
    …
}
</code></pre>
<p>Note that this lint ignores all conditions with a function call as it could
have side effects:</p>
<pre><code class="language-rust">if foo() {
    …
} else if foo() { // not linted
    …
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>ignore-interior-mutability</code>:  A list of paths to types that should be treated as if they do not contain interior mutability</p>
<p>(default: <code>["bytes::Bytes"]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ifs_same_cond">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ifs/mod.rs#L14">View Source</a></div></div></div></article><article id="ignore_without_reason"><input id="label-ignore_without_reason" type="checkbox"><label for="label-ignore_without_reason"><h2 class="lint-title"><div class="panel-title-name" id="lint-ignore_without_reason">ignore_without_reason
<a href="#ignore_without_reason" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for ignored tests without messages.</p>
<h3>Why is this bad?</h3>
<p>The reason for ignoring the test may not be obvious.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[test]
#[ignore]
fn test() {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[test]
#[ignore = "Some good reason"]
fn test() {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.88.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ignore_without_reason">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/attrs/mod.rs#L452">View Source</a></div></div></div></article><article id="ignored_unit_patterns"><input id="label-ignored_unit_patterns" type="checkbox"><label for="label-ignored_unit_patterns"><h2 class="lint-title"><div class="panel-title-name" id="lint-ignored_unit_patterns">ignored_unit_patterns
<a href="#ignored_unit_patterns" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>_</code> in patterns of type <code>()</code>.</p>
<h3>Why is this bad?</h3>
<p>Matching with <code>()</code> explicitly instead of <code>_</code> outlines
the fact that the pattern contains no data. Also it
would detect a type change that <code>_</code> would ignore.</p>
<h3>Example</h3>
<pre><code class="language-rust">match std::fs::create_dir("tmp-work-dir") {
    Ok(_) =&gt; println!("Working directory created"),
    Err(s) =&gt; eprintln!("Could not create directory: {s}"),
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">match std::fs::create_dir("tmp-work-dir") {
    Ok(()) =&gt; println!("Working directory created"),
    Err(s) =&gt; eprintln!("Could not create directory: {s}"),
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ignored_unit_patterns">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ignored_unit_patterns.rs#L8">View Source</a></div></div></div></article><article id="impl_hash_borrow_with_str_and_bytes"><input id="label-impl_hash_borrow_with_str_and_bytes" type="checkbox"><label for="label-impl_hash_borrow_with_str_and_bytes"><h2 class="lint-title"><div class="panel-title-name" id="lint-impl_hash_borrow_with_str_and_bytes">impl_hash_borrow_with_str_and_bytes
<a href="#impl_hash_borrow_with_str_and_bytes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint is concerned with the semantics of <code>Borrow</code> and <code>Hash</code> for a
type that implements all three of <code>Hash</code>, <code>Borrow&lt;str&gt;</code> and <code>Borrow&lt;[u8]&gt;</code>
as it is impossible to satisfy the semantics of Borrow and <code>Hash</code> for
both <code>Borrow&lt;str&gt;</code> and <code>Borrow&lt;[u8]&gt;</code>.</p>
<h3>Why is this bad?</h3>
<p>When providing implementations for <code>Borrow&lt;T&gt;</code>, one should consider whether the different
implementations should act as facets or representations of the underlying type. Generic code
typically uses <code>Borrow&lt;T&gt;</code> when it relies on the identical behavior of these additional trait
implementations. These traits will likely appear as additional trait bounds.</p>
<p>In particular <code>Eq</code>, <code>Ord</code> and <code>Hash</code> must be equivalent for borrowed and owned values:
<code>x.borrow() == y.borrow()</code> should give the same result as <code>x == y</code>.
It follows then that the following equivalence must hold:
<code>hash(x) == hash((x as Borrow&lt;[u8]&gt;).borrow()) == hash((x as Borrow&lt;str&gt;).borrow())</code></p>
<p>Unfortunately it doesn’t hold as <code>hash("abc") != hash("abc".as_bytes())</code>.
This happens because the <code>Hash</code> impl for str passes an additional <code>0xFF</code> byte to
the hasher to avoid collisions. For example, given the tuples <code>("a", "bc")</code>, and <code>("ab", "c")</code>,
the two tuples would have the same hash value if the <code>0xFF</code> byte was not added.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::borrow::Borrow;
use std::hash::{Hash, Hasher};

struct ExampleType {
    data: String
}

impl Hash for ExampleType {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.data.hash(state);
    }
}

impl Borrow&lt;str&gt; for ExampleType {
    fn borrow(&amp;self) -&gt; &amp;str {
        &amp;self.data
    }
}

impl Borrow&lt;[u8]&gt; for ExampleType {
    fn borrow(&amp;self) -&gt; &amp;[u8] {
        self.data.as_bytes()
    }
}
</code></pre>
<p>As a consequence, hashing a <code>&amp;ExampleType</code> and hashing the result of the two
borrows will result in different values.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.76.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+impl_hash_borrow_with_str_and_bytes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/impl_hash_with_borrow_str_and_bytes.rs#L10">View Source</a></div></div></div></article><article id="impl_trait_in_params"><input id="label-impl_trait_in_params" type="checkbox"><label for="label-impl_trait_in_params"><h2 class="lint-title"><div class="panel-title-name" id="lint-impl_trait_in_params">impl_trait_in_params
<a href="#impl_trait_in_params" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Lints when <code>impl Trait</code> is being used in a function’s parameters.</p>
<h3>Why restrict this?</h3>
<p>Turbofish syntax (<code>::&lt;&gt;</code>) cannot be used to specify the type of an <code>impl Trait</code> parameter,
making <code>impl Trait</code> less powerful. Readability may also be a factor.</p>
<h3>Example</h3>
<pre><code class="language-rust">trait MyTrait {}
fn foo(a: impl MyTrait) {
	// [...]
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">trait MyTrait {}
fn foo&lt;T: MyTrait&gt;(a: T) {
	// [...]
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.69.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+impl_trait_in_params">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/functions/mod.rs#L367">View Source</a></div></div></div></article><article id="implicit_clone"><input id="label-implicit_clone" type="checkbox"><label for="label-implicit_clone"><h2 class="lint-title"><div class="panel-title-name" id="lint-implicit_clone">implicit_clone
<a href="#implicit_clone" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the usage of <code>_.to_owned()</code>, <code>vec.to_vec()</code>, or similar when calling <code>_.clone()</code> would be clearer.</p>
<h3>Why is this bad?</h3>
<p>These methods do the same thing as <code>_.clone()</code> but may be confusing as
to why we are calling <code>to_vec</code> on something that is already a <code>Vec</code> or calling <code>to_owned</code> on something that is already owned.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = vec![1, 2, 3];
let b = a.to_vec();
let c = a.to_owned();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a = vec![1, 2, 3];
let b = a.clone();
let c = a.clone();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.52.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+implicit_clone">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2125">View Source</a></div></div></div></article><article id="implicit_hasher"><input id="label-implicit_hasher" type="checkbox"><label for="label-implicit_hasher"><h2 class="lint-title"><div class="panel-title-name" id="lint-implicit_hasher">implicit_hasher
<a href="#implicit_hasher" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for public <code>impl</code> or <code>fn</code> missing generalization
over different hashers and implicitly defaulting to the default hashing
algorithm (<code>SipHash</code>).</p>
<h3>Why is this bad?</h3>
<p><code>HashMap</code> or <code>HashSet</code> with custom hashers cannot be
used with them.</p>
<h3>Known problems</h3>
<p>Suggestions for replacing constructors can contain
false-positives. Also applying suggestions can require modification of other
pieces of code, possibly including external crates.</p>
<h3>Example</h3>
<pre><code class="language-rust">impl&lt;K: Hash + Eq, V&gt; Serialize for HashMap&lt;K, V&gt; { }

pub fn foo(map: &amp;mut HashMap&lt;i32, i32&gt;) { }
</code></pre>
<p>could be rewritten as</p>
<pre><code class="language-rust">impl&lt;K: Hash + Eq, V, S: BuildHasher&gt; Serialize for HashMap&lt;K, V, S&gt; { }

pub fn foo&lt;S: BuildHasher&gt;(map: &amp;mut HashMap&lt;i32, i32, S&gt;) { }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+implicit_hasher">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/implicit_hasher.rs#L19">View Source</a></div></div></div></article><article id="implicit_return"><input id="label-implicit_return" type="checkbox"><label for="label-implicit_return"><h2 class="lint-title"><div class="panel-title-name" id="lint-implicit_return">implicit_return
<a href="#implicit_return" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for missing return statements at the end of a block.</p>
<h3>Why restrict this?</h3>
<p>Omitting the return keyword whenever possible is idiomatic Rust code, but:</p>
<ul>
<li>Programmers coming from other languages might prefer the expressiveness of <code>return</code>.</li>
<li>It’s possible to miss the last returning statement because the only difference is a missing <code>;</code>.</li>
<li>Especially in bigger code with multiple return paths, having a <code>return</code> keyword makes it easier to find the
corresponding statements.</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(x: usize) -&gt; usize {
    x
}
</code></pre>
<p>add return</p>
<pre><code class="language-rust">fn foo(x: usize) -&gt; usize {
    return x;
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.33.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+implicit_return">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/implicit_return.rs#L14">View Source</a></div></div></div></article><article id="implicit_saturating_add"><input id="label-implicit_saturating_add" type="checkbox"><label for="label-implicit_saturating_add"><h2 class="lint-title"><div class="panel-title-name" id="lint-implicit_saturating_add">implicit_saturating_add
<a href="#implicit_saturating_add" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for implicit saturating addition.</p>
<h3>Why is this bad?</h3>
<p>The built-in function is more readable and may be faster.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut u:u32 = 7000;

if u != u32::MAX {
    u += 1;
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut u:u32 = 7000;

u = u.saturating_add(1);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.66.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+implicit_saturating_add">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/implicit_saturating_add.rs#L13">View Source</a></div></div></div></article><article id="implicit_saturating_sub"><input id="label-implicit_saturating_sub" type="checkbox"><label for="label-implicit_saturating_sub"><h2 class="lint-title"><div class="panel-title-name" id="lint-implicit_saturating_sub">implicit_saturating_sub
<a href="#implicit_saturating_sub" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for implicit saturating subtraction.</p>
<h3>Why is this bad?</h3>
<p>Simplicity and readability. Instead we can easily use an builtin function.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut i: u32 = end - start;

if i != 0 {
    i -= 1;
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut i: u32 = end - start;

i = i.saturating_sub(1);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.44.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+implicit_saturating_sub">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/implicit_saturating_sub.rs#L20">View Source</a></div></div></div></article><article id="implied_bounds_in_impls"><input id="label-implied_bounds_in_impls" type="checkbox"><label for="label-implied_bounds_in_impls"><h2 class="lint-title"><div class="panel-title-name" id="lint-implied_bounds_in_impls">implied_bounds_in_impls
<a href="#implied_bounds_in_impls" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Looks for bounds in <code>impl Trait</code> in return position that are implied by other bounds.
This can happen when a trait is specified that another trait already has as a supertrait
(e.g. <code>fn() -&gt; impl Deref + DerefMut&lt;Target = i32&gt;</code> has an unnecessary <code>Deref</code> bound,
because <code>Deref</code> is a supertrait of <code>DerefMut</code>)</p>
<h3>Why is this bad?</h3>
<p>Specifying more bounds than necessary adds needless complexity for the reader.</p>
<h3>Limitations</h3>
<p>This lint does not check for implied bounds transitively. Meaning that
it doesn’t check for implied bounds from supertraits of supertraits
(e.g. <code>trait A {} trait B: A {} trait C: B {}</code>, then having an <code>fn() -&gt; impl A + C</code>)</p>
<h3>Example</h3>
<pre><code class="language-rust">fn f() -&gt; impl Deref&lt;Target = i32&gt; + DerefMut&lt;Target = i32&gt; {
//             ^^^^^^^^^^^^^^^^^^^ unnecessary bound, already implied by the `DerefMut` trait bound
    Box::new(123)
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn f() -&gt; impl DerefMut&lt;Target = i32&gt; {
    Box::new(123)
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.74.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+implied_bounds_in_impls">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/implied_bounds_in_impls.rs#L15">View Source</a></div></div></div></article><article id="impossible_comparisons"><input id="label-impossible_comparisons" type="checkbox"><label for="label-impossible_comparisons"><h2 class="lint-title"><div class="panel-title-name" id="lint-impossible_comparisons">impossible_comparisons
<a href="#impossible_comparisons" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for double comparisons that can never succeed</p>
<h3>Why is this bad?</h3>
<p>The whole expression can be replaced by <code>false</code>,
which is probably not the programmer’s intention</p>
<h3>Example</h3>
<pre><code class="language-rust">if status_code &lt;= 400 &amp;&amp; status_code &gt; 500 {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+impossible_comparisons">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L320">View Source</a></div></div></div></article><article id="imprecise_flops"><input id="label-imprecise_flops" type="checkbox"><label for="label-imprecise_flops"><h2 class="lint-title"><div class="panel-title-name" id="lint-imprecise_flops">imprecise_flops
<a href="#imprecise_flops" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Looks for floating-point expressions that
can be expressed using built-in methods to improve accuracy
at the cost of performance.</p>
<h3>Why is this bad?</h3>
<p>Negatively impacts accuracy.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = 3f32;
let _ = a.powf(1.0 / 3.0);
let _ = (1.0 + a).ln();
let _ = a.exp() - 1.0;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a = 3f32;
let _ = a.cbrt();
let _ = a.ln_1p();
let _ = a.exp_m1();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.43.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+imprecise_flops">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/floating_point_arithmetic/mod.rs#L19">View Source</a></div></div></div></article><article id="incompatible_msrv"><input id="label-incompatible_msrv" type="checkbox"><label for="label-incompatible_msrv"><h2 class="lint-title"><div class="panel-title-name" id="lint-incompatible_msrv">incompatible_msrv
<a href="#incompatible_msrv" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint checks that no function newer than the defined MSRV (minimum
supported rust version) is used in the crate.</p>
<h3>Why is this bad?</h3>
<p>It would prevent the crate to be actually used with the specified MSRV.</p>
<h3>Example</h3>
<pre><code class="language-rust">// MSRV of 1.3.0
use std::thread::sleep;
use std::time::Duration;

// Sleep was defined in `1.4.0`.
sleep(Duration::new(1, 0));
</code></pre>
<p>To fix this problem, either increase your MSRV or use another item
available in your current MSRV.</p>
<p>You can also locally change the MSRV that should be checked by Clippy,
for example if a feature in your crate (e.g., <code>modern_compiler</code>) should
allow you to use an item:</p>
<pre><code class="language-rust">//! This crate has a MSRV of 1.3.0, but we also have an optional feature
//! `sleep_well` which requires at least Rust 1.4.0.

// When the `sleep_well` feature is set, do not warn for functions available
// in Rust 1.4.0 and below.
#![cfg_attr(feature = "sleep_well", clippy::msrv = "1.4.0")]

use std::time::Duration;

#[cfg(feature = "sleep_well")]
fn sleep_for_some_time() {
    std::thread::sleep(Duration::new(1, 0)); // Will not trigger the lint
}
</code></pre>
<p>You can also increase the MSRV in tests, by using:</p>
<pre><code class="language-rust">// Use a much higher MSRV for tests while keeping the main one low
#![cfg_attr(test, clippy::msrv = "1.85.0")]

#[test]
fn my_test() {
    // The tests can use items introduced in Rust 1.85.0 and lower
    // without triggering the `incompatible_msrv` lint.
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>check-incompatible-msrv-in-tests</code>:  Whether to check MSRV compatibility in <code>#[test]</code> and <code>#[cfg(test)]</code> code.</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.78.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+incompatible_msrv">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/incompatible_msrv.rs#L14">View Source</a></div></div></div></article><article id="inconsistent_digit_grouping"><input id="label-inconsistent_digit_grouping" type="checkbox"><label for="label-inconsistent_digit_grouping"><h2 class="lint-title"><div class="panel-title-name" id="lint-inconsistent_digit_grouping">inconsistent_digit_grouping
<a href="#inconsistent_digit_grouping" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns if an integral or floating-point constant is
grouped inconsistently with underscores.</p>
<h3>Why is this bad?</h3>
<p>Readers may incorrectly interpret inconsistently
grouped digits.</p>
<h3>Example</h3>
<pre><code class="language-rust">618_64_9189_73_511
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">61_864_918_973_511
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+inconsistent_digit_grouping">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/literal_representation.rs#L62">View Source</a></div></div></div></article><article id="inconsistent_struct_constructor"><input id="label-inconsistent_struct_constructor" type="checkbox"><label for="label-inconsistent_struct_constructor"><h2 class="lint-title"><div class="panel-title-name" id="lint-inconsistent_struct_constructor">inconsistent_struct_constructor
<a href="#inconsistent_struct_constructor" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for struct constructors where the order of the field
init in the constructor is inconsistent with the order in the
struct definition.</p>
<h3>Why is this bad?</h3>
<p>Since the order of fields in a constructor doesn’t affect the
resulted instance as the below example indicates,</p>
<pre><code class="language-rust">#[derive(Debug, PartialEq, Eq)]
struct Foo {
    x: i32,
    y: i32,
}
let x = 1;
let y = 2;

// This assertion never fails:
assert_eq!(Foo { x, y }, Foo { y, x });
</code></pre>
<p>inconsistent order can be confusing and decreases readability and consistency.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Foo {
    x: i32,
    y: i32,
}
let x = 1;
let y = 2;

Foo { y, x };
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">Foo { x, y };
</code></pre>
<h3>Configuration</h3>
<ul>
<li><code>check-inconsistent-struct-field-initializers</code>:  Whether to suggest reordering constructor fields when initializers are present.</li>
</ul>
<p>Warnings produced by this configuration aren’t necessarily fixed by just reordering the fields. Even if the
suggested code would compile, it can change semantics if the initializer expressions have side effects. The
following example <a href="https://github.com/rust-lang/rust-clippy/issues/11846#issuecomment-1820747924">from rust-clippy#11846</a> shows how the suggestion can run into borrow check errors:</p>
<pre><code class="language-rust">struct MyStruct {
    vector: Vec&lt;u32&gt;,
    length: usize
}
fn main() {
    let vector = vec![1,2,3];
    MyStruct { length: vector.len(), vector};
}
</code></pre>
<p>(default: <code>false</code>)</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.52.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+inconsistent_struct_constructor">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/inconsistent_struct_constructor.rs#L14">View Source</a></div></div></div></article><article id="index_refutable_slice"><input id="label-index_refutable_slice" type="checkbox"><label for="label-index_refutable_slice"><h2 class="lint-title"><div class="panel-title-name" id="lint-index_refutable_slice">index_refutable_slice
<a href="#index_refutable_slice" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>The lint checks for slice bindings in patterns that are only used to
access individual slice values.</p>
<h3>Why is this bad?</h3>
<p>Accessing slice values using indices can lead to panics. Using refutable
patterns can avoid these. Binding to individual values also improves the
readability as they can be named.</p>
<h3>Limitations</h3>
<p>This lint currently only checks for immutable access inside <code>if let</code>
patterns.</p>
<h3>Example</h3>
<pre><code class="language-rust">let slice: Option&lt;&amp;[u32]&gt; = Some(&amp;[1, 2, 3]);

if let Some(slice) = slice {
    println!("{}", slice[0]);
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let slice: Option&lt;&amp;[u32]&gt; = Some(&amp;[1, 2, 3]);

if let Some(&amp;[first, ..]) = slice {
    println!("{}", first);
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>max-suggested-slice-pattern-length</code>:  When Clippy suggests using a slice pattern, this is the maximum number of elements allowed in
the slice pattern that is suggested. If more elements are necessary, the lint is suppressed.
For example, <code>[_, _, _, e, ..]</code> is a slice pattern with 4 elements.</p>
<p>(default: <code>3</code>)</p>
</li>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.59.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+index_refutable_slice">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/index_refutable_slice.rs#L20">View Source</a></div></div></div></article><article id="indexing_slicing"><input id="label-indexing_slicing" type="checkbox"><label for="label-indexing_slicing"><h2 class="lint-title"><div class="panel-title-name" id="lint-indexing_slicing">indexing_slicing
<a href="#indexing_slicing" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of indexing or slicing that may panic at runtime.</p>
<p>This lint does not report on indexing or slicing operations
that always panic, clippy’s <code>out_of_bound_indexing</code> already
handles those cases.</p>
<h3>Why restrict this?</h3>
<p>To avoid implicit panics from indexing and slicing.</p>
<p>There are “checked” alternatives which do not panic, and can be used with <code>unwrap()</code> to make
an explicit panic when it is desired.</p>
<h3>Limitations</h3>
<p>This lint does not check for the usage of indexing or slicing on strings. These are covered
by the more specific <code>string_slice</code> lint.</p>
<h3>Example</h3>
<pre><code class="language-rust">// Vector
let x = vec![0, 1, 2, 3];

x[2];
x[100];
&amp;x[2..100];

// Array
let y = [0, 1, 2, 3];

let i = 10; // Could be a runtime value
let j = 20;
&amp;y[i..j];
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">x.get(2);
x.get(100);
x.get(2..100);

let i = 10;
let j = 20;
y.get(i..j);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allow-indexing-slicing-in-tests</code>:  Whether <code>indexing_slicing</code> should be allowed in test functions or <code>#[cfg(test)]</code></p>
<p>(default: <code>false</code>)</p>
</li>
<li>
<p><code>suppress-restriction-lint-in-const</code>:  Whether to suppress a restriction lint in constant code. In same
cases the restructured operation might not be unavoidable, as the
suggested counterparts are unavailable in constant code. This
configuration will cause restriction lints to trigger even
if no suggestion can be made.</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+indexing_slicing">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/indexing_slicing.rs#L42">View Source</a></div></div></div></article><article id="ineffective_bit_mask"><input id="label-ineffective_bit_mask" type="checkbox"><label for="label-ineffective_bit_mask"><h2 class="lint-title"><div class="panel-title-name" id="lint-ineffective_bit_mask">ineffective_bit_mask
<a href="#ineffective_bit_mask" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for bit masks in comparisons which can be removed
without changing the outcome. The basic structure can be seen in the
following table:</p>
<table class="table"><thead><tr><th>Comparison</th><th>Bit Op</th><th>Example</th><th>equals</th></tr></thead><tbody>
<tr><td><code>&gt;</code> / <code>&lt;=</code></td><td><code>|</code> / <code>^</code></td><td><code>x | 2 &gt; 3</code></td><td><code>x &gt; 3</code></td></tr>
<tr><td><code>&lt;</code> / <code>&gt;=</code></td><td><code>|</code> / <code>^</code></td><td><code>x ^ 1 &lt; 4</code></td><td><code>x &lt; 4</code></td></tr>
</tbody></table>
<h3>Why is this bad?</h3>
<p>Not equally evil as <a href="#bad_bit_mask"><code>bad_bit_mask</code></a>,
but still a bit misleading, because the bit mask is ineffective.</p>
<h3>Known problems</h3>
<p>False negatives: This lint will only match instances
where we have figured out the math (which is for a power-of-two compared
value). This means things like <code>x | 1 &gt;= 7</code> (which would be better written
as <code>x &gt;= 6</code>) will not be reported (but bit masks like this are fairly
uncommon).</p>
<h3>Example</h3>
<pre><code class="language-rust">if (x | 1 &gt; 3) {  }
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if (x &gt;= 2) {  }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ineffective_bit_mask">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L225">View Source</a></div></div></div></article><article id="ineffective_open_options"><input id="label-ineffective_open_options" type="checkbox"><label for="label-ineffective_open_options"><h2 class="lint-title"><div class="panel-title-name" id="lint-ineffective_open_options">ineffective_open_options
<a href="#ineffective_open_options" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks if both <code>.write(true)</code> and <code>.append(true)</code> methods are called
on a same <code>OpenOptions</code>.</p>
<h3>Why is this bad?</h3>
<p><code>.append(true)</code> already enables <code>write(true)</code>, making this one
superfluous.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = OpenOptions::new()
           .write(true)
           .append(true)
           .create(true)
           .open("file.json");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = OpenOptions::new()
           .append(true)
           .create(true)
           .open("file.json");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.76.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ineffective_open_options">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ineffective_open_options.rs#L11">View Source</a></div></div></div></article><article id="inefficient_to_string"><input id="label-inefficient_to_string" type="checkbox"><label for="label-inefficient_to_string"><h2 class="lint-title"><div class="panel-title-name" id="lint-inefficient_to_string">inefficient_to_string
<a href="#inefficient_to_string" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.to_string()</code> on an <code>&amp;&amp;T</code> where
<code>T</code> implements <code>ToString</code> directly (like <code>&amp;&amp;str</code> or <code>&amp;&amp;String</code>).</p>
<h3>Why is this bad?</h3>
<p>In versions of the compiler before Rust 1.82.0, this bypasses the specialized
implementation of <code>ToString</code> and instead goes through the more expensive string
formatting facilities.</p>
<h3>Example</h3>
<pre><code class="language-rust">// Generic implementation for `T: Display` is used (slow)
["foo", "bar"].iter().map(|s| s.to_string());

// OK, the specialized impl is used
["foo", "bar"].iter().map(|&amp;s| s.to_string());
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.40.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+inefficient_to_string">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1080">View Source</a></div></div></div></article><article id="infallible_destructuring_match"><input id="label-infallible_destructuring_match" type="checkbox"><label for="label-infallible_destructuring_match"><h2 class="lint-title"><div class="panel-title-name" id="lint-infallible_destructuring_match">infallible_destructuring_match
<a href="#infallible_destructuring_match" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for matches being used to destructure a single-variant enum
or tuple struct where a <code>let</code> will suffice.</p>
<h3>Why is this bad?</h3>
<p>Just readability – <code>let</code> doesn’t nest, whereas a <code>match</code> does.</p>
<h3>Example</h3>
<pre><code class="language-rust">enum Wrapper {
    Data(i32),
}

let wrapper = Wrapper::Data(42);

let data = match wrapper {
    Wrapper::Data(i) =&gt; i,
};
</code></pre>
<p>The correct use would be:</p>
<pre><code class="language-rust">enum Wrapper {
    Data(i32),
}

let wrapper = Wrapper::Data(42);
let Wrapper::Data(data) = wrapper;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+infallible_destructuring_match">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L366">View Source</a></div></div></div></article><article id="infallible_try_from"><input id="label-infallible_try_from" type="checkbox"><label for="label-infallible_try_from"><h2 class="lint-title"><div class="panel-title-name" id="lint-infallible_try_from">infallible_try_from
<a href="#infallible_try_from" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Finds manual impls of <code>TryFrom</code> with infallible error types.</p>
<h3>Why is this bad?</h3>
<p>Infallible conversions should be implemented via <code>From</code> with the blanket conversion.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::convert::Infallible;
struct MyStruct(i16);
impl TryFrom&lt;i16&gt; for MyStruct {
    type Error = Infallible;
    fn try_from(other: i16) -&gt; Result&lt;Self, Infallible&gt; {
        Ok(Self(other.into()))
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct MyStruct(i16);
impl From&lt;i16&gt; for MyStruct {
    fn from(other: i16) -&gt; Self {
        Self(other)
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.89.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+infallible_try_from">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/infallible_try_from.rs#L9">View Source</a></div></div></div></article><article id="infinite_iter"><input id="label-infinite_iter" type="checkbox"><label for="label-infinite_iter"><h2 class="lint-title"><div class="panel-title-name" id="lint-infinite_iter">infinite_iter
<a href="#infinite_iter" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for iteration that is guaranteed to be infinite.</p>
<h3>Why is this bad?</h3>
<p>While there may be places where this is acceptable
(e.g., in event streams), in most cases this is simply an error.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::iter;

iter::repeat(1_u8).collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+infinite_iter">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/infinite_iter.rs#L10">View Source</a></div></div></div></article><article id="infinite_loop"><input id="label-infinite_loop" type="checkbox"><label for="label-infinite_loop"><h2 class="lint-title"><div class="panel-title-name" id="lint-infinite_loop">infinite_loop
<a href="#infinite_loop" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for infinite loops in a function where the return type is not <code>!</code>
and lint accordingly.</p>
<h3>Why restrict this?</h3>
<p>Making the return type <code>!</code> serves as documentation that the function does not return.
If the function is not intended to loop infinitely, then this lint may detect a bug.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn run_forever() {
    loop {
        // do something
    }
}
</code></pre>
<p>If infinite loops are as intended:</p>
<pre><code class="language-rust">fn run_forever() -&gt; ! {
    loop {
        // do something
    }
}
</code></pre>
<p>Otherwise add a <code>break</code> or <code>return</code> condition:</p>
<pre><code class="language-rust">fn run_forever() {
    loop {
        // do something
        if condition {
            break;
        }
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.76.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+infinite_loop">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L678">View Source</a></div></div></div></article><article id="inherent_to_string"><input id="label-inherent_to_string" type="checkbox"><label for="label-inherent_to_string"><h2 class="lint-title"><div class="panel-title-name" id="lint-inherent_to_string">inherent_to_string
<a href="#inherent_to_string" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the definition of inherent methods with a signature of <code>to_string(&amp;self) -&gt; String</code>.</p>
<h3>Why is this bad?</h3>
<p>This method is also implicitly defined if a type implements the <code>Display</code> trait. As the functionality of <code>Display</code> is much more versatile, it should be preferred.</p>
<h3>Example</h3>
<pre><code class="language-rust">pub struct A;

impl A {
    pub fn to_string(&amp;self) -&gt; String {
        "I am A".to_string()
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::fmt;

pub struct A;

impl fmt::Display for A {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "I am A")
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.38.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+inherent_to_string">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/inherent_to_string.rs#L11">View Source</a></div></div></div></article><article id="inherent_to_string_shadow_display"><input id="label-inherent_to_string_shadow_display" type="checkbox"><label for="label-inherent_to_string_shadow_display"><h2 class="lint-title"><div class="panel-title-name" id="lint-inherent_to_string_shadow_display">inherent_to_string_shadow_display
<a href="#inherent_to_string_shadow_display" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the definition of inherent methods with a signature of <code>to_string(&amp;self) -&gt; String</code> and if the type implementing this method also implements the <code>Display</code> trait.</p>
<h3>Why is this bad?</h3>
<p>This method is also implicitly defined if a type implements the <code>Display</code> trait. The less versatile inherent method will then shadow the implementation introduced by <code>Display</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::fmt;

pub struct A;

impl A {
    pub fn to_string(&amp;self) -&gt; String {
        "I am A".to_string()
    }
}

impl fmt::Display for A {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "I am A, too")
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::fmt;

pub struct A;

impl fmt::Display for A {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "I am A")
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.38.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+inherent_to_string_shadow_display">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/inherent_to_string.rs#L47">View Source</a></div></div></div></article><article id="init_numbered_fields"><input id="label-init_numbered_fields" type="checkbox"><label for="label-init_numbered_fields"><h2 class="lint-title"><div class="panel-title-name" id="lint-init_numbered_fields">init_numbered_fields
<a href="#init_numbered_fields" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for tuple structs initialized with field syntax.
It will however not lint if a base initializer is present.
The lint will also ignore code in macros.</p>
<h3>Why is this bad?</h3>
<p>This may be confusing to the uninitiated and adds no
benefit as opposed to tuple initializers</p>
<h3>Example</h3>
<pre><code class="language-rust">struct TupleStruct(u8, u16);

let _ = TupleStruct {
    0: 1,
    1: 23,
};

// should be written as
let base = TupleStruct(1, 23);

// This is OK however
let _ = TupleStruct { 0: 42, ..base };
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.59.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+init_numbered_fields">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/init_numbered_fields.rs#L11">View Source</a></div></div></div></article><article id="inline_always"><input id="label-inline_always" type="checkbox"><label for="label-inline_always"><h2 class="lint-title"><div class="panel-title-name" id="lint-inline_always">inline_always
<a href="#inline_always" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for items annotated with <code>#[inline(always)]</code>,
unless the annotated function is empty or simply panics.</p>
<h3>Why is this bad?</h3>
<p>While there are valid uses of this annotation (and once
you know when to use it, by all means <code>allow</code> this lint), it’s a common
newbie-mistake to pepper one’s code with it.</p>
<p>As a rule of thumb, before slapping <code>#[inline(always)]</code> on a function,
measure if that additional function call really affects your runtime profile
sufficiently to make up for the increase in compile time.</p>
<h3>Known problems</h3>
<p>False positives, big time. This lint is meant to be
deactivated by everyone doing serious performance work. This means having
done the measurement.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[inline(always)]
fn not_quite_hot_code(..) { ... }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+inline_always">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/attrs/mod.rs#L26">View Source</a></div></div></div></article><article id="inline_asm_x86_att_syntax"><input id="label-inline_asm_x86_att_syntax" type="checkbox"><label for="label-inline_asm_x86_att_syntax"><h2 class="lint-title"><div class="panel-title-name" id="lint-inline_asm_x86_att_syntax">inline_asm_x86_att_syntax
<a href="#inline_asm_x86_att_syntax" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of AT&amp;T x86 assembly syntax.</p>
<h3>Why restrict this?</h3>
<p>To enforce consistent use of Intel x86 assembly syntax.</p>
<h3>Example</h3>
<pre><code class="language-rust">asm!("lea ({}), {}", in(reg) ptr, lateout(reg) _, options(att_syntax));
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">asm!("lea {}, [{}]", lateout(reg) _, in(reg) ptr);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+inline_asm_x86_att_syntax">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/asm_syntax.rs#L108">View Source</a></div></div></div></article><article id="inline_asm_x86_intel_syntax"><input id="label-inline_asm_x86_intel_syntax" type="checkbox"><label for="label-inline_asm_x86_intel_syntax"><h2 class="lint-title"><div class="panel-title-name" id="lint-inline_asm_x86_intel_syntax">inline_asm_x86_intel_syntax
<a href="#inline_asm_x86_intel_syntax" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of Intel x86 assembly syntax.</p>
<h3>Why restrict this?</h3>
<p>To enforce consistent use of AT&amp;T x86 assembly syntax.</p>
<h3>Example</h3>
<pre><code class="language-rust">asm!("lea {}, [{}]", lateout(reg) _, in(reg) ptr);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">asm!("lea ({}), {}", in(reg) ptr, lateout(reg) _, options(att_syntax));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+inline_asm_x86_intel_syntax">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/asm_syntax.rs#L60">View Source</a></div></div></div></article><article id="inline_fn_without_body"><input id="label-inline_fn_without_body" type="checkbox"><label for="label-inline_fn_without_body"><h2 class="lint-title"><div class="panel-title-name" id="lint-inline_fn_without_body">inline_fn_without_body
<a href="#inline_fn_without_body" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>#[inline]</code> on trait methods without bodies</p>
<h3>Why is this bad?</h3>
<p>Only implementations of trait methods may be inlined.
The inline attribute is ignored for trait methods without bodies.</p>
<h3>Example</h3>
<pre><code class="language-rust">trait Animal {
    #[inline]
    fn name(&amp;self) -&gt; &amp;'static str;
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+inline_fn_without_body">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/inline_fn_without_body.rs#L9">View Source</a></div></div></div></article><article id="inspect_for_each"><input id="label-inspect_for_each" type="checkbox"><label for="label-inspect_for_each"><h2 class="lint-title"><div class="panel-title-name" id="lint-inspect_for_each">inspect_for_each
<a href="#inspect_for_each" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>inspect().for_each()</code>.</p>
<h3>Why is this bad?</h3>
<p>It is the same as performing the computation
inside <code>inspect</code> at the beginning of the closure in <code>for_each</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">[1,2,3,4,5].iter()
.inspect(|&amp;x| println!("inspect the number: {}", x))
.for_each(|&amp;x| {
    assert!(x &gt;= 0);
});
</code></pre>
<p>Can be written as</p>
<pre><code class="language-rust">[1,2,3,4,5].iter()
.for_each(|&amp;x| {
    println!("inspect the number: {}", x);
    assert!(x &gt;= 0);
});
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.51.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+inspect_for_each">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2026">View Source</a></div></div></div></article><article id="int_plus_one"><input id="label-int_plus_one" type="checkbox"><label for="label-int_plus_one"><h2 class="lint-title"><div class="panel-title-name" id="lint-int_plus_one">int_plus_one
<a href="#int_plus_one" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>x &gt;= y + 1</code> or <code>x - 1 &gt;= y</code> (and <code>&lt;=</code>) in a block</p>
<h3>Why is this bad?</h3>
<p>Readability – better to use <code>&gt; y</code> instead of <code>&gt;= y + 1</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">if x &gt;= y + 1 {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if x &gt; y {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+int_plus_one">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/int_plus_one.rs#L9">View Source</a></div></div></div></article><article id="integer_division"><input id="label-integer_division" type="checkbox"><label for="label-integer_division"><h2 class="lint-title"><div class="panel-title-name" id="lint-integer_division">integer_division
<a href="#integer_division" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for division of integers</p>
<h3>Why restrict this?</h3>
<p>When outside of some very specific algorithms,
integer division is very often a mistake because it discards the
remainder.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = 3 / 2;
println!("{}", x);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = 3f32 / 2f32;
println!("{}", x);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.37.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+integer_division">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L519">View Source</a></div></div></div></article><article id="integer_division_remainder_used"><input id="label-integer_division_remainder_used" type="checkbox"><label for="label-integer_division_remainder_used"><h2 class="lint-title"><div class="panel-title-name" id="lint-integer_division_remainder_used">integer_division_remainder_used
<a href="#integer_division_remainder_used" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the usage of division (<code>/</code>) and remainder (<code>%</code>) operations
when performed on any integer types using the default <code>Div</code> and <code>Rem</code> trait implementations.</p>
<h3>Why restrict this?</h3>
<p>In cryptographic contexts, division can result in timing sidechannel vulnerabilities,
and needs to be replaced with constant-time code instead (e.g. Barrett reduction).</p>
<h3>Example</h3>
<pre><code class="language-rust">let my_div = 10 / 2;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let my_div = 10 &gt;&gt; 1;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.79.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+integer_division_remainder_used">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L916">View Source</a></div></div></div></article><article id="into_iter_on_ref"><input id="label-into_iter_on_ref" type="checkbox"><label for="label-into_iter_on_ref"><h2 class="lint-title"><div class="panel-title-name" id="lint-into_iter_on_ref">into_iter_on_ref
<a href="#into_iter_on_ref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>into_iter</code> calls on references which should be replaced by <code>iter</code>
or <code>iter_mut</code>.</p>
<h3>Why is this bad?</h3>
<p>Readability. Calling <code>into_iter</code> on a reference will not move out its
content into the resulting iterator, which is confusing. It is better just call <code>iter</code> or
<code>iter_mut</code> directly.</p>
<h3>Example</h3>
<pre><code class="language-rust">(&amp;vec).into_iter();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">(&amp;vec).iter();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.32.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+into_iter_on_ref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1603">View Source</a></div></div></div></article><article id="into_iter_without_iter"><input id="label-into_iter_without_iter" type="checkbox"><label for="label-into_iter_without_iter"><h2 class="lint-title"><div class="panel-title-name" id="lint-into_iter_without_iter">into_iter_without_iter
<a href="#into_iter_without_iter" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This is the opposite of the <code>iter_without_into_iter</code> lint.
It looks for <code>IntoIterator for (&amp;|&amp;mut) Type</code> implementations without an inherent <code>iter</code> or <code>iter_mut</code> method
on the type or on any of the types in its <code>Deref</code> chain.</p>
<h3>Why is this bad?</h3>
<p>It’s not bad, but having them is idiomatic and allows the type to be used in iterator chains
by just calling <code>.iter()</code>, instead of the more awkward <code>&lt;&amp;Type&gt;::into_iter</code> or <code>(&amp;val).into_iter()</code> syntax
in case of ambiguity with another <code>IntoIterator</code> impl.</p>
<h3>Limitations</h3>
<p>This lint focuses on providing an idiomatic API. Therefore, it will only
lint on types which are accessible outside of the crate. For internal types,
these methods can be added on demand if they are actually needed. Otherwise,
it would trigger the <a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#dead-code"><code>dead_code</code></a> lint for the unused method.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct MySlice&lt;'a&gt;(&amp;'a [u8]);
impl&lt;'a&gt; IntoIterator for &amp;MySlice&lt;'a&gt; {
    type Item = &amp;'a u8;
    type IntoIter = std::slice::Iter&lt;'a, u8&gt;;
    fn into_iter(self) -&gt; Self::IntoIter {
        self.0.iter()
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct MySlice&lt;'a&gt;(&amp;'a [u8]);
impl&lt;'a&gt; MySlice&lt;'a&gt; {
    pub fn iter(&amp;self) -&gt; std::slice::Iter&lt;'a, u8&gt; {
        self.into_iter()
    }
}
impl&lt;'a&gt; IntoIterator for &amp;MySlice&lt;'a&gt; {
    type Item = &amp;'a u8;
    type IntoIter = std::slice::Iter&lt;'a, u8&gt;;
    fn into_iter(self) -&gt; Self::IntoIter {
        self.0.iter()
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.75.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+into_iter_without_iter">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/iter_without_into_iter.rs#L56">View Source</a></div></div></div></article><article id="invalid_regex"><input id="label-invalid_regex" type="checkbox"><label for="label-invalid_regex"><h2 class="lint-title"><div class="panel-title-name" id="lint-invalid_regex">invalid_regex
<a href="#invalid_regex" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks <a href="https://crates.io/crates/regex">regex</a> creation
(with <code>Regex::new</code>, <code>RegexBuilder::new</code>, or <code>RegexSet::new</code>) for correct
regex syntax.</p>
<h3>Why is this bad?</h3>
<p>This will lead to a runtime panic.</p>
<h3>Example</h3>
<pre><code class="language-rust">Regex::new("(")
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">Regex::new("\(")
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+invalid_regex">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/regex.rs#L16">View Source</a></div></div></div></article><article id="invalid_upcast_comparisons"><input id="label-invalid_upcast_comparisons" type="checkbox"><label for="label-invalid_upcast_comparisons"><h2 class="lint-title"><div class="panel-title-name" id="lint-invalid_upcast_comparisons">invalid_upcast_comparisons
<a href="#invalid_upcast_comparisons" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for comparisons where the relation is always either
true or false, but where one side has been upcast so that the comparison is
necessary. Only integer types are checked.</p>
<h3>Why is this bad?</h3>
<p>An expression like <code>let x : u8 = ...; (x as u32) &gt; 300</code>
will mistakenly imply that it is possible for <code>x</code> to be outside the range of
<code>u8</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: u8 = 1;
(x as u32) &gt; 300;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+invalid_upcast_comparisons">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L894">View Source</a></div></div></div></article><article id="inverted_saturating_sub"><input id="label-inverted_saturating_sub" type="checkbox"><label for="label-inverted_saturating_sub"><h2 class="lint-title"><div class="panel-title-name" id="lint-inverted_saturating_sub">inverted_saturating_sub
<a href="#inverted_saturating_sub" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for comparisons between integers, followed by subtracting the greater value from the
lower one.</p>
<h3>Why is this bad?</h3>
<p>This could result in an underflow and is most likely not what the user wants. If this was
intended to be a saturated subtraction, consider using the <code>saturating_sub</code> method directly.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = 12u32;
let b = 13u32;

let result = if a &gt; b { b - a } else { 0 };
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a = 12u32;
let b = 13u32;

let result = a.saturating_sub(b);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.83.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+inverted_saturating_sub">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/implicit_saturating_sub.rs#L52">View Source</a></div></div></div></article><article id="invisible_characters"><input id="label-invisible_characters" type="checkbox"><label for="label-invisible_characters"><h2 class="lint-title"><div class="panel-title-name" id="lint-invisible_characters">invisible_characters
<a href="#invisible_characters" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for invisible Unicode characters in the code.</p>
<h3>Why is this bad?</h3>
<p>Having an invisible character in the code makes for all
sorts of April fools, but otherwise is very much frowned upon.</p>
<h3>Example</h3>
<p>You don’t see it, but there may be a zero-width space or soft hyphen
some­where in this text.</p>
<h3>Past names</h3>
<ul>
<li>zero_width_space</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+invisible_characters">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unicode.rs#L13">View Source</a></div></div></div></article><article id="io_other_error"><input id="label-io_other_error" type="checkbox"><label for="label-io_other_error"><h2 class="lint-title"><div class="panel-title-name" id="lint-io_other_error">io_other_error
<a href="#io_other_error" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><p>This lint warns on calling <code>io::Error::new(..)</code> with a kind of
<code>io::ErrorKind::Other</code>.</p>
<h3>Why is this bad?</h3>
<p>Since Rust 1.74, there’s the <code>io::Error::other(_)</code> shortcut.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::io;
let _ = io::Error::new(io::ErrorKind::Other, "bad".to_string());
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = std::io::Error::other("bad".to_string());
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.87.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+io_other_error">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4549">View Source</a></div></div></div></article><article id="ip_constant"><input id="label-ip_constant" type="checkbox"><label for="label-ip_constant"><h2 class="lint-title"><div class="panel-title-name" id="lint-ip_constant">ip_constant
<a href="#ip_constant" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for IP addresses that could be replaced with predefined constants such as
<code>Ipv4Addr::new(127, 0, 0, 1)</code> instead of using the appropriate constants.</p>
<h3>Why is this bad?</h3>
<p>Using specific IP addresses like <code>127.0.0.1</code> or <code>::1</code> is less clear and less maintainable than using the
predefined constants <code>Ipv4Addr::LOCALHOST</code> or <code>Ipv6Addr::LOCALHOST</code>. These constants improve code
readability, make the intent explicit, and are less error-prone.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::net::{Ipv4Addr, Ipv6Addr};

// IPv4 loopback
let addr_v4 = Ipv4Addr::new(127, 0, 0, 1);

// IPv6 loopback
let addr_v6 = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::net::{Ipv4Addr, Ipv6Addr};

// IPv4 loopback
let addr_v4 = Ipv4Addr::LOCALHOST;

// IPv6 loopback
let addr_v6 = Ipv6Addr::LOCALHOST;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.89.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ip_constant">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4618">View Source</a></div></div></div></article><article id="is_digit_ascii_radix"><input id="label-is_digit_ascii_radix" type="checkbox"><label for="label-is_digit_ascii_radix"><h2 class="lint-title"><div class="panel-title-name" id="lint-is_digit_ascii_radix">is_digit_ascii_radix
<a href="#is_digit_ascii_radix" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Finds usages of <a href="https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_digit"><code>char::is_digit</code></a> that
can be replaced with <a href="https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_ascii_digit"><code>is_ascii_digit</code></a> or
<a href="https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_ascii_hexdigit"><code>is_ascii_hexdigit</code></a>.</p>
<h3>Why is this bad?</h3>
<p><code>is_digit(..)</code> is slower and requires specifying the radix.</p>
<h3>Example</h3>
<pre><code class="language-rust">let c: char = '6';
c.is_digit(10);
c.is_digit(16);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let c: char = '6';
c.is_ascii_digit();
c.is_ascii_hexdigit();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+is_digit_ascii_radix">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2428">View Source</a></div></div></div></article><article id="items_after_statements"><input id="label-items_after_statements" type="checkbox"><label for="label-items_after_statements"><h2 class="lint-title"><div class="panel-title-name" id="lint-items_after_statements">items_after_statements
<a href="#items_after_statements" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for items declared after some statement in a block.</p>
<h3>Why is this bad?</h3>
<p>Items live for the entire scope they are declared
in. But statements are processed in order. This might cause confusion as
it’s hard to figure out which item is meant in a statement.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo() {
    println!("cake");
}

fn main() {
    foo(); // prints "foo"
    fn foo() {
        println!("foo");
    }
    foo(); // prints "foo"
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo() {
    println!("cake");
}

fn main() {
    fn foo() {
        println!("foo");
    }
    foo(); // prints "foo"
    foo(); // prints "foo"
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+items_after_statements">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/items_after_statements.rs#L6">View Source</a></div></div></div></article><article id="items_after_test_module"><input id="label-items_after_test_module" type="checkbox"><label for="label-items_after_test_module"><h2 class="lint-title"><div class="panel-title-name" id="lint-items_after_test_module">items_after_test_module
<a href="#items_after_test_module" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Triggers if an item is declared after the testing module marked with <code>#[cfg(test)]</code>.</p>
<h3>Why is this bad?</h3>
<p>Having items declared after the testing module is confusing and may lead to bad test coverage.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    // [...]
}

fn my_function() {
    // [...]
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn my_function() {
    // [...]
}

#[cfg(test)]
mod tests {
    // [...]
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.71.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+items_after_test_module">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/items_after_test_module.rs#L11">View Source</a></div></div></div></article><article id="iter_cloned_collect"><input id="label-iter_cloned_collect" type="checkbox"><label for="label-iter_cloned_collect"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_cloned_collect">iter_cloned_collect
<a href="#iter_cloned_collect" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the use of <code>.cloned().collect()</code> on slice to
create a <code>Vec</code>.</p>
<h3>Why is this bad?</h3>
<p><code>.to_vec()</code> is clearer</p>
<h3>Example</h3>
<pre><code class="language-rust">let s = [1, 2, 3, 4, 5];
let s2: Vec&lt;isize&gt; = s[..].iter().cloned().collect();
</code></pre>
<p>The better use would be:</p>
<pre><code class="language-rust">let s = [1, 2, 3, 4, 5];
let s2: Vec&lt;isize&gt; = s.to_vec();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_cloned_collect">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1443">View Source</a></div></div></div></article><article id="iter_count"><input id="label-iter_count" type="checkbox"><label for="label-iter_count"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_count">iter_count
<a href="#iter_count" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the use of <code>.iter().count()</code>.</p>
<h3>Why is this bad?</h3>
<p><code>.len()</code> is more efficient and more
readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">let some_vec = vec![0, 1, 2, 3];

some_vec.iter().count();
&amp;some_vec[..].iter().count();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let some_vec = vec![0, 1, 2, 3];

some_vec.len();
&amp;some_vec[..].len();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.52.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_count">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2151">View Source</a></div></div></div></article><article id="iter_filter_is_ok"><input id="label-iter_filter_is_ok" type="checkbox"><label for="label-iter_filter_is_ok"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_filter_is_ok">iter_filter_is_ok
<a href="#iter_filter_is_ok" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.filter(Result::is_ok)</code> that may be replaced with a <code>.flatten()</code> call.
This lint will require additional changes to the follow-up calls as it affects the type.</p>
<h3>Why is this bad?</h3>
<p>This pattern is often followed by manual unwrapping of <code>Result</code>. The simplification
results in more readable and succinct code without the need for manual unwrapping.</p>
<h3>Example</h3>
<pre><code class="language-rust">vec![Ok::&lt;i32, String&gt;(1)].into_iter().filter(Result::is_ok);

</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">vec![Ok::&lt;i32, String&gt;(1)].into_iter().flatten();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.77.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_filter_is_ok">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3910">View Source</a></div></div></div></article><article id="iter_filter_is_some"><input id="label-iter_filter_is_some" type="checkbox"><label for="label-iter_filter_is_some"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_filter_is_some">iter_filter_is_some
<a href="#iter_filter_is_some" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.filter(Option::is_some)</code> that may be replaced with a <code>.flatten()</code> call.
This lint will require additional changes to the follow-up calls as it affects the type.</p>
<h3>Why is this bad?</h3>
<p>This pattern is often followed by manual unwrapping of the <code>Option</code>. The simplification
results in more readable and succinct code without the need for manual unwrapping.</p>
<h3>Example</h3>
<pre><code class="language-rust">vec![Some(1)].into_iter().filter(Option::is_some);

</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">vec![Some(1)].into_iter().flatten();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.77.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_filter_is_some">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3886">View Source</a></div></div></div></article><article id="iter_kv_map"><input id="label-iter_kv_map" type="checkbox"><label for="label-iter_kv_map"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_kv_map">iter_kv_map
<a href="#iter_kv_map" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for iterating a map (<code>HashMap</code> or <code>BTreeMap</code>) and
ignoring either the keys or values.</p>
<h3>Why is this bad?</h3>
<p>Readability. There are <code>keys</code> and <code>values</code> methods that
can be used to express that we only need the keys or the values.</p>
<h3>Example</h3>
<pre><code class="language-rust">let map: HashMap&lt;u32, u32&gt; = HashMap::new();
let values = map.iter().map(|(_, value)| value).collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let map: HashMap&lt;u32, u32&gt; = HashMap::new();
let values = map.values().collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.66.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_kv_map">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3239">View Source</a></div></div></div></article><article id="iter_next_loop"><input id="label-iter_next_loop" type="checkbox"><label for="label-iter_next_loop"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_next_loop">iter_next_loop
<a href="#iter_next_loop" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for loops on <code>x.next()</code>.</p>
<h3>Why is this bad?</h3>
<p><code>next()</code> returns either <code>Some(value)</code> if there was a
value, or <code>None</code> otherwise. The insidious thing is that <code>Option&lt;_&gt;</code>
implements <code>IntoIterator</code>, so that possibly one value will be iterated,
leading to some hard to find bugs. No one will want to write such code
<a href="https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr">except to win an Underhanded Rust
Contest</a>.</p>
<h3>Example</h3>
<pre><code class="language-rust">for x in y.next() {
    ..
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_next_loop">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L161">View Source</a></div></div></div></article><article id="iter_next_slice"><input id="label-iter_next_slice" type="checkbox"><label for="label-iter_next_slice"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_next_slice">iter_next_slice
<a href="#iter_next_slice" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>iter().next()</code> on a Slice or an Array</p>
<h3>Why is this bad?</h3>
<p>These can be shortened into <code>.get()</code></p>
<h3>Example</h3>
<pre><code class="language-rust">a[2..].iter().next();
b.iter().next();
</code></pre>
<p>should be written as:</p>
<pre><code class="language-rust">a.get(2);
b.get(0);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.46.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_next_slice">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1871">View Source</a></div></div></div></article><article id="iter_not_returning_iterator"><input id="label-iter_not_returning_iterator" type="checkbox"><label for="label-iter_not_returning_iterator"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_not_returning_iterator">iter_not_returning_iterator
<a href="#iter_not_returning_iterator" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects methods named <code>iter</code> or <code>iter_mut</code> that do not have a return type that implements <code>Iterator</code>.</p>
<h3>Why is this bad?</h3>
<p>Methods named <code>iter</code> or <code>iter_mut</code> conventionally return an <code>Iterator</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">// `String` does not implement `Iterator`
struct Data {}
impl Data {
    fn iter(&amp;self) -&gt; String {
        todo!()
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::str::Chars;
struct Data {}
impl Data {
    fn iter(&amp;self) -&gt; Chars&lt;'static&gt; {
        todo!()
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.57.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_not_returning_iterator">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/iter_not_returning_iterator.rs#L9">View Source</a></div></div></div></article><article id="iter_nth"><input id="label-iter_nth" type="checkbox"><label for="label-iter_nth"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_nth">iter_nth
<a href="#iter_nth" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.iter().nth()</code>/<code>.iter_mut().nth()</code> on standard library types that have
equivalent <code>.get()</code>/<code>.get_mut()</code> methods.</p>
<h3>Why is this bad?</h3>
<p><code>.get()</code> and <code>.get_mut()</code> are equivalent but more concise.</p>
<h3>Example</h3>
<pre><code class="language-rust">let some_vec = vec![0, 1, 2, 3];
let bad_vec = some_vec.iter().nth(3);
let bad_slice = &amp;some_vec[..].iter().nth(3);
</code></pre>
<p>The correct use would be:</p>
<pre><code class="language-rust">let some_vec = vec![0, 1, 2, 3];
let bad_vec = some_vec.get(3);
let bad_slice = &amp;some_vec[..].get(3);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_nth">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1239">View Source</a></div></div></div></article><article id="iter_nth_zero"><input id="label-iter_nth_zero" type="checkbox"><label for="label-iter_nth_zero"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_nth_zero">iter_nth_zero
<a href="#iter_nth_zero" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the use of <code>iter.nth(0)</code>.</p>
<h3>Why is this bad?</h3>
<p><code>iter.next()</code> is equivalent to
<code>iter.nth(0)</code>, as they both consume the next element,
but is more readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = s.iter().nth(0);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = s.iter().next();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.42.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_nth_zero">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1209">View Source</a></div></div></div></article><article id="iter_on_empty_collections"><input id="label-iter_on_empty_collections" type="checkbox"><label for="label-iter_on_empty_collections"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_on_empty_collections">iter_on_empty_collections
<a href="#iter_on_empty_collections" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>iter</code>, <code>iter_mut</code> or <code>into_iter</code> on empty collections</p>
<h3>Why is this bad?</h3>
<p>It is simpler to use the empty function from the standard library:</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::{slice, option};
let a: slice::Iter&lt;i32&gt; = [].iter();
let f: option::IntoIter&lt;i32&gt; = None.into_iter();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::iter;
let a: iter::Empty&lt;i32&gt; = iter::empty();
let b: iter::Empty&lt;i32&gt; = iter::empty();
</code></pre>
<h3>Known problems</h3>
<p>The type of the resulting iterator might become incompatible with its usage</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.65.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_on_empty_collections">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2557">View Source</a></div></div></div></article><article id="iter_on_single_items"><input id="label-iter_on_single_items" type="checkbox"><label for="label-iter_on_single_items"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_on_single_items">iter_on_single_items
<a href="#iter_on_single_items" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>iter</code>, <code>iter_mut</code> or <code>into_iter</code> on collections containing a single item</p>
<h3>Why is this bad?</h3>
<p>It is simpler to use the once function from the standard library:</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = [123].iter();
let b = Some(123).into_iter();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::iter;
let a = iter::once(&amp;123);
let b = iter::once(123);
</code></pre>
<h3>Known problems</h3>
<p>The type of the resulting iterator might become incompatible with its usage</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.65.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_on_single_items">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2526">View Source</a></div></div></div></article><article id="iter_out_of_bounds"><input id="label-iter_out_of_bounds" type="checkbox"><label for="label-iter_out_of_bounds"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_out_of_bounds">iter_out_of_bounds
<a href="#iter_out_of_bounds" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Looks for iterator combinator calls such as <code>.take(x)</code> or <code>.skip(x)</code>
where <code>x</code> is greater than the amount of items that an iterator will produce.</p>
<h3>Why is this bad?</h3>
<p>Taking or skipping more items than there are in an iterator either creates an iterator
with all items from the original iterator or an iterator with no items at all.
This is most likely not what the user intended to do.</p>
<h3>Example</h3>
<pre><code class="language-rust">for _ in [1, 2, 3].iter().take(4) {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">for _ in [1, 2, 3].iter() {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.74.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_out_of_bounds">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3685">View Source</a></div></div></div></article><article id="iter_over_hash_type"><input id="label-iter_over_hash_type" type="checkbox"><label for="label-iter_over_hash_type"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_over_hash_type">iter_over_hash_type
<a href="#iter_over_hash_type" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This is a restriction lint which prevents the use of hash types (i.e., <code>HashSet</code> and <code>HashMap</code>) in for loops.</p>
<h3>Why restrict this?</h3>
<p>Because hash types are unordered, when iterated through such as in a <code>for</code> loop, the values are returned in
an undefined order. As a result, on redundant systems this may cause inconsistencies and anomalies.
In addition, the unknown order of the elements may reduce readability or introduce other undesired
side effects.</p>
<h3>Example</h3>
<pre><code class="language-rust">    let my_map = std::collections::HashMap::&lt;i32, String&gt;::new();
    for (key, value) in my_map { /* ... */ }
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">    let my_map = std::collections::HashMap::&lt;i32, String&gt;::new();
    let mut keys = my_map.keys().clone().collect::&lt;Vec&lt;_&gt;&gt;();
    keys.sort();
    for key in keys {
        let value = &amp;my_map[key];
    }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.76.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_over_hash_type">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/iter_over_hash_type.rs#L8">View Source</a></div></div></div></article><article id="iter_overeager_cloned"><input id="label-iter_overeager_cloned" type="checkbox"><label for="label-iter_overeager_cloned"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_overeager_cloned">iter_overeager_cloned
<a href="#iter_overeager_cloned" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>_.cloned().&lt;func&gt;()</code> where call to <code>.cloned()</code> can be postponed.</p>
<h3>Why is this bad?</h3>
<p>It’s often inefficient to clone all elements of an iterator, when eventually, only some
of them will be consumed.</p>
<h3>Known Problems</h3>
<p>This <code>lint</code> removes the side of effect of cloning items in the iterator.
A code that relies on that side-effect could fail.</p>
<h3>Examples</h3>
<pre><code class="language-rust">vec.iter().cloned().take(10);
vec.iter().cloned().last();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">vec.iter().take(10).cloned();
vec.iter().last().cloned();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.60.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_overeager_cloned">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L215">View Source</a></div></div></div></article><article id="iter_skip_next"><input id="label-iter_skip_next" type="checkbox"><label for="label-iter_skip_next"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_skip_next">iter_skip_next
<a href="#iter_skip_next" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.skip(x).next()</code> on iterators.</p>
<h3>Why is this bad?</h3>
<p><code>.nth(x)</code> is cleaner</p>
<h3>Example</h3>
<pre><code class="language-rust">let some_vec = vec![0, 1, 2, 3];
let bad_vec = some_vec.iter().skip(3).next();
let bad_slice = &amp;some_vec[..].iter().skip(3).next();
</code></pre>
<p>The correct use would be:</p>
<pre><code class="language-rust">let some_vec = vec![0, 1, 2, 3];
let bad_vec = some_vec.iter().nth(3);
let bad_slice = &amp;some_vec[..].iter().nth(3);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_skip_next">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1265">View Source</a></div></div></div></article><article id="iter_skip_zero"><input id="label-iter_skip_zero" type="checkbox"><label for="label-iter_skip_zero"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_skip_zero">iter_skip_zero
<a href="#iter_skip_zero" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.skip(0)</code> on iterators.</p>
<h3>Why is this bad?</h3>
<p>This was likely intended to be <code>.skip(1)</code> to skip the first element, as <code>.skip(0)</code> does
nothing. If not, the call should be removed.</p>
<h3>Example</h3>
<pre><code class="language-rust">let v = vec![1, 2, 3];
let x = v.iter().skip(0).collect::&lt;Vec&lt;_&gt;&gt;();
let y = v.iter().collect::&lt;Vec&lt;_&gt;&gt;();
assert_eq!(x, y);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_skip_zero">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3602">View Source</a></div></div></div></article><article id="iter_with_drain"><input id="label-iter_with_drain" type="checkbox"><label for="label-iter_with_drain"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_with_drain">iter_with_drain
<a href="#iter_with_drain" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.drain(..)</code> on <code>Vec</code> and <code>VecDeque</code> for iteration.</p>
<h3>Why is this bad?</h3>
<p><code>.into_iter()</code> is simpler with better performance.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut foo = vec![0, 1, 2, 3];
let bar: HashSet&lt;usize&gt; = foo.drain(..).collect();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let foo = vec![0, 1, 2, 3];
let bar: HashSet&lt;usize&gt; = foo.into_iter().collect();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.61.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_with_drain">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1290">View Source</a></div></div></div></article><article id="iter_without_into_iter"><input id="label-iter_without_into_iter" type="checkbox"><label for="label-iter_without_into_iter"><h2 class="lint-title"><div class="panel-title-name" id="lint-iter_without_into_iter">iter_without_into_iter
<a href="#iter_without_into_iter" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Looks for <code>iter</code> and <code>iter_mut</code> methods without an associated <code>IntoIterator for (&amp;|&amp;mut) Type</code> implementation.</p>
<h3>Why is this bad?</h3>
<p>It’s not bad, but having them is idiomatic and allows the type to be used in for loops directly
(<code>for val in &amp;iter {}</code>), without having to first call <code>iter()</code> or <code>iter_mut()</code>.</p>
<h3>Limitations</h3>
<p>This lint focuses on providing an idiomatic API. Therefore, it will only
lint on types which are accessible outside of the crate. For internal types,
the <code>IntoIterator</code> trait can be implemented on demand if it is actually needed.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct MySlice&lt;'a&gt;(&amp;'a [u8]);
impl&lt;'a&gt; MySlice&lt;'a&gt; {
    pub fn iter(&amp;self) -&gt; std::slice::Iter&lt;'a, u8&gt; {
        self.0.iter()
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct MySlice&lt;'a&gt;(&amp;'a [u8]);
impl&lt;'a&gt; MySlice&lt;'a&gt; {
    pub fn iter(&amp;self) -&gt; std::slice::Iter&lt;'a, u8&gt; {
        self.0.iter()
    }
}
impl&lt;'a&gt; IntoIterator for &amp;MySlice&lt;'a&gt; {
    type Item = &amp;'a u8;
    type IntoIter = std::slice::Iter&lt;'a, u8&gt;;
    fn into_iter(self) -&gt; Self::IntoIter {
        self.iter()
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.75.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iter_without_into_iter">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/iter_without_into_iter.rs#L12">View Source</a></div></div></div></article><article id="iterator_step_by_zero"><input id="label-iterator_step_by_zero" type="checkbox"><label for="label-iterator_step_by_zero"><h2 class="lint-title"><div class="panel-title-name" id="lint-iterator_step_by_zero">iterator_step_by_zero
<a href="#iterator_step_by_zero" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calling <code>.step_by(0)</code> on iterators which panics.</p>
<h3>Why is this bad?</h3>
<p>This very much looks like an oversight. Use <code>panic!()</code> instead if you
actually intend to panic.</p>
<h3>Example</h3>
<pre><code class="language-rust">for x in (0..100).step_by(0) {
    //..
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+iterator_step_by_zero">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1166">View Source</a></div></div></div></article><article id="join_absolute_paths"><input id="label-join_absolute_paths" type="checkbox"><label for="label-join_absolute_paths"><h2 class="lint-title"><div class="panel-title-name" id="lint-join_absolute_paths">join_absolute_paths
<a href="#join_absolute_paths" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>Path::join</code> that start with a path separator (<code>\\</code> or <code>/</code>).</p>
<h3>Why is this bad?</h3>
<p>If the argument to <code>Path::join</code> starts with a separator, it will overwrite
the original path. If this is intentional, prefer using <code>Path::new</code> instead.</p>
<p>Note the behavior is platform dependent. A leading <code>\\</code> will be accepted
on unix systems as part of the file name</p>
<p>See <a href="https://doc.rust-lang.org/std/path/struct.Path.html#method.join"><code>Path::join</code></a></p>
<h3>Example</h3>
<pre><code class="language-rust">let path = Path::new("/bin");
let joined_path = path.join("/sh");
assert_eq!(joined_path, PathBuf::from("/sh"));
</code></pre>
<p>Use instead;</p>
<pre><code class="language-rust">let path = Path::new("/bin");

// If this was unintentional, remove the leading separator
let joined_path = path.join("sh");
assert_eq!(joined_path, PathBuf::from("/bin/sh"));

// If this was intentional, create a new path instead
let new = Path::new("/sh");
assert_eq!(new, PathBuf::from("/sh"));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.76.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+join_absolute_paths">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3823">View Source</a></div></div></div></article><article id="just_underscores_and_digits"><input id="label-just_underscores_and_digits" type="checkbox"><label for="label-just_underscores_and_digits"><h2 class="lint-title"><div class="panel-title-name" id="lint-just_underscores_and_digits">just_underscores_and_digits
<a href="#just_underscores_and_digits" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks if you have variables whose name consists of just
underscores and digits.</p>
<h3>Why is this bad?</h3>
<p>It’s hard to memorize what a variable means without a
descriptive name.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _1 = 1;
let ___1 = 1;
let __1___2 = 11;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+just_underscores_and_digits">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/non_expressive_names.rs#L55">View Source</a></div></div></div></article><article id="large_const_arrays"><input id="label-large_const_arrays" type="checkbox"><label for="label-large_const_arrays"><h2 class="lint-title"><div class="panel-title-name" id="lint-large_const_arrays">large_const_arrays
<a href="#large_const_arrays" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for large <code>const</code> arrays that should
be defined as <code>static</code> instead.</p>
<h3>Why is this bad?</h3>
<p>Performance: const variables are inlined upon use.
Static items result in only one instance and has a fixed location in memory.</p>
<h3>Example</h3>
<pre><code class="language-rust">pub const a = [0u32; 1_000_000];
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">pub static a = [0u32; 1_000_000];
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>array-size-threshold</code>:  The maximum allowed size for arrays on the stack</p>
<p>(default: <code>16384</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.44.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+large_const_arrays">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/large_const_arrays.rs#L11">View Source</a></div></div></div></article><article id="large_digit_groups"><input id="label-large_digit_groups" type="checkbox"><label for="label-large_digit_groups"><h2 class="lint-title"><div class="panel-title-name" id="lint-large_digit_groups">large_digit_groups
<a href="#large_digit_groups" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns if the digits of an integral or floating-point
constant are grouped into groups that
are too large.</p>
<h3>Why is this bad?</h3>
<p>Negatively impacts readability.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: u64 = 6186491_8973511;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+large_digit_groups">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/literal_representation.rs#L109">View Source</a></div></div></div></article><article id="large_enum_variant"><input id="label-large_enum_variant" type="checkbox"><label for="label-large_enum_variant"><h2 class="lint-title"><div class="panel-title-name" id="lint-large_enum_variant">large_enum_variant
<a href="#large_enum_variant" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for large size differences between variants on
<code>enum</code>s.</p>
<h3>Why is this bad?</h3>
<p>Enum size is bounded by the largest variant. Having one
large variant can penalize the memory layout of that enum.</p>
<h3>Known problems</h3>
<p>This lint obviously cannot take the distribution of
variants in your running program into account. It is possible that the
smaller variants make up less than 1% of all instances, in which case
the overhead is negligible and the boxing is counter-productive. Always
measure the change this lint suggests.</p>
<p>For types that implement <code>Copy</code>, the suggestion to <code>Box</code> a variant’s
data would require removing the trait impl. The types can of course
still be <code>Clone</code>, but that is worse ergonomically. Depending on the
use case it may be possible to store the large data in an auxiliary
structure (e.g. Arena or ECS).</p>
<p>The lint will ignore the impact of generic types to the type layout by
assuming every type parameter is zero-sized. Depending on your use case,
this may lead to a false positive.</p>
<h3>Example</h3>
<pre><code class="language-rust">enum Test {
    A(i32),
    B([i32; 8000]),
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// Possibly better
enum Test2 {
    A(i32),
    B(Box&lt;[i32; 8000]&gt;),
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>enum-variant-size-threshold</code>:  The maximum size of an enum’s variant to avoid box suggestion</p>
<p>(default: <code>200</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+large_enum_variant">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/large_enum_variant.rs#L13">View Source</a></div></div></div></article><article id="large_futures"><input id="label-large_futures" type="checkbox"><label for="label-large_futures"><h2 class="lint-title"><div class="panel-title-name" id="lint-large_futures">large_futures
<a href="#large_futures" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>It checks for the size of a <code>Future</code> created by <code>async fn</code> or <code>async {}</code>.</p>
<h3>Why is this bad?</h3>
<p>Due to the current <a href="https://github.com/rust-lang/rust/issues/69826">unideal implementation</a> of <code>Coroutine</code>,
large size of a <code>Future</code> may cause stack overflows.</p>
<h3>Example</h3>
<pre><code class="language-rust">async fn large_future(_x: [u8; 16 * 1024]) {}

pub async fn trigger() {
    large_future([0u8; 16 * 1024]).await;
}
</code></pre>
<p><code>Box::pin</code> the big future instead.</p>
<pre><code class="language-rust">async fn large_future(_x: [u8; 16 * 1024]) {}

pub async fn trigger() {
    Box::pin(large_future([0u8; 16 * 1024])).await;
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>future-size-threshold</code>:  The maximum byte size a <code>Future</code> can have, before it triggers the <code>clippy::large_futures</code> lint</p>
<p>(default: <code>16384</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+large_futures">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/large_futures.rs#L11">View Source</a></div></div></div></article><article id="large_include_file"><input id="label-large_include_file" type="checkbox"><label for="label-large_include_file"><h2 class="lint-title"><div class="panel-title-name" id="lint-large_include_file">large_include_file
<a href="#large_include_file" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the inclusion of large files via <code>include_bytes!()</code>
or <code>include_str!()</code>.</p>
<h3>Why restrict this?</h3>
<p>Including large files can undesirably increase the size of the binary produced by the compiler.
This lint may be used to catch mistakes where an unexpectedly large file is included, or
temporarily to obtain a list of all large files.</p>
<h3>Example</h3>
<pre><code class="language-rust">let included_str = include_str!("very_large_file.txt");
let included_bytes = include_bytes!("very_large_file.txt");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::fs;

// You can load the file at runtime
let string = fs::read_to_string("very_large_file.txt")?;
let bytes = fs::read("very_large_file.txt")?;
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>max-include-file-size</code>:  The maximum size of a file included via <code>include_bytes!()</code> or <code>include_str!()</code>, in bytes</p>
<p>(default: <code>1000000</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+large_include_file">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/large_include_file.rs#L11">View Source</a></div></div></div></article><article id="large_stack_arrays"><input id="label-large_stack_arrays" type="checkbox"><label for="label-large_stack_arrays"><h2 class="lint-title"><div class="panel-title-name" id="lint-large_stack_arrays">large_stack_arrays
<a href="#large_stack_arrays" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for local arrays that may be too large.</p>
<h3>Why is this bad?</h3>
<p>Large local arrays may cause stack overflow.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = [0u32; 1_000_000];
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>array-size-threshold</code>:  The maximum allowed size for arrays on the stack</p>
<p>(default: <code>16384</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.41.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+large_stack_arrays">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/large_stack_arrays.rs#L15">View Source</a></div></div></div></article><article id="large_stack_frames"><input id="label-large_stack_frames" type="checkbox"><label for="label-large_stack_frames"><h2 class="lint-title"><div class="panel-title-name" id="lint-large_stack_frames">large_stack_frames
<a href="#large_stack_frames" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for functions that use a lot of stack space.</p>
<p>This often happens when constructing a large type, such as an array with a lot of elements,
or constructing <em>many</em> smaller-but-still-large structs, or copying around a lot of large types.</p>
<p>This lint is a more general version of <a href="https://rust-lang.github.io/rust-clippy/master/#large_stack_arrays"><code>large_stack_arrays</code></a>
that is intended to look at functions as a whole instead of only individual array expressions inside of a function.</p>
<h3>Why is this bad?</h3>
<p>The stack region of memory is very limited in size (usually <em>much</em> smaller than the heap) and attempting to
use too much will result in a stack overflow and crash the program.
To avoid this, you should consider allocating large types on the heap instead (e.g. by boxing them).</p>
<p>Keep in mind that the code path to construction of large types does not even need to be reachable;
it purely needs to <em>exist</em> inside of the function to contribute to the stack size.
For example, this causes a stack overflow even though the branch is unreachable:</p>
<pre><code class="language-rust">fn main() {
    if false {
        let x = [0u8; 10000000]; // 10 MB stack array
        black_box(&amp;x);
    }
}
</code></pre>
<h3>Known issues</h3>
<p>False positives. The stack size that clippy sees is an estimated value and can be vastly different
from the actual stack usage after optimizations passes have run (especially true in release mode).
Modern compilers are very smart and are able to optimize away a lot of unnecessary stack allocations.
In debug mode however, it is usually more accurate.</p>
<p>This lint works by summing up the size of all variables that the user typed, variables that were
implicitly introduced by the compiler for temporaries, function arguments and the return value,
and comparing them against a (configurable, but high-by-default).</p>
<h3>Example</h3>
<p>This function creates four 500 KB arrays on the stack. Quite big but just small enough to not trigger <code>large_stack_arrays</code>.
However, looking at the function as a whole, it’s clear that this uses a lot of stack space.</p>
<pre><code class="language-rust">struct QuiteLargeType([u8; 500_000]);
fn foo() {
    // ... some function that uses a lot of stack space ...
    let _x1 = QuiteLargeType([0; 500_000]);
    let _x2 = QuiteLargeType([0; 500_000]);
    let _x3 = QuiteLargeType([0; 500_000]);
    let _x4 = QuiteLargeType([0; 500_000]);
}
</code></pre>
<p>Instead of doing this, allocate the arrays on the heap.
This currently requires going through a <code>Vec</code> first and then converting it to a <code>Box</code>:</p>
<pre><code class="language-rust">struct NotSoLargeType(Box&lt;[u8]&gt;);

fn foo() {
    let _x1 = NotSoLargeType(vec![0; 500_000].into_boxed_slice());
//                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  Now heap allocated.
//                                                                The size of `NotSoLargeType` is 16 bytes.
//  ...
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allow-large-stack-frames-in-tests</code>:  Whether functions inside <code>#[cfg(test)]</code> modules or test functions should be checked.</p>
<p>(default: <code>true</code>)</p>
</li>
<li>
<p><code>stack-size-threshold</code>:  The maximum allowed stack size for functions in bytes</p>
<p>(default: <code>512000</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+large_stack_frames">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/large_stack_frames.rs#L16">View Source</a></div></div></div></article><article id="large_types_passed_by_value"><input id="label-large_types_passed_by_value" type="checkbox"><label for="label-large_types_passed_by_value"><h2 class="lint-title"><div class="panel-title-name" id="lint-large_types_passed_by_value">large_types_passed_by_value
<a href="#large_types_passed_by_value" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for functions taking arguments by value, where
the argument type is <code>Copy</code> and large enough to be worth considering
passing by reference. Does not trigger if the function is being exported,
because that might induce API breakage, if the parameter is declared as mutable,
or if the argument is a <code>self</code>.</p>
<h3>Why is this bad?</h3>
<p>Arguments passed by value might result in an unnecessary
shallow copy, taking up more space in the stack and requiring a call to
<code>memcpy</code>, which can be expensive.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[derive(Clone, Copy)]
struct TooLarge([u8; 2048]);

fn foo(v: TooLarge) {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo(v: &amp;TooLarge) {}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
<li>
<p><code>pass-by-value-size-limit</code>:  The minimum size (in bytes) to consider a type for passing by reference instead of by value.</p>
<p>(default: <code>256</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+large_types_passed_by_value">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/pass_by_ref_or_value.rs#L71">View Source</a></div></div></div></article><article id="legacy_numeric_constants"><input id="label-legacy_numeric_constants" type="checkbox"><label for="label-legacy_numeric_constants"><h2 class="lint-title"><div class="panel-title-name" id="lint-legacy_numeric_constants">legacy_numeric_constants
<a href="#legacy_numeric_constants" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>&lt;integer&gt;::max_value()</code>, <code>std::&lt;integer&gt;::MAX</code>,
<code>std::&lt;float&gt;::EPSILON</code>, etc.</p>
<h3>Why is this bad?</h3>
<p>All of these have been superseded by the associated constants on their respective types,
such as <code>i128::MAX</code>. These legacy items may be deprecated in a future version of rust.</p>
<h3>Example</h3>
<pre><code class="language-rust">let eps = std::f32::EPSILON;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let eps = f32::EPSILON;
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.79.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+legacy_numeric_constants">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/legacy_numeric_constants.rs#L15">View Source</a></div></div></div></article><article id="len_without_is_empty"><input id="label-len_without_is_empty" type="checkbox"><label for="label-len_without_is_empty"><h2 class="lint-title"><div class="panel-title-name" id="lint-len_without_is_empty">len_without_is_empty
<a href="#len_without_is_empty" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for items that implement <code>.len()</code> but not
<code>.is_empty()</code>.</p>
<h3>Why is this bad?</h3>
<p>It is good custom to have both methods, because for
some data structures, asking about the length will be a costly operation,
whereas <code>.is_empty()</code> can usually answer in constant time. Also it used to
lead to false positives on the <a href="#len_zero"><code>len_zero</code></a> lint – currently that
lint will ignore such entities.</p>
<h3>Example</h3>
<pre><code class="language-rust">impl X {
    pub fn len(&amp;self) -&gt; usize {
        ..
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+len_without_is_empty">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/len_without_is_empty.rs#L17">View Source</a></div></div></div></article><article id="len_zero"><input id="label-len_zero" type="checkbox"><label for="label-len_zero"><h2 class="lint-title"><div class="panel-title-name" id="lint-len_zero">len_zero
<a href="#len_zero" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for getting the length of something via <code>.len()</code>
just to compare to zero, and suggests using <code>.is_empty()</code> where applicable.</p>
<h3>Why is this bad?</h3>
<p>Some structures can answer <code>.is_empty()</code> much faster
than calculating their length. So it is good to get into the habit of using
<code>.is_empty()</code>, and having it is cheap.
Besides, it makes the intent clearer than a manual comparison in some contexts.</p>
<h3>Example</h3>
<pre><code class="language-rust">if x.len() == 0 {
    ..
}
if y.len() != 0 {
    ..
}
</code></pre>
<p>instead use</p>
<pre><code class="language-rust">if x.is_empty() {
    ..
}
if !y.is_empty() {
    ..
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+len_zero">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/len_zero.rs#L19">View Source</a></div></div></div></article><article id="let_and_return"><input id="label-let_and_return" type="checkbox"><label for="label-let_and_return"><h2 class="lint-title"><div class="panel-title-name" id="lint-let_and_return">let_and_return
<a href="#let_and_return" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>let</code>-bindings, which are subsequently
returned.</p>
<h3>Why is this bad?</h3>
<p>It is just extraneous code. Remove it to make your code
more rusty.</p>
<h3>Known problems</h3>
<p>In the case of some temporaries, e.g. locks, eliding the variable binding could lead
to deadlocks. See <a href="https://github.com/rust-lang/rust/issues/37612">this issue</a>.
This could become relevant if the code is later changed to use the code that would have been
bound without first assigning it to a let-binding.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo() -&gt; String {
    let x = String::new();
    x
}
</code></pre>
<p>instead, use</p>
<pre><code class="language-rust">fn foo() -&gt; String {
    String::new()
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+let_and_return">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/returns/mod.rs#L12">View Source</a></div></div></div></article><article id="let_underscore_future"><input id="label-let_underscore_future" type="checkbox"><label for="label-let_underscore_future"><h2 class="lint-title"><div class="panel-title-name" id="lint-let_underscore_future">let_underscore_future
<a href="#let_underscore_future" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>let _ = &lt;expr&gt;</code> where the resulting type of expr implements <code>Future</code></p>
<h3>Why is this bad?</h3>
<p>Futures must be polled for work to be done. The original intention was most likely to await the future
and ignore the resulting value.</p>
<h3>Example</h3>
<pre><code class="language-rust">async fn foo() -&gt; Result&lt;(), ()&gt; {
    Ok(())
}
let _ = foo();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">async fn foo() -&gt; Result&lt;(), ()&gt; {
    Ok(())
}
let _ = foo().await;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.67.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+let_underscore_future">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/let_underscore.rs#L61">View Source</a></div></div></div></article><article id="let_underscore_lock"><input id="label-let_underscore_lock" type="checkbox"><label for="label-let_underscore_lock"><h2 class="lint-title"><div class="panel-title-name" id="lint-let_underscore_lock">let_underscore_lock
<a href="#let_underscore_lock" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>let _ = sync_lock</code>. This supports <code>mutex</code> and <code>rwlock</code> in
<code>parking_lot</code>. For <code>std</code> locks see the <code>rustc</code> lint
<a href="https://doc.rust-lang.org/nightly/rustc/lints/listing/deny-by-default.html#let-underscore-lock"><code>let_underscore_lock</code></a></p>
<h3>Why is this bad?</h3>
<p>This statement immediately drops the lock instead of
extending its lifetime to the end of the scope, which is often not intended.
To extend lock lifetime to the end of the scope, use an underscore-prefixed
name instead (i.e. _lock). If you want to explicitly drop the lock,
<code>std::mem::drop</code> conveys your intention better and is less error-prone.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = mutex.lock();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _lock = mutex.lock();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.43.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+let_underscore_lock">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/let_underscore.rs#L33">View Source</a></div></div></div></article><article id="let_underscore_must_use"><input id="label-let_underscore_must_use" type="checkbox"><label for="label-let_underscore_must_use"><h2 class="lint-title"><div class="panel-title-name" id="lint-let_underscore_must_use">let_underscore_must_use
<a href="#let_underscore_must_use" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>let _ = &lt;expr&gt;</code> where expr is <code>#[must_use]</code></p>
<h3>Why restrict this?</h3>
<p>To ensure that all <code>#[must_use]</code> types are used rather than ignored.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn f() -&gt; Result&lt;u32, u32&gt; {
    Ok(0)
}

let _ = f();
// is_ok() is marked #[must_use]
let _ = f().is_ok();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.42.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+let_underscore_must_use">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/let_underscore.rs#L10">View Source</a></div></div></div></article><article id="let_underscore_untyped"><input id="label-let_underscore_untyped" type="checkbox"><label for="label-let_underscore_untyped"><h2 class="lint-title"><div class="panel-title-name" id="lint-let_underscore_untyped">let_underscore_untyped
<a href="#let_underscore_untyped" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>let _ = &lt;expr&gt;</code> without a type annotation, and suggests to either provide one,
or remove the <code>let</code> keyword altogether.</p>
<h3>Why restrict this?</h3>
<p>The <code>let _ = &lt;expr&gt;</code> expression ignores the value of <code>&lt;expr&gt;</code>, but will continue to do so even
if the type were to change, thus potentially introducing subtle bugs. By supplying a type
annotation, one will be forced to re-visit the decision to ignore the value in such cases.</p>
<h3>Known problems</h3>
<p>The <code>_ = &lt;expr&gt;</code> is not properly supported by some tools (e.g. IntelliJ) and may seem odd
to many developers. This lint also partially overlaps with the other <code>let_underscore_*</code>
lints.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo() -&gt; Result&lt;u32, ()&gt; {
    Ok(123)
}
let _ = foo();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo() -&gt; Result&lt;u32, ()&gt; {
    Ok(123)
}
// Either provide a type annotation:
let _: Result&lt;u32, ()&gt; = foo();
// …or drop the let keyword:
_ = foo();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.69.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+let_underscore_untyped">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/let_underscore.rs#L92">View Source</a></div></div></div></article><article id="let_unit_value"><input id="label-let_unit_value" type="checkbox"><label for="label-let_unit_value"><h2 class="lint-title"><div class="panel-title-name" id="lint-let_unit_value">let_unit_value
<a href="#let_unit_value" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for binding a unit value.</p>
<h3>Why is this bad?</h3>
<p>A unit value cannot usefully be used anywhere. So
binding one is kind of pointless.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = {
    1;
};
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+let_unit_value">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unit_types/mod.rs#L11">View Source</a></div></div></div></article><article id="let_with_type_underscore"><input id="label-let_with_type_underscore" type="checkbox"><label for="label-let_with_type_underscore"><h2 class="lint-title"><div class="panel-title-name" id="lint-let_with_type_underscore">let_with_type_underscore
<a href="#let_with_type_underscore" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects when a variable is declared with an explicit type of <code>_</code>.</p>
<h3>Why is this bad?</h3>
<p>It adds noise, <code>: _</code> provides zero clarity or utility.</p>
<h3>Example</h3>
<pre><code class="language-rust">let my_number: _ = 1;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let my_number = 1;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+let_with_type_underscore">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/let_with_type_underscore.rs#L9">View Source</a></div></div></div></article><article id="lines_filter_map_ok"><input id="label-lines_filter_map_ok" type="checkbox"><label for="label-lines_filter_map_ok"><h2 class="lint-title"><div class="panel-title-name" id="lint-lines_filter_map_ok">lines_filter_map_ok
<a href="#lines_filter_map_ok" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>lines.filter_map(Result::ok)</code> or <code>lines.flat_map(Result::ok)</code>
when <code>lines</code> has type <code>std::io::Lines</code>.</p>
<h3>Why is this bad?</h3>
<p><code>Lines</code> instances might produce a never-ending stream of <code>Err</code>, in which case
<code>filter_map(Result::ok)</code> will enter an infinite loop while waiting for an
<code>Ok</code> variant. Calling <code>next()</code> once is sufficient to enter the infinite loop,
even in the absence of explicit loops in the user code.</p>
<p>This situation can arise when working with user-provided paths. On some platforms,
<code>std::fs::File::open(path)</code> might return <code>Ok(fs)</code> even when <code>path</code> is a directory,
but any later attempt to read from <code>fs</code> will return an error.</p>
<h3>Known problems</h3>
<p>This lint suggests replacing <code>filter_map()</code> or <code>flat_map()</code> applied to a <code>Lines</code>
instance in all cases. There are two cases where the suggestion might not be
appropriate or necessary:</p>
<ul>
<li>If the <code>Lines</code> instance can never produce any error, or if an error is produced
only once just before terminating the iterator, using <code>map_while()</code> is not
necessary but will not do any harm.</li>
<li>If the <code>Lines</code> instance can produce intermittent errors then recover and produce
successful results, using <code>map_while()</code> would stop at the first error.</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">let mut lines = BufReader::new(File::open("some-path")?).lines().filter_map(Result::ok);
// If "some-path" points to a directory, the next statement never terminates:
let first_line: Option&lt;String&gt; = lines.next();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut lines = BufReader::new(File::open("some-path")?).lines().map_while(Result::ok);
let first_line: Option&lt;String&gt; = lines.next();
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+lines_filter_map_ok">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4703">View Source</a></div></div></div></article><article id="linkedlist"><input id="label-linkedlist" type="checkbox"><label for="label-linkedlist"><h2 class="lint-title"><div class="panel-title-name" id="lint-linkedlist">linkedlist
<a href="#linkedlist" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of any <code>LinkedList</code>, suggesting to use a
<code>Vec</code> or a <code>VecDeque</code> (formerly called <code>RingBuf</code>).</p>
<h3>Why is this bad?</h3>
<p>Gankra says:</p>
<blockquote>
<p>The TL;DR of <code>LinkedList</code> is that it’s built on a massive amount of
pointers and indirection.
It wastes memory, it has terrible cache locality, and is all-around slow.
<code>RingBuf</code>, while
“only” amortized for push/pop, should be faster in the general case for
almost every possible
workload, and isn’t even amortized at all if you can predict the capacity
you need.</p>
<p><code>LinkedList</code>s are only really good if you’re doing a lot of merging or
splitting of lists.
This is because they can just mangle some pointers instead of actually
copying the data. Even
if you’re doing a lot of insertion in the middle of the list, <code>RingBuf</code>
can still be better
because of how expensive it is to seek to the middle of a <code>LinkedList</code>.</p>
</blockquote>
<h3>Known problems</h3>
<p>False positives – the instances where using a
<code>LinkedList</code> makes sense are few and far between, but they can still happen.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: LinkedList&lt;usize&gt; = LinkedList::new();
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+linkedlist">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/types/mod.rs#L123">View Source</a></div></div></div></article><article id="lint_groups_priority"><input id="label-lint_groups_priority" type="checkbox"><label for="label-lint_groups_priority"><h2 class="lint-title"><div class="panel-title-name" id="lint-lint_groups_priority">lint_groups_priority
<a href="#lint_groups_priority" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for lint groups with the same priority as lints in the <code>Cargo.toml</code>
<a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-lints-section"><code>[lints]</code> table</a>.</p>
<p>This lint will be removed once <a href="https://github.com/rust-lang/cargo/issues/12918">cargo#12918</a>
is resolved.</p>
<h3>Why is this bad?</h3>
<p>The order of lints in the <code>[lints]</code> is ignored, to have a lint override a group the
<code>priority</code> field needs to be used, otherwise the sort order is undefined.</p>
<h3>Known problems</h3>
<p>Does not check lints inherited using <code>lints.workspace = true</code></p>
<h3>Example</h3>
<pre><code class="language-toml">[lints.clippy]
pedantic = "warn"
similar_names = "allow"
</code></pre>
<p>Use instead:</p>
<pre><code class="language-toml">[lints.clippy]
pedantic = { level = "warn", priority = -1 }
similar_names = "allow"
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.78.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+lint_groups_priority">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/cargo/mod.rs#L179">View Source</a></div></div></div></article><article id="literal_string_with_formatting_args"><input id="label-literal_string_with_formatting_args" type="checkbox"><label for="label-literal_string_with_formatting_args"><h2 class="lint-title"><div class="panel-title-name" id="lint-literal_string_with_formatting_args">literal_string_with_formatting_args
<a href="#literal_string_with_formatting_args" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks if string literals have formatting arguments outside of macros
using them (like <code>format!</code>).</p>
<h3>Why is this bad?</h3>
<p>It will likely not generate the expected content.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: Option&lt;usize&gt; = None;
let y = "hello";
x.expect("{y:?}");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x: Option&lt;usize&gt; = None;
let y = "hello";
x.expect(&amp;format!("{y:?}"));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.85.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+literal_string_with_formatting_args">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/literal_string_with_formatting_args.rs#L13">View Source</a></div></div></div></article><article id="little_endian_bytes"><input id="label-little_endian_bytes" type="checkbox"><label for="label-little_endian_bytes"><h2 class="lint-title"><div class="panel-title-name" id="lint-little_endian_bytes">little_endian_bytes
<a href="#little_endian_bytes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the usage of the <code>to_le_bytes</code> method and/or the function <code>from_le_bytes</code>.</p>
<h3>Why restrict this?</h3>
<p>To ensure use of big-endian or the target’s endianness rather than little-endian.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _x = 2i32.to_le_bytes();
let _y = 2i64.to_le_bytes();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+little_endian_bytes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/endian_bytes.rs#L30">View Source</a></div></div></div></article><article id="lossy_float_literal"><input id="label-lossy_float_literal" type="checkbox"><label for="label-lossy_float_literal"><h2 class="lint-title"><div class="panel-title-name" id="lint-lossy_float_literal">lossy_float_literal
<a href="#lossy_float_literal" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for whole number float literals that
cannot be represented as the underlying type without loss.</p>
<h3>Why restrict this?</h3>
<p>If the value was intended to be exact, it will not be.
This may be especially surprising when the lost precision is to the left of the decimal point.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _: f32 = 16_777_217.0; // 16_777_216.0
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _: f32 = 16_777_216.0;
let _: f64 = 16_777_217.0;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.43.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+lossy_float_literal">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/float_literal.rs#L39">View Source</a></div></div></div></article><article id="macro_metavars_in_unsafe"><input id="label-macro_metavars_in_unsafe" type="checkbox"><label for="label-macro_metavars_in_unsafe"><h2 class="lint-title"><div class="panel-title-name" id="lint-macro_metavars_in_unsafe">macro_metavars_in_unsafe
<a href="#macro_metavars_in_unsafe" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Looks for macros that expand metavariables in an unsafe block.</p>
<h3>Why is this bad?</h3>
<p>This hides an unsafe block and allows the user of the macro to write unsafe code without an explicit
unsafe block at callsite, making it possible to perform unsafe operations in seemingly safe code.</p>
<p>The macro should be restructured so that these metavariables are referenced outside of unsafe blocks
and that the usual unsafety checks apply to the macro argument.</p>
<p>This is usually done by binding it to a variable outside of the unsafe block
and then using that variable inside of the block as shown in the example, or by referencing it a second time
in a safe context, e.g. <code>if false { $expr }</code>.</p>
<h3>Known limitations</h3>
<p>Due to how macros are represented in the compiler at the time Clippy runs its lints,
it’s not possible to look for metavariables in macro definitions directly.</p>
<p>Instead, this lint looks at expansions of macros.
This leads to false negatives for macros that are never actually invoked.</p>
<p>By default, this lint is rather conservative and will only emit warnings on publicly-exported
macros from the same crate, because oftentimes private internal macros are one-off macros where
this lint would just be noise (e.g. macros that generate <code>impl</code> blocks).
The default behavior should help with preventing a high number of such false positives,
however it can be configured to also emit warnings in private macros if desired.</p>
<h3>Example</h3>
<pre><code class="language-rust">/// Gets the first element of a slice
macro_rules! first {
    ($slice:expr) =&gt; {
        unsafe {
            let slice = $slice; // ⚠️ expansion inside of `unsafe {}`

            assert!(!slice.is_empty());
            // SAFETY: slice is checked to have at least one element
            slice.first().unwrap_unchecked()
        }
    }
}

assert_eq!(*first!(&amp;[1i32]), 1);

// This will compile as a consequence (note the lack of `unsafe {}`)
assert_eq!(*first!(std::hint::unreachable_unchecked() as &amp;[i32]), 1);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">macro_rules! first {
    ($slice:expr) =&gt; {{
        let slice = $slice; // ✅ outside of `unsafe {}`
        unsafe {
            assert!(!slice.is_empty());
            // SAFETY: slice is checked to have at least one element
            slice.first().unwrap_unchecked()
        }
    }}
}

assert_eq!(*first!(&amp;[1]), 1);

// This won't compile:
assert_eq!(*first!(std::hint::unreachable_unchecked() as &amp;[i32]), 1);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>warn-unsafe-macro-metavars-in-private-macros</code>:  Whether to also emit warnings for unsafe blocks with metavariable expansions in <strong>private</strong> macros.</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.80.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+macro_metavars_in_unsafe">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/macro_metavars_in_unsafe.rs#L16">View Source</a></div></div></div></article><article id="macro_use_imports"><input id="label-macro_use_imports" type="checkbox"><label for="label-macro_use_imports"><h2 class="lint-title"><div class="panel-title-name" id="lint-macro_use_imports">macro_use_imports
<a href="#macro_use_imports" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>#[macro_use] use...</code>.</p>
<h3>Why is this bad?</h3>
<p>Since the Rust 2018 edition you can import
macro’s directly, this is considered idiomatic.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[macro_use]
extern crate some_crate;

fn main() {
    some_macro!();
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use some_crate::some_macro;

fn main() {
    some_macro!();
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.44.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+macro_use_imports">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/macro_use.rs#L14">View Source</a></div></div></div></article><article id="main_recursion"><input id="label-main_recursion" type="checkbox"><label for="label-main_recursion"><h2 class="lint-title"><div class="panel-title-name" id="lint-main_recursion">main_recursion
<a href="#main_recursion" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for recursion using the entrypoint.</p>
<h3>Why is this bad?</h3>
<p>Apart from special setups (which we could detect following attributes like #![no_std]),
recursing into main() seems like an unintuitive anti-pattern we should be able to detect.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn main() {
    main();
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.38.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+main_recursion">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/main_recursion.rs#L8">View Source</a></div></div></div></article><article id="manual_abs_diff"><input id="label-manual_abs_diff" type="checkbox"><label for="label-manual_abs_diff"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_abs_diff">manual_abs_diff
<a href="#manual_abs_diff" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects patterns like <code>if a &gt; b { a - b } else { b - a }</code> and suggests using <code>a.abs_diff(b)</code>.</p>
<h3>Why is this bad?</h3>
<p>Using <code>abs_diff</code> is shorter, more readable, and avoids control flow.</p>
<h3>Examples</h3>
<pre><code class="language-rust">if a &gt; b {
    a - b
} else {
    b - a
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">a.abs_diff(b)
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.88.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_abs_diff">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_abs_diff.rs#L17">View Source</a></div></div></div></article><article id="manual_assert"><input id="label-manual_assert" type="checkbox"><label for="label-manual_assert"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_assert">manual_assert
<a href="#manual_assert" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects <code>if</code>-then-<code>panic!</code> that can be replaced with <code>assert!</code>.</p>
<h3>Why is this bad?</h3>
<p><code>assert!</code> is simpler than <code>if</code>-then-<code>panic!</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let sad_people: Vec&lt;&amp;str&gt; = vec![];
if !sad_people.is_empty() {
    panic!("there are sad people: {:?}", sad_people);
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let sad_people: Vec&lt;&amp;str&gt; = vec![];
assert!(sad_people.is_empty(), "there are sad people: {:?}", sad_people);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.57.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_assert">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_assert.rs#L10">View Source</a></div></div></div></article><article id="manual_async_fn"><input id="label-manual_async_fn" type="checkbox"><label for="label-manual_async_fn"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_async_fn">manual_async_fn
<a href="#manual_async_fn" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>It checks for manual implementations of <code>async</code> functions.</p>
<h3>Why is this bad?</h3>
<p>It’s more idiomatic to use the dedicated syntax.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::future::Future;

fn foo() -&gt; impl Future&lt;Output = i32&gt; { async { 42 } }
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">async fn foo() -&gt; i32 { 42 }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.45.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_async_fn">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_async_fn.rs#L16">View Source</a></div></div></div></article><article id="manual_bits"><input id="label-manual_bits" type="checkbox"><label for="label-manual_bits"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_bits">manual_bits
<a href="#manual_bits" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>size_of::&lt;T&gt;() * 8</code> when
<code>T::BITS</code> is available.</p>
<h3>Why is this bad?</h3>
<p>Can be written as the shorter <code>T::BITS</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">size_of::&lt;usize&gt;() * 8;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">usize::BITS as usize;
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.60.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_bits">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_bits.rs#L15">View Source</a></div></div></div></article><article id="manual_c_str_literals"><input id="label-manual_c_str_literals" type="checkbox"><label for="label-manual_c_str_literals"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_c_str_literals">manual_c_str_literals
<a href="#manual_c_str_literals" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the manual creation of C strings (a string with a <code>NUL</code> byte at the end), either
through one of the <code>CStr</code> constructor functions, or more plainly by calling <code>.as_ptr()</code>
on a (byte) string literal with a hardcoded <code>\0</code> byte at the end.</p>
<h3>Why is this bad?</h3>
<p>This can be written more concisely using <code>c"str"</code> literals and is also less error-prone,
because the compiler checks for interior <code>NUL</code> bytes and the terminating <code>NUL</code> byte is inserted automatically.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn needs_cstr(_: &amp;CStr) {}

needs_cstr(CStr::from_bytes_with_nul(b"Hello\0").unwrap());
unsafe { libc::puts("World\0".as_ptr().cast()) }
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn needs_cstr(_: &amp;CStr) {}

needs_cstr(c"Hello");
unsafe { libc::puts(c"World".as_ptr()) }
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.78.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_c_str_literals">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4076">View Source</a></div></div></div></article><article id="manual_clamp"><input id="label-manual_clamp" type="checkbox"><label for="label-manual_clamp"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_clamp">manual_clamp
<a href="#manual_clamp" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Identifies good opportunities for a clamp function from std or core, and suggests using it.</p>
<h3>Why is this bad?</h3>
<p>clamp is much shorter, easier to read, and doesn’t use any control flow.</p>
<h3>Limitations</h3>
<p>This lint will only trigger if max and min are known at compile time, and max is
greater than min.</p>
<h3>Known issue(s)</h3>
<p>If the clamped variable is NaN this suggestion will cause the code to propagate NaN
rather than returning either <code>max</code> or <code>min</code>.</p>
<p><code>clamp</code> functions will panic if <code>max &lt; min</code>, <code>max.is_nan()</code>, or <code>min.is_nan()</code>.
Some may consider panicking in these situations to be desirable, but it also may
introduce panicking where there wasn’t any before.</p>
<p>See also <a href="https://github.com/rust-lang/rust-clippy/pull/9484#issuecomment-1278922613">the discussion in the
PR</a>.</p>
<h3>Examples</h3>
<pre><code class="language-rust">if input &gt; max {
    max
} else if input &lt; min {
    min
} else {
    input
}
</code></pre>
<pre><code class="language-rust">input.max(min).min(max)
</code></pre>
<pre><code class="language-rust">match input {
    x if x &gt; max =&gt; max,
    x if x &lt; min =&gt; min,
    x =&gt; x,
}
</code></pre>
<pre><code class="language-rust">let mut x = input;
if x &lt; min { x = min; }
if x &gt; max { x = max; }
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">input.clamp(min, max)
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.66.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_clamp">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_clamp.rs#L22">View Source</a></div></div></div></article><article id="manual_contains"><input id="label-manual_contains" type="checkbox"><label for="label-manual_contains"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_contains">manual_contains
<a href="#manual_contains" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>iter().any()</code> on slices when it can be replaced with <code>contains()</code> and suggests doing so.</p>
<h3>Why is this bad?</h3>
<p><code>contains()</code> is more concise and idiomatic, while also being faster in some cases.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(values: &amp;[u8]) -&gt; bool {
    values.iter().any(|&amp;v| v == 10)
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo(values: &amp;[u8]) -&gt; bool {
    values.contains(&amp;10)
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.87.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_contains">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4524">View Source</a></div></div></div></article><article id="manual_dangling_ptr"><input id="label-manual_dangling_ptr" type="checkbox"><label for="label-manual_dangling_ptr"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_dangling_ptr">manual_dangling_ptr
<a href="#manual_dangling_ptr" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for casts of small constant literals or <code>mem::align_of</code> results to raw pointers.</p>
<h3>Why is this bad?</h3>
<p>This creates a dangling pointer and is better expressed as
{<code>std</code>, <code>core</code>}<code>::ptr::</code>{<code>dangling</code>, <code>dangling_mut</code>}.</p>
<h3>Example</h3>
<pre><code class="language-rust">let ptr = 4 as *const u32;
let aligned = std::mem::align_of::&lt;u32&gt;() as *const u32;
let mut_ptr: *mut i64 = 8 as *mut _;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let ptr = std::ptr::dangling::&lt;u32&gt;();
let aligned = std::ptr::dangling::&lt;u32&gt;();
let mut_ptr: *mut i64 = std::ptr::dangling_mut();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.88.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_dangling_ptr">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L765">View Source</a></div></div></div></article><article id="manual_div_ceil"><input id="label-manual_div_ceil" type="checkbox"><label for="label-manual_div_ceil"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_div_ceil">manual_div_ceil
<a href="#manual_div_ceil" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for an expression like <code>(x + (y - 1)) / y</code> which is a common manual reimplementation
of <code>x.div_ceil(y)</code>.</p>
<h3>Why is this bad?</h3>
<p>It’s simpler, clearer and more readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: i32 = 7;
let y: i32 = 4;
let div = (x + (y - 1)) / y;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#![feature(int_roundings)]
let x: i32 = 7;
let y: i32 = 4;
let div = x.div_ceil(y);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.83.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_div_ceil">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L867">View Source</a></div></div></div></article><article id="manual_filter"><input id="label-manual_filter" type="checkbox"><label for="label-manual_filter"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_filter">manual_filter
<a href="#manual_filter" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>match</code> which could be implemented using <code>filter</code></p>
<h3>Why is this bad?</h3>
<p>Using the <code>filter</code> method is clearer and more concise.</p>
<h3>Example</h3>
<pre><code class="language-rust">match Some(0) {
    Some(x) =&gt; if x % 2 == 0 {
                    Some(x)
               } else {
                    None
                },
    None =&gt; None,
};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">Some(0).filter(|&amp;x| x % 2 == 0);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.66.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_filter">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L917">View Source</a></div></div></div></article><article id="manual_filter_map"><input id="label-manual_filter_map" type="checkbox"><label for="label-manual_filter_map"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_filter_map">manual_filter_map
<a href="#manual_filter_map" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>_.filter(_).map(_)</code> that can be written more simply
as <code>filter_map(_)</code>.</p>
<h3>Why is this bad?</h3>
<p>Redundant code in the <code>filter</code> and <code>map</code> operations is poor style and
less performant.</p>
<h3>Example</h3>
<pre><code class="language-rust">(0_i32..10)
    .filter(|n| n.checked_add(1).is_some())
    .map(|n| n.checked_add(1).unwrap());
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">(0_i32..10).filter_map(|n| n.checked_add(1));
</code></pre>
<h3>Past names</h3>
<ul>
<li>filter_map</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.51.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_filter_map">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L767">View Source</a></div></div></div></article><article id="manual_find"><input id="label-manual_find" type="checkbox"><label for="label-manual_find"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_find">manual_find
<a href="#manual_find" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for manual implementations of Iterator::find</p>
<h3>Why is this bad?</h3>
<p>It doesn’t affect performance, but using <code>find</code> is shorter and easier to read.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn example(arr: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    for el in arr {
        if el == 1 {
            return Some(el);
        }
    }
    None
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn example(arr: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    arr.into_iter().find(|&amp;el| el == 1)
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.64.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_find">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L590">View Source</a></div></div></div></article><article id="manual_find_map"><input id="label-manual_find_map" type="checkbox"><label for="label-manual_find_map"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_find_map">manual_find_map
<a href="#manual_find_map" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>_.find(_).map(_)</code> that can be written more simply
as <code>find_map(_)</code>.</p>
<h3>Why is this bad?</h3>
<p>Redundant code in the <code>find</code> and <code>map</code> operations is poor style and
less performant.</p>
<h3>Example</h3>
<pre><code class="language-rust">(0_i32..10)
    .find(|n| n.checked_add(1).is_some())
    .map(|n| n.checked_add(1).unwrap());
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">(0_i32..10).find_map(|n| n.checked_add(1));
</code></pre>
<h3>Past names</h3>
<ul>
<li>find_map</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.51.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_find_map">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L793">View Source</a></div></div></div></article><article id="manual_flatten"><input id="label-manual_flatten" type="checkbox"><label for="label-manual_flatten"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_flatten">manual_flatten
<a href="#manual_flatten" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for unnecessary <code>if let</code> usage in a for loop
where only the <code>Some</code> or <code>Ok</code> variant of the iterator element is used.</p>
<h3>Why is this bad?</h3>
<p>It is verbose and can be simplified
by first calling the <code>flatten</code> method on the <code>Iterator</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = vec![Some(1), Some(2), Some(3)];
for n in x {
    if let Some(n) = n {
        println!("{}", n);
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = vec![Some(1), Some(2), Some(3)];
for n in x.into_iter().flatten() {
    println!("{}", n);
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.52.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_flatten">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L522">View Source</a></div></div></div></article><article id="manual_hash_one"><input id="label-manual_hash_one" type="checkbox"><label for="label-manual_hash_one"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_hash_one">manual_hash_one
<a href="#manual_hash_one" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for cases where <a href="https://doc.rust-lang.org/std/hash/trait.BuildHasher.html#method.hash_one"><code>BuildHasher::hash_one</code></a> can be used.</p>
<h3>Why is this bad?</h3>
<p>It is more concise to use the <code>hash_one</code> method.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::hash::{BuildHasher, Hash, Hasher};
use std::collections::hash_map::RandomState;

let s = RandomState::new();
let value = vec![1, 2, 3];

let mut hasher = s.build_hasher();
value.hash(&amp;mut hasher);
let hash = hasher.finish();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::hash::BuildHasher;
use std::collections::hash_map::RandomState;

let s = RandomState::new();
let value = vec![1, 2, 3];

let hash = s.hash_one(&amp;value);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.75.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_hash_one">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_hash_one.rs#L13">View Source</a></div></div></div></article><article id="manual_ignore_case_cmp"><input id="label-manual_ignore_case_cmp" type="checkbox"><label for="label-manual_ignore_case_cmp"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_ignore_case_cmp">manual_ignore_case_cmp
<a href="#manual_ignore_case_cmp" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for manual case-insensitive ASCII comparison.</p>
<h3>Why is this bad?</h3>
<p>The <code>eq_ignore_ascii_case</code> method is faster because it does not allocate
memory for the new strings, and it is more readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn compare(a: &amp;str, b: &amp;str) -&gt; bool {
    a.to_ascii_lowercase() == b.to_ascii_lowercase() || a.to_ascii_lowercase() == "abc"
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn compare(a: &amp;str, b: &amp;str) -&gt; bool {
    a.eq_ignore_ascii_case(b) || a.eq_ignore_ascii_case("abc")
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.84.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_ignore_case_cmp">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_ignore_case_cmp.rs#L16">View Source</a></div></div></div></article><article id="manual_ilog2"><input id="label-manual_ilog2" type="checkbox"><label for="label-manual_ilog2"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_ilog2">manual_ilog2
<a href="#manual_ilog2" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for expressions like <code>N - x.leading_zeros()</code> (where <code>N</code> is one less than bit width
of <code>x</code>) or <code>x.ilog(2)</code>, which are manual reimplementations of <code>x.ilog2()</code></p>
<h3>Why is this bad?</h3>
<p>Manual reimplementations of <code>ilog2</code> increase code complexity for little benefit.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: u32 = 5;
let log = 31 - x.leading_zeros();
let log = x.ilog(2);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x: u32 = 5;
let log = x.ilog2();
let log = x.ilog2();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.93.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_ilog2">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_ilog2.rs#L14">View Source</a></div></div></div></article><article id="manual_inspect"><input id="label-manual_inspect" type="checkbox"><label for="label-manual_inspect"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_inspect">manual_inspect
<a href="#manual_inspect" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for uses of <code>map</code> which return the original item.</p>
<h3>Why is this bad?</h3>
<p><code>inspect</code> is both clearer in intent and shorter.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = Some(0).map(|x| { println!("{x}"); x });
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = Some(0).inspect(|x| println!("{x}"));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.81.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_inspect">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4221">View Source</a></div></div></div></article><article id="manual_instant_elapsed"><input id="label-manual_instant_elapsed" type="checkbox"><label for="label-manual_instant_elapsed"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_instant_elapsed">manual_instant_elapsed
<a href="#manual_instant_elapsed" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Lints subtraction between <code>Instant::now()</code> and another <code>Instant</code>.</p>
<h3>Why is this bad?</h3>
<p>It is easy to accidentally write <code>prev_instant - Instant::now()</code>, which will always be 0ns
as <code>Instant</code> subtraction saturates.</p>
<p><code>prev_instant.elapsed()</code> also more clearly signals intention.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::time::Instant;
let prev_instant = Instant::now();
let duration = Instant::now() - prev_instant;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::time::Instant;
let prev_instant = Instant::now();
let duration = prev_instant.elapsed();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.65.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_instant_elapsed">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/time_subtraction.rs#L13">View Source</a></div></div></div></article><article id="manual_is_ascii_check"><input id="label-manual_is_ascii_check" type="checkbox"><label for="label-manual_is_ascii_check"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_is_ascii_check">manual_is_ascii_check
<a href="#manual_is_ascii_check" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Suggests to use dedicated built-in methods,
<code>is_ascii_(lowercase|uppercase|digit|hexdigit)</code> for checking on corresponding
ascii range</p>
<h3>Why is this bad?</h3>
<p>Using the built-in functions is more readable and makes it
clear that it’s not a specific subset of characters, but all
ASCII (lowercase|uppercase|digit|hexdigit) characters.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn main() {
    assert!(matches!('x', 'a'..='z'));
    assert!(matches!(b'X', b'A'..=b'Z'));
    assert!(matches!('2', '0'..='9'));
    assert!(matches!('x', 'A'..='Z' | 'a'..='z'));
    assert!(matches!('C', '0'..='9' | 'a'..='f' | 'A'..='F'));

    ('0'..='9').contains(&amp;'0');
    ('a'..='z').contains(&amp;'a');
    ('A'..='Z').contains(&amp;'A');
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn main() {
    assert!('x'.is_ascii_lowercase());
    assert!(b'X'.is_ascii_uppercase());
    assert!('2'.is_ascii_digit());
    assert!('x'.is_ascii_alphabetic());
    assert!('C'.is_ascii_hexdigit());

    '0'.is_ascii_digit();
    'a'.is_ascii_lowercase();
    'A'.is_ascii_uppercase();
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.67.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_is_ascii_check">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_is_ascii_check.rs#L17">View Source</a></div></div></div></article><article id="manual_is_finite"><input id="label-manual_is_finite" type="checkbox"><label for="label-manual_is_finite"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_is_finite">manual_is_finite
<a href="#manual_is_finite" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for manual <code>is_finite</code> reimplementations
(i.e., <code>x != &lt;float&gt;::INFINITY &amp;&amp; x != &lt;float&gt;::NEG_INFINITY</code>).</p>
<h3>Why is this bad?</h3>
<p>The method <code>is_finite</code> is shorter and more readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">if x != f32::INFINITY &amp;&amp; x != f32::NEG_INFINITY {}
if x.abs() &lt; f32::INFINITY {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if x.is_finite() {}
if x.is_finite() {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_is_finite">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_float_methods.rs#L39">View Source</a></div></div></div></article><article id="manual_is_infinite"><input id="label-manual_is_infinite" type="checkbox"><label for="label-manual_is_infinite"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_is_infinite">manual_is_infinite
<a href="#manual_is_infinite" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for manual <code>is_infinite</code> reimplementations
(i.e., <code>x == &lt;float&gt;::INFINITY || x == &lt;float&gt;::NEG_INFINITY</code>).</p>
<h3>Why is this bad?</h3>
<p>The method <code>is_infinite</code> is shorter and more readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">if x == f32::INFINITY || x == f32::NEG_INFINITY {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if x.is_infinite() {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_is_infinite">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_float_methods.rs#L16">View Source</a></div></div></div></article><article id="manual_is_multiple_of"><input id="label-manual_is_multiple_of" type="checkbox"><label for="label-manual_is_multiple_of"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_is_multiple_of">manual_is_multiple_of
<a href="#manual_is_multiple_of" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for manual implementation of <code>.is_multiple_of()</code> on
unsigned integer types.</p>
<h3>Why is this bad?</h3>
<p><code>a.is_multiple_of(b)</code> is a clearer way to check for divisibility
of <code>a</code> by <code>b</code>. This expression can never panic.</p>
<h3>Example</h3>
<pre><code class="language-rust">if a % b == 0 {
    println!("{a} is divisible by {b}");
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if a.is_multiple_of(b) {
    println!("{a} is divisible by {b}");
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.90.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_is_multiple_of">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L838">View Source</a></div></div></div></article><article id="manual_is_power_of_two"><input id="label-manual_is_power_of_two" type="checkbox"><label for="label-manual_is_power_of_two"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_is_power_of_two">manual_is_power_of_two
<a href="#manual_is_power_of_two" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for expressions like <code>x.count_ones() == 1</code> or <code>x &amp; (x - 1) == 0</code>, with x and unsigned integer, which may be manual
reimplementations of <code>x.is_power_of_two()</code>.</p>
<h3>Why is this bad?</h3>
<p>Manual reimplementations of <code>is_power_of_two</code> increase code complexity for little benefit.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a: u32 = 4;
let result = a.count_ones() == 1;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a: u32 = 4;
let result = a.is_power_of_two();
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.83.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_is_power_of_two">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_is_power_of_two.rs#L13">View Source</a></div></div></div></article><article id="manual_is_variant_and"><input id="label-manual_is_variant_and" type="checkbox"><label for="label-manual_is_variant_and"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_is_variant_and">manual_is_variant_and
<a href="#manual_is_variant_and" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>option.map(f).unwrap_or_default()</code> and <code>result.map(f).unwrap_or_default()</code> where f is a function or closure that returns the <code>bool</code> type.
Also checks for equality comparisons like <code>option.map(f) == Some(true)</code> and <code>result.map(f) == Ok(true)</code>.</p>
<h3>Why is this bad?</h3>
<p>Readability. These can be written more concisely as <code>option.is_some_and(f)</code> and <code>result.is_ok_and(f)</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">option.map(|a| a &gt; 10).unwrap_or_default();
result.map(|a| a &gt; 10).unwrap_or_default();

option.map(|a| a &gt; 10) == Some(true);
result.map(|a| a &gt; 10) == Ok(true);
option.map(|a| a &gt; 10) != Some(true);
result.map(|a| a &gt; 10) != Ok(true);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">option.is_some_and(|a| a &gt; 10);
result.is_ok_and(|a| a &gt; 10);

option.is_some_and(|a| a &gt; 10);
result.is_ok_and(|a| a &gt; 10);
option.is_none_or(|a| a &gt; 10);
!result.is_ok_and(|a| a &gt; 10);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.77.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_is_variant_and">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3934">View Source</a></div></div></div></article><article id="manual_let_else"><input id="label-manual_let_else" type="checkbox"><label for="label-manual_let_else"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_let_else">manual_let_else
<a href="#manual_let_else" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warn of cases where <code>let...else</code> could be used</p>
<h3>Why is this bad?</h3>
<p><code>let...else</code> provides a standard construct for this pattern
that people can easily recognize. It’s also more compact.</p>
<h3>Example</h3>
<pre><code class="language-rust">let v = if let Some(v) = w { v } else { return };
</code></pre>
<p>Could be written:</p>
<pre><code class="language-rust">let Some(v) = w else { return };
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>matches-for-let-else</code>:  Whether the matches should be considered by the lint, and whether there should
be filtering for common types.</p>
<p>(default: <code>"WellKnownTypes"</code>)</p>
</li>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.67.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_let_else">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_let_else.rs#L18">View Source</a></div></div></div></article><article id="manual_main_separator_str"><input id="label-manual_main_separator_str" type="checkbox"><label for="label-manual_main_separator_str"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_main_separator_str">manual_main_separator_str
<a href="#manual_main_separator_str" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for references on <code>std::path::MAIN_SEPARATOR.to_string()</code> used
to build a <code>&amp;str</code>.</p>
<h3>Why is this bad?</h3>
<p>There exists a <code>std::path::MAIN_SEPARATOR_STR</code> which does not require
an extra memory allocation.</p>
<h3>Example</h3>
<pre><code class="language-rust">let s: &amp;str = &amp;std::path::MAIN_SEPARATOR.to_string();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let s: &amp;str = std::path::MAIN_SEPARATOR_STR;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_main_separator_str">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_main_separator_str.rs#L14">View Source</a></div></div></div></article><article id="manual_map"><input id="label-manual_map" type="checkbox"><label for="label-manual_map"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_map">manual_map
<a href="#manual_map" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>match</code> which could be implemented using <code>map</code></p>
<h3>Why is this bad?</h3>
<p>Using the <code>map</code> method is clearer and more concise.</p>
<h3>Example</h3>
<pre><code class="language-rust">match Some(0) {
    Some(x) =&gt; Some(x + 1),
    None =&gt; None,
};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">Some(0).map(|x| x + 1);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.52.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_map">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L893">View Source</a></div></div></div></article><article id="manual_memcpy"><input id="label-manual_memcpy" type="checkbox"><label for="label-manual_memcpy"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_memcpy">manual_memcpy
<a href="#manual_memcpy" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for for-loops that manually copy items between
slices that could be optimized by having a memcpy.</p>
<h3>Why is this bad?</h3>
<p>It is not as fast as a memcpy.</p>
<h3>Example</h3>
<pre><code class="language-rust">for i in 0..src.len() {
    dst[i + 64] = src[i];
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">dst[64..(src.len() + 64)].clone_from_slice(&amp;src[..]);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_memcpy">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L38">View Source</a></div></div></div></article><article id="manual_midpoint"><input id="label-manual_midpoint" type="checkbox"><label for="label-manual_midpoint"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_midpoint">manual_midpoint
<a href="#manual_midpoint" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for manual implementation of <code>midpoint</code>.</p>
<h3>Why is this bad?</h3>
<p>Using <code>(x + y) / 2</code> might cause an overflow on the intermediate
addition result.</p>
<h3>Example</h3>
<pre><code class="language-rust">let c = (a + 10) / 2;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let c = u32::midpoint(a, 10);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.87.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_midpoint">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L814">View Source</a></div></div></div></article><article id="manual_next_back"><input id="label-manual_next_back" type="checkbox"><label for="label-manual_next_back"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_next_back">manual_next_back
<a href="#manual_next_back" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>.rev().next()</code> on a <code>DoubleEndedIterator</code></p>
<h3>Why is this bad?</h3>
<p><code>.next_back()</code> is cleaner.</p>
<h3>Example</h3>
<pre><code class="language-rust">foo.iter().rev().next();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">foo.iter().next_back();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.71.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_next_back">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3420">View Source</a></div></div></div></article><article id="manual_non_exhaustive"><input id="label-manual_non_exhaustive" type="checkbox"><label for="label-manual_non_exhaustive"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_non_exhaustive">manual_non_exhaustive
<a href="#manual_non_exhaustive" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for manual implementations of the non-exhaustive pattern.</p>
<h3>Why is this bad?</h3>
<p>Using the #[non_exhaustive] attribute expresses better the intent
and allows possible optimizations when applied to enums.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct S {
    pub a: i32,
    pub b: i32,
    _c: (),
}

enum E {
    A,
    B,
    #[doc(hidden)]
    _C,
}

struct T(pub i32, pub i32, ());
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[non_exhaustive]
struct S {
    pub a: i32,
    pub b: i32,
}

#[non_exhaustive]
enum E {
    A,
    B,
}

#[non_exhaustive]
struct T(pub i32, pub i32);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.45.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_non_exhaustive">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_non_exhaustive.rs#L17">View Source</a></div></div></div></article><article id="manual_ok_err"><input id="label-manual_ok_err" type="checkbox"><label for="label-manual_ok_err"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_ok_err">manual_ok_err
<a href="#manual_ok_err" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for manual implementation of <code>.ok()</code> or <code>.err()</code>
on <code>Result</code> values.</p>
<h3>Why is this bad?</h3>
<p>Using <code>.ok()</code> or <code>.err()</code> rather than a <code>match</code> or
<code>if let</code> is less complex and more readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = match func() {
    Ok(v) =&gt; Some(v),
    Err(_) =&gt; None,
};
let b = if let Err(v) = func() {
    Some(v)
} else {
    None
};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a = func().ok();
let b = func().err();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.86.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_ok_err">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L975">View Source</a></div></div></div></article><article id="manual_ok_or"><input id="label-manual_ok_or" type="checkbox"><label for="label-manual_ok_or"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_ok_or">manual_ok_or
<a href="#manual_ok_or" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Finds patterns that reimplement <code>Option::ok_or</code>.</p>
<h3>Why is this bad?</h3>
<p>Concise code helps focusing on behavior instead of boilerplate.</p>
<h3>Examples</h3>
<pre><code class="language-rust">let foo: Option&lt;i32&gt; = None;
foo.map_or(Err("error"), |v| Ok(v));
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let foo: Option&lt;i32&gt; = None;
foo.ok_or("error");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_ok_or">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2699">View Source</a></div></div></div></article><article id="manual_option_as_slice"><input id="label-manual_option_as_slice" type="checkbox"><label for="label-manual_option_as_slice"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_option_as_slice">manual_option_as_slice
<a href="#manual_option_as_slice" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This detects various manual reimplementations of <code>Option::as_slice</code>.</p>
<h3>Why is this bad?</h3>
<p>Those implementations are both more complex than calling <code>as_slice</code>
and unlike that incur a branch, pessimizing performance and leading
to more generated code.</p>
<h3>Example</h3>
<pre><code class="language-rust">_ = opt.as_ref().map_or(&amp;[][..], std::slice::from_ref);
_ = match opt.as_ref() {
    Some(f) =&gt; std::slice::from_ref(f),
    None =&gt; &amp;[],
};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">_ = opt.as_slice();
_ = opt.as_slice();
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.86.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_option_as_slice">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_option_as_slice.rs#L13">View Source</a></div></div></div></article><article id="manual_pattern_char_comparison"><input id="label-manual_pattern_char_comparison" type="checkbox"><label for="label-manual_pattern_char_comparison"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_pattern_char_comparison">manual_pattern_char_comparison
<a href="#manual_pattern_char_comparison" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for manual <code>char</code> comparison in string patterns</p>
<h3>Why is this bad?</h3>
<p>This can be written more concisely using a <code>char</code> or an array of <code>char</code>.
This is more readable and more optimized when comparing to only one <code>char</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">"Hello World!".trim_end_matches(|c| c == '.' || c == ',' || c == '!' || c == '?');
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">"Hello World!".trim_end_matches(['.', ',', '!', '?']);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.81.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_pattern_char_comparison">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/string_patterns.rs#L21">View Source</a></div></div></div></article><article id="manual_range_contains"><input id="label-manual_range_contains" type="checkbox"><label for="label-manual_range_contains"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_range_contains">manual_range_contains
<a href="#manual_range_contains" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for expressions like <code>x &gt;= 3 &amp;&amp; x &lt; 8</code> that could
be more readably expressed as <code>(3..8).contains(x)</code>.</p>
<h3>Why is this bad?</h3>
<p><code>contains</code> expresses the intent better and has less
failure modes (such as fencepost errors or using <code>||</code> instead of <code>&amp;&amp;</code>).</p>
<h3>Example</h3>
<pre><code class="language-rust">// given
let x = 6;

assert!(x &gt;= 3 &amp;&amp; x &lt; 8);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">assert!((3..8).contains(&amp;x));
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_range_contains">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ranges.rs#L140">View Source</a></div></div></div></article><article id="manual_range_patterns"><input id="label-manual_range_patterns" type="checkbox"><label for="label-manual_range_patterns"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_range_patterns">manual_range_patterns
<a href="#manual_range_patterns" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Looks for combined OR patterns that are all contained in a specific range,
e.g. <code>6 | 4 | 5 | 9 | 7 | 8</code> can be rewritten as <code>4..=9</code>.</p>
<h3>Why is this bad?</h3>
<p>Using an explicit range is more concise and easier to read.</p>
<h3>Known issues</h3>
<p>This lint intentionally does not handle numbers greater than <code>i128::MAX</code> for <code>u128</code> literals
in order to support negative numbers.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = 6;
let foo = matches!(x, 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = 6;
let foo = matches!(x, 1..=10);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_range_patterns">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_range_patterns.rs#L11">View Source</a></div></div></div></article><article id="manual_rem_euclid"><input id="label-manual_rem_euclid" type="checkbox"><label for="label-manual_rem_euclid"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_rem_euclid">manual_rem_euclid
<a href="#manual_rem_euclid" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for an expression like <code>((x % 4) + 4) % 4</code> which is a common manual reimplementation
of <code>x.rem_euclid(4)</code>.</p>
<h3>Why is this bad?</h3>
<p>It’s simpler and more readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: i32 = 24;
let rem = ((x % 4) + 4) % 4;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x: i32 = 24;
let rem = x.rem_euclid(4);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.64.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_rem_euclid">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_rem_euclid.rs#L14">View Source</a></div></div></div></article><article id="manual_repeat_n"><input id="label-manual_repeat_n" type="checkbox"><label for="label-manual_repeat_n"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_repeat_n">manual_repeat_n
<a href="#manual_repeat_n" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>repeat().take()</code> that can be replaced with <code>repeat_n()</code>.</p>
<h3>Why is this bad?</h3>
<p>Using <code>repeat_n()</code> is more concise and clearer. Also, <code>repeat_n()</code> is sometimes faster than <code>repeat().take()</code> when the type of the element is non-trivial to clone because the original value can be reused for the last <code>.next()</code> call rather than always cloning.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = std::iter::repeat(10).take(3);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = std::iter::repeat_n(10, 3);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.86.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_repeat_n">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4407">View Source</a></div></div></div></article><article id="manual_retain"><input id="label-manual_retain" type="checkbox"><label for="label-manual_retain"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_retain">manual_retain
<a href="#manual_retain" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for code to be replaced by <code>.retain()</code>.</p>
<h3>Why is this bad?</h3>
<p><code>.retain()</code> is simpler and avoids needless allocation.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut vec = vec![0, 1, 2];
vec = vec.iter().filter(|&amp;x| x % 2 == 0).copied().collect();
vec = vec.into_iter().filter(|x| x % 2 == 0).collect();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut vec = vec![0, 1, 2];
vec.retain(|x| x % 2 == 0);
vec.retain(|x| x % 2 == 0);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.64.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_retain">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_retain.rs#L24">View Source</a></div></div></div></article><article id="manual_rotate"><input id="label-manual_rotate" type="checkbox"><label for="label-manual_rotate"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_rotate">manual_rotate
<a href="#manual_rotate" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>It detects manual bit rotations that could be rewritten using standard
functions <code>rotate_left</code> or <code>rotate_right</code>.</p>
<h3>Why is this bad?</h3>
<p>Calling the function better conveys the intent.</p>
<h3>Known issues</h3>
<p>Currently, the lint only catches shifts by constant amount.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = 12345678_u32;
let _ = (x &gt;&gt; 8) | (x &lt;&lt; 24);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = 12345678_u32;
let _ = x.rotate_right(8);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.81.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_rotate">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_rotate.rs#L12">View Source</a></div></div></div></article><article id="manual_saturating_arithmetic"><input id="label-manual_saturating_arithmetic" type="checkbox"><label for="label-manual_saturating_arithmetic"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_saturating_arithmetic">manual_saturating_arithmetic
<a href="#manual_saturating_arithmetic" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>.checked_add/sub(x).unwrap_or(MAX/MIN)</code>.</p>
<h3>Why is this bad?</h3>
<p>These can be written simply with <code>saturating_add/sub</code> methods.</p>
<h3>Example</h3>
<pre><code class="language-rust">let add = x.checked_add(y).unwrap_or(u32::MAX);
let sub = x.checked_sub(y).unwrap_or(u32::MIN);
</code></pre>
<p>can be written using dedicated methods for saturating addition/subtraction as:</p>
<pre><code class="language-rust">let add = x.saturating_add(y);
let sub = x.saturating_sub(y);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.39.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_saturating_arithmetic">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1685">View Source</a></div></div></div></article><article id="manual_slice_fill"><input id="label-manual_slice_fill" type="checkbox"><label for="label-manual_slice_fill"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_slice_fill">manual_slice_fill
<a href="#manual_slice_fill" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for manually filling a slice with a value.</p>
<h3>Why is this bad?</h3>
<p>Using the <code>fill</code> method is more idiomatic and concise.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut some_slice = [1, 2, 3, 4, 5];
for i in 0..some_slice.len() {
    some_slice[i] = 0;
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut some_slice = [1, 2, 3, 4, 5];
some_slice.fill(0);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.86.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_slice_fill">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L720">View Source</a></div></div></div></article><article id="manual_slice_size_calculation"><input id="label-manual_slice_size_calculation" type="checkbox"><label for="label-manual_slice_size_calculation"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_slice_size_calculation">manual_slice_size_calculation
<a href="#manual_slice_size_calculation" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>When <code>a</code> is <code>&amp;[T]</code>, detect <code>a.len() * size_of::&lt;T&gt;()</code> and suggest <code>size_of_val(a)</code>
instead.</p>
<h3>Why is this better?</h3>
<ul>
<li>Shorter to write</li>
<li>Removes the need for the human and the compiler to worry about overflow in the
multiplication</li>
<li>Potentially faster at runtime as rust emits special no-wrapping flags when it
calculates the byte length</li>
<li>Less turbofishing</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">let newlen = data.len() * size_of::&lt;i32&gt;();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let newlen = size_of_val(data);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_slice_size_calculation">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_slice_size_calculation.rs#L14">View Source</a></div></div></div></article><article id="manual_split_once"><input id="label-manual_split_once" type="checkbox"><label for="label-manual_split_once"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_split_once">manual_split_once
<a href="#manual_split_once" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>str::splitn(2, _)</code></p>
<h3>Why is this bad?</h3>
<p><code>split_once</code> is both clearer in intent and slightly more efficient.</p>
<h3>Example</h3>
<pre><code class="language-rust">let s = "key=value=add";
let (key, value) = s.splitn(2, '=').next_tuple()?;
let value = s.splitn(2, '=').nth(1)?;

let mut parts = s.splitn(2, '=');
let key = parts.next()?;
let value = parts.next()?;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let s = "key=value=add";
let (key, value) = s.split_once('=')?;
let value = s.split_once('=')?.1;

let (key, value) = s.split_once('=')?;
</code></pre>
<h3>Limitations</h3>
<p>The multiple statement variant currently only detects <code>iter.next()?</code>/<code>iter.next().unwrap()</code>
in two separate <code>let</code> statements that immediately follow the <code>splitn()</code></p>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.57.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_split_once">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2281">View Source</a></div></div></div></article><article id="manual_str_repeat"><input id="label-manual_str_repeat" type="checkbox"><label for="label-manual_str_repeat"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_str_repeat">manual_str_repeat
<a href="#manual_str_repeat" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for manual implementations of <code>str::repeat</code></p>
<h3>Why is this bad?</h3>
<p>These are both harder to read, as well as less performant.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: String = std::iter::repeat('x').take(10).collect();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x: String = "x".repeat(10);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.54.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_str_repeat">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2259">View Source</a></div></div></div></article><article id="manual_string_new"><input id="label-manual_string_new" type="checkbox"><label for="label-manual_string_new"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_string_new">manual_string_new
<a href="#manual_string_new" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>""</code> to create a <code>String</code>, such as <code>"".to_string()</code>, <code>"".to_owned()</code>,
<code>String::from("")</code> and others.</p>
<h3>Why is this bad?</h3>
<p>Different ways of creating an empty string makes your code less standardized, which can
be confusing.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = "".to_string();
let b: String = "".into();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a = String::new();
let b = String::new();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.65.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_string_new">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_string_new.rs#L11">View Source</a></div></div></div></article><article id="manual_strip"><input id="label-manual_strip" type="checkbox"><label for="label-manual_strip"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_strip">manual_strip
<a href="#manual_strip" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Suggests using <code>strip_{prefix,suffix}</code> over <code>str::{starts,ends}_with</code> and slicing using
the pattern’s length.</p>
<h3>Why is this bad?</h3>
<p>Using <code>str:strip_{prefix,suffix}</code> is safer and may have better performance as there is no
slicing which may panic and the compiler does not need to insert this panic code. It is
also sometimes more readable as it removes the need for duplicating or storing the pattern
used by <code>str::{starts,ends}_with</code> and in the slicing.</p>
<h3>Example</h3>
<pre><code class="language-rust">let s = "hello, world!";
if s.starts_with("hello, ") {
    assert_eq!(s["hello, ".len()..].to_uppercase(), "WORLD!");
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let s = "hello, world!";
if let Some(end) = s.strip_prefix("hello, ") {
    assert_eq!(end.to_uppercase(), "WORLD!");
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.48.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_strip">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/manual_strip.rs#L22">View Source</a></div></div></div></article><article id="manual_swap"><input id="label-manual_swap" type="checkbox"><label for="label-manual_swap"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_swap">manual_swap
<a href="#manual_swap" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for manual swapping.</p>
<p>Note that the lint will not be emitted in const blocks, as the suggestion would not be applicable.</p>
<h3>Why is this bad?</h3>
<p>The <code>std::mem::swap</code> function exposes the intent better
without deinitializing or copying either variable.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut a = 42;
let mut b = 1337;

let t = b;
b = a;
a = t;
</code></pre>
<p>Use std::mem::swap():</p>
<pre><code class="language-rust">let mut a = 1;
let mut b = 2;
std::mem::swap(&amp;mut a, &amp;mut b);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_swap">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/swap.rs#L21">View Source</a></div></div></div></article><article id="manual_try_fold"><input id="label-manual_try_fold" type="checkbox"><label for="label-manual_try_fold"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_try_fold">manual_try_fold
<a href="#manual_try_fold" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>Iterator::fold</code> with a type that implements <code>Try</code>.</p>
<h3>Why is this bad?</h3>
<p>The code should use <code>try_fold</code> instead, which short-circuits on failure, thus opening the
door for additional optimizations not possible with <code>fold</code> as rustc can guarantee the
function is never called on <code>None</code>, <code>Err</code>, etc., alleviating otherwise necessary checks. It’s
also slightly more idiomatic.</p>
<h3>Known issues</h3>
<p>This lint doesn’t take into account whether a function does something on the failure case,
i.e., whether short-circuiting will affect behavior. Refactoring to <code>try_fold</code> is not
desirable in those cases.</p>
<h3>Example</h3>
<pre><code class="language-rust">vec![1, 2, 3].iter().fold(Some(0i32), |sum, i| sum?.checked_add(*i));
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">vec![1, 2, 3].iter().try_fold(0i32, |sum, i| sum.checked_add(*i));
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_try_fold">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3479">View Source</a></div></div></div></article><article id="manual_unwrap_or"><input id="label-manual_unwrap_or" type="checkbox"><label for="label-manual_unwrap_or"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_unwrap_or">manual_unwrap_or
<a href="#manual_unwrap_or" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Finds patterns that reimplement <code>Option::unwrap_or</code> or <code>Result::unwrap_or</code>.</p>
<h3>Why is this bad?</h3>
<p>Concise code helps focusing on behavior instead of boilerplate.</p>
<h3>Example</h3>
<pre><code class="language-rust">let foo: Option&lt;i32&gt; = None;
match foo {
    Some(v) =&gt; v,
    None =&gt; 1,
};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let foo: Option&lt;i32&gt; = None;
foo.unwrap_or(1);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_unwrap_or">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L697">View Source</a></div></div></div></article><article id="manual_unwrap_or_default"><input id="label-manual_unwrap_or_default" type="checkbox"><label for="label-manual_unwrap_or_default"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_unwrap_or_default">manual_unwrap_or_default
<a href="#manual_unwrap_or_default" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks if a <code>match</code> or <code>if let</code> expression can be simplified using
<code>.unwrap_or_default()</code>.</p>
<h3>Why is this bad?</h3>
<p>It can be done in one call with <code>.unwrap_or_default()</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: Option&lt;String&gt; = Some(String::new());
let y: String = match x {
    Some(v) =&gt; v,
    None =&gt; String::new(),
};

let x: Option&lt;Vec&lt;String&gt;&gt; = Some(Vec::new());
let y: Vec&lt;String&gt; = if let Some(v) = x {
    v
} else {
    Vec::new()
};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x: Option&lt;String&gt; = Some(String::new());
let y: String = x.unwrap_or_default();

let x: Option&lt;Vec&lt;String&gt;&gt; = Some(Vec::new());
let y: Vec&lt;String&gt; = x.unwrap_or_default();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.79.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_unwrap_or_default">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L724">View Source</a></div></div></div></article><article id="manual_while_let_some"><input id="label-manual_while_let_some" type="checkbox"><label for="label-manual_while_let_some"><h2 class="lint-title"><div class="panel-title-name" id="lint-manual_while_let_some">manual_while_let_some
<a href="#manual_while_let_some" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Looks for loops that check for emptiness of a <code>Vec</code> in the condition and pop an element
in the body as a separate operation.</p>
<h3>Why is this bad?</h3>
<p>Such loops can be written in a more idiomatic way by using a while-let loop and directly
pattern matching on the return value of <code>Vec::pop()</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut numbers = vec![1, 2, 3, 4, 5];
while !numbers.is_empty() {
    let number = numbers.pop().unwrap();
    // use `number`
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut numbers = vec![1, 2, 3, 4, 5];
while let Some(number) = numbers.pop() {
    // use `number`
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.71.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+manual_while_let_some">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L648">View Source</a></div></div></div></article><article id="many_single_char_names"><input id="label-many_single_char_names" type="checkbox"><label for="label-many_single_char_names"><h2 class="lint-title"><div class="panel-title-name" id="lint-many_single_char_names">many_single_char_names
<a href="#many_single_char_names" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for too many variables whose name consists of a
single character.</p>
<h3>Why is this bad?</h3>
<p>It’s hard to memorize what a variable means without a
descriptive name.</p>
<h3>Example</h3>
<pre><code class="language-rust">let (a, b, c, d, e, f, g) = (...);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>single-char-binding-names-threshold</code>:  The maximum number of single char bindings a scope may have</p>
<p>(default: <code>4</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+many_single_char_names">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/non_expressive_names.rs#L36">View Source</a></div></div></div></article><article id="map_all_any_identity"><input id="label-map_all_any_identity" type="checkbox"><label for="label-map_all_any_identity"><h2 class="lint-title"><div class="panel-title-name" id="lint-map_all_any_identity">map_all_any_identity
<a href="#map_all_any_identity" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.map(…)</code>, followed by <code>.all(identity)</code> or <code>.any(identity)</code>.</p>
<h3>Why is this bad?</h3>
<p>The <code>.all(…)</code> or <code>.any(…)</code> methods can be called directly in place of <code>.map(…)</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let e1 = v.iter().map(|s| s.is_empty()).all(|a| a);
let e2 = v.iter().map(|s| s.is_empty()).any(std::convert::identity);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let e1 = v.iter().all(|s| s.is_empty());
let e2 = v.iter().any(|s| s.is_empty());
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.84.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+map_all_any_identity">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4295">View Source</a></div></div></div></article><article id="map_clone"><input id="label-map_clone" type="checkbox"><label for="label-map_clone"><h2 class="lint-title"><div class="panel-title-name" id="lint-map_clone">map_clone
<a href="#map_clone" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>map(|x| x.clone())</code> or
dereferencing closures for <code>Copy</code> types, on <code>Iterator</code> or <code>Option</code>,
and suggests <code>cloned()</code> or <code>copied()</code> instead</p>
<h3>Why is this bad?</h3>
<p>Readability, this can be written more concisely</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = vec![42, 43];
let y = x.iter();
let z = y.map(|i| *i);
</code></pre>
<p>The correct use would be:</p>
<pre><code class="language-rust">let x = vec![42, 43];
let y = x.iter();
let z = y.cloned();
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+map_clone">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2725">View Source</a></div></div></div></article><article id="map_collect_result_unit"><input id="label-map_collect_result_unit" type="checkbox"><label for="label-map_collect_result_unit"><h2 class="lint-title"><div class="panel-title-name" id="lint-map_collect_result_unit">map_collect_result_unit
<a href="#map_collect_result_unit" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>_.map(_).collect::&lt;Result&lt;(), _&gt;()</code>.</p>
<h3>Why is this bad?</h3>
<p>Using <code>try_for_each</code> instead is more readable and idiomatic.</p>
<h3>Example</h3>
<pre><code class="language-rust">(0..3).map(|t| Err(t)).collect::&lt;Result&lt;(), _&gt;&gt;();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">(0..3).try_for_each(|t| Err(t));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+map_collect_result_unit">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1964">View Source</a></div></div></div></article><article id="map_entry"><input id="label-map_entry" type="checkbox"><label for="label-map_entry"><h2 class="lint-title"><div class="panel-title-name" id="lint-map_entry">map_entry
<a href="#map_entry" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>contains_key</code> + <code>insert</code> on <code>HashMap</code>
or <code>BTreeMap</code>.</p>
<h3>Why is this bad?</h3>
<p>Using <code>entry</code> is more efficient.</p>
<h3>Known problems</h3>
<p>The suggestion may have type inference errors in some cases. e.g.</p>
<pre><code class="language-rust">let mut map = std::collections::HashMap::new();
let _ = if !map.contains_key(&amp;0) {
    map.insert(0, 0)
} else {
    None
};
</code></pre>
<h3>Example</h3>
<pre><code class="language-rust">if !map.contains_key(&amp;k) {
    map.insert(k, v);
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">map.entry(k).or_insert(v);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+map_entry">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/entry.rs#L20">View Source</a></div></div></div></article><article id="map_err_ignore"><input id="label-map_err_ignore" type="checkbox"><label for="label-map_err_ignore"><h2 class="lint-title"><div class="panel-title-name" id="lint-map_err_ignore">map_err_ignore
<a href="#map_err_ignore" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for instances of <code>map_err(|_| Some::Enum)</code></p>
<h3>Why restrict this?</h3>
<p>This <code>map_err</code> throws away the original error rather than allowing the enum to
contain and report the cause of the error.</p>
<h3>Example</h3>
<p>Before:</p>
<pre><code class="language-rust">use std::fmt;

#[derive(Debug)]
enum Error {
    Indivisible,
    Remainder(u8),
}

impl fmt::Display for Error {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            Error::Indivisible =&gt; write!(f, "could not divide input by three"),
            Error::Remainder(remainder) =&gt; write!(
                f,
                "input is not divisible by three, remainder = {}",
                remainder
            ),
        }
    }
}

impl std::error::Error for Error {}

fn divisible_by_3(input: &amp;str) -&gt; Result&lt;(), Error&gt; {
    input
        .parse::&lt;i32&gt;()
        .map_err(|_| Error::Indivisible)
        .map(|v| v % 3)
        .and_then(|remainder| {
            if remainder == 0 {
                Ok(())
            } else {
                Err(Error::Remainder(remainder as u8))
            }
        })
}
</code></pre>
<p>After:</p>
<pre><code class="language-rust">use std::{fmt, num::ParseIntError};

#[derive(Debug)]
enum Error {
    Indivisible(ParseIntError),
    Remainder(u8),
}

impl fmt::Display for Error {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            Error::Indivisible(_) =&gt; write!(f, "could not divide input by three"),
            Error::Remainder(remainder) =&gt; write!(
                f,
                "input is not divisible by three, remainder = {}",
                remainder
            ),
        }
    }
}

impl std::error::Error for Error {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn std::error::Error + 'static)&gt; {
        match self {
            Error::Indivisible(source) =&gt; Some(source),
            _ =&gt; None,
        }
    }
}

fn divisible_by_3(input: &amp;str) -&gt; Result&lt;(), Error&gt; {
    input
        .parse::&lt;i32&gt;()
        .map_err(Error::Indivisible)
        .map(|v| v % 3)
        .and_then(|remainder| {
            if remainder == 0 {
                Ok(())
            } else {
                Err(Error::Remainder(remainder as u8))
            }
        })
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.48.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+map_err_ignore">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2754">View Source</a></div></div></div></article><article id="map_flatten"><input id="label-map_flatten" type="checkbox"><label for="label-map_flatten"><h2 class="lint-title"><div class="panel-title-name" id="lint-map_flatten">map_flatten
<a href="#map_flatten" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>_.map(_).flatten(_)</code> on <code>Iterator</code> and <code>Option</code></p>
<h3>Why is this bad?</h3>
<p>Readability, this can be written more concisely as
<code>_.flat_map(_)</code> for <code>Iterator</code> or <code>_.and_then(_)</code> for <code>Option</code></p>
<h3>Example</h3>
<pre><code class="language-rust">let vec = vec![vec![1]];
let opt = Some(5);

vec.iter().map(|x| x.iter()).flatten();
opt.map(|x| Some(x * 2)).flatten();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">vec.iter().flat_map(|x| x.iter());
opt.and_then(|x| Some(x * 2));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.31.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+map_flatten">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L737">View Source</a></div></div></div></article><article id="map_identity"><input id="label-map_identity" type="checkbox"><label for="label-map_identity"><h2 class="lint-title"><div class="panel-title-name" id="lint-map_identity">map_identity
<a href="#map_identity" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for instances of <code>map(f)</code> where <code>f</code> is the identity function.</p>
<h3>Why is this bad?</h3>
<p>It can be written more concisely without the call to <code>map</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = [1, 2, 3];
let y: Vec&lt;_&gt; = x.iter().map(|x| x).map(|x| 2*x).collect();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = [1, 2, 3];
let y: Vec&lt;_&gt; = x.iter().map(|x| 2*x).collect();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.47.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+map_identity">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2079">View Source</a></div></div></div></article><article id="map_unwrap_or"><input id="label-map_unwrap_or" type="checkbox"><label for="label-map_unwrap_or"><h2 class="lint-title"><div class="panel-title-name" id="lint-map_unwrap_or">map_unwrap_or
<a href="#map_unwrap_or" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>option.map(_).unwrap_or(_)</code> or <code>option.map(_).unwrap_or_else(_)</code> or
<code>result.map(_).unwrap_or_else(_)</code>.</p>
<h3>Why is this bad?</h3>
<p>Readability, these can be written more concisely (resp.) as
<code>option.map_or(_, _)</code>, <code>option.map_or_else(_, _)</code> and <code>result.map_or_else(_, _)</code>.</p>
<h3>Known problems</h3>
<p>The order of the arguments is not in execution order</p>
<h3>Examples</h3>
<pre><code class="language-rust">option.map(|a| a + 1).unwrap_or(0);
option.map(|a| a &gt; 10).unwrap_or(false);
result.map(|a| a + 1).unwrap_or_else(some_function);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">option.map_or(0, |a| a + 1);
option.is_some_and(|a| a &gt; 10);
result.map_or_else(some_function, |a| a + 1);
</code></pre>
<h3>Past names</h3>
<ul>
<li>option_map_unwrap_or</li>
<li>option_map_unwrap_or_else</li>
<li>result_map_unwrap_or_else</li>
</ul>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.45.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+map_unwrap_or">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L565">View Source</a></div></div></div></article><article id="map_with_unused_argument_over_ranges"><input id="label-map_with_unused_argument_over_ranges" type="checkbox"><label for="label-map_with_unused_argument_over_ranges"><h2 class="lint-title"><div class="panel-title-name" id="lint-map_with_unused_argument_over_ranges">map_with_unused_argument_over_ranges
<a href="#map_with_unused_argument_over_ranges" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>Iterator::map</code> over ranges without using the parameter which
could be more clearly expressed using <code>std::iter::repeat(...).take(...)</code>
or <code>std::iter::repeat_n</code>.</p>
<h3>Why is this bad?</h3>
<p>It expresses the intent more clearly to <code>take</code> the correct number of times
from a generating function than to apply a closure to each number in a
range only to discard them.</p>
<h3>Example</h3>
<pre><code class="language-rust">let random_numbers : Vec&lt;_&gt; = (0..10).map(|_| { 3 + 1 }).collect();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let f : Vec&lt;_&gt; = std::iter::repeat( 3 + 1 ).take(10).collect();
</code></pre>
<h3>Known Issues</h3>
<p>This lint may suggest replacing a <code>Map&lt;Range&gt;</code> with a <code>Take&lt;RepeatWith&gt;</code>.
The former implements some traits that the latter does not, such as
<code>DoubleEndedIterator</code>.</p>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.84.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+map_with_unused_argument_over_ranges">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4320">View Source</a></div></div></div></article><article id="match_as_ref"><input id="label-match_as_ref" type="checkbox"><label for="label-match_as_ref"><h2 class="lint-title"><div class="panel-title-name" id="lint-match_as_ref">match_as_ref
<a href="#match_as_ref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for match which is used to add a reference to an
<code>Option</code> value.</p>
<h3>Why is this bad?</h3>
<p>Using <code>as_ref()</code> or <code>as_mut()</code> instead is shorter.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: Option&lt;()&gt; = None;

let r: Option&lt;&amp;()&gt; = match x {
    None =&gt; None,
    Some(ref v) =&gt; Some(v),
};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x: Option&lt;()&gt; = None;

let r: Option&lt;&amp;()&gt; = x.as_ref();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+match_as_ref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L231">View Source</a></div></div></div></article><article id="match_bool"><input id="label-match_bool" type="checkbox"><label for="label-match_bool"><h2 class="lint-title"><div class="panel-title-name" id="lint-match_bool">match_bool
<a href="#match_bool" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for matches where match expression is a <code>bool</code>. It
suggests to replace the expression with an <code>if...else</code> block.</p>
<h3>Why is this bad?</h3>
<p>It makes the code less readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">let condition: bool = true;
match condition {
    true =&gt; foo(),
    false =&gt; bar(),
}
</code></pre>
<p>Use if/else instead:</p>
<pre><code class="language-rust">let condition: bool = true;
if condition {
    foo();
} else {
    bar();
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+match_bool">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L150">View Source</a></div></div></div></article><article id="match_like_matches_macro"><input id="label-match_like_matches_macro" type="checkbox"><label for="label-match_like_matches_macro"><h2 class="lint-title"><div class="panel-title-name" id="lint-match_like_matches_macro">match_like_matches_macro
<a href="#match_like_matches_macro" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>match</code>  or <code>if let</code> expressions producing a
<code>bool</code> that could be written using <code>matches!</code></p>
<h3>Why is this bad?</h3>
<p>Readability and needless complexity.</p>
<h3>Known problems</h3>
<p>This lint falsely triggers, if there are arms with
<code>cfg</code> attributes that remove an arm evaluating to <code>false</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = Some(5);

let a = match x {
    Some(0) =&gt; true,
    _ =&gt; false,
};

let a = if let Some(0) = x {
    true
} else {
    false
};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = Some(5);
let a = matches!(x, Some(0));
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.47.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+match_like_matches_macro">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L534">View Source</a></div></div></div></article><article id="match_on_vec_items"><input id="label-match_on_vec_items" type="checkbox"><label for="label-match_on_vec_items"><h2 class="lint-title"><div class="panel-title-name" id="lint-match_on_vec_items">match_on_vec_items
<a href="#match_on_vec_items" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p><code>clippy::indexing_slicing</code> covers indexing and slicing on <code>Vec&lt;_&gt;</code>.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">1.88.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+match_on_vec_items">Related Issues</a></div></div></div></article><article id="match_overlapping_arm"><input id="label-match_overlapping_arm" type="checkbox"><label for="label-match_overlapping_arm"><h2 class="lint-title"><div class="panel-title-name" id="lint-match_overlapping_arm">match_overlapping_arm
<a href="#match_overlapping_arm" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for overlapping match arms.</p>
<h3>Why is this bad?</h3>
<p>It is likely to be an error and if not, makes the code
less obvious.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = 5;
match x {
    1..=10 =&gt; println!("1 ... 10"),
    5..=15 =&gt; println!("5 ... 15"),
    _ =&gt; (),
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+match_overlapping_arm">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L185">View Source</a></div></div></div></article><article id="match_ref_pats"><input id="label-match_ref_pats" type="checkbox"><label for="label-match_ref_pats"><h2 class="lint-title"><div class="panel-title-name" id="lint-match_ref_pats">match_ref_pats
<a href="#match_ref_pats" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for matches where all arms match a reference,
suggesting to remove the reference and deref the matched expression
instead. It also checks for <code>if let &amp;foo = bar</code> blocks.</p>
<h3>Why is this bad?</h3>
<p>It just makes the code less readable. That reference
destructuring adds nothing to the code.</p>
<h3>Example</h3>
<pre><code class="language-rust">match x {
    &amp;A(ref y) =&gt; foo(y),
    &amp;B =&gt; bar(),
    _ =&gt; frob(&amp;x),
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">match *x {
    A(ref y) =&gt; foo(y),
    B =&gt; bar(),
    _ =&gt; frob(x),
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+match_ref_pats">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L117">View Source</a></div></div></div></article><article id="match_result_ok"><input id="label-match_result_ok" type="checkbox"><label for="label-match_result_ok"><h2 class="lint-title"><div class="panel-title-name" id="lint-match_result_ok">match_result_ok
<a href="#match_result_ok" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for unnecessary <code>ok()</code> in <code>while let</code>.</p>
<h3>Why is this bad?</h3>
<p>Calling <code>ok()</code> in <code>while let</code> is unnecessary, instead match
on <code>Ok(pat)</code></p>
<h3>Example</h3>
<pre><code class="language-rust">while let Some(value) = iter.next().ok() {
    vec.push(value)
}

if let Some(value) = iter.next().ok() {
    vec.push(value)
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">while let Ok(value) = iter.next() {
    vec.push(value)
}

if let Ok(value) = iter.next() {
       vec.push(value)
}
</code></pre>
<h3>Past names</h3>
<ul>
<li>if_let_some_result</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.57.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+match_result_ok">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/match_result_ok.rs#L10">View Source</a></div></div></div></article><article id="match_same_arms"><input id="label-match_same_arms" type="checkbox"><label for="label-match_same_arms"><h2 class="lint-title"><div class="panel-title-name" id="lint-match_same_arms">match_same_arms
<a href="#match_same_arms" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>match</code> with identical arm bodies.</p>
<p>Note: Does not lint on wildcards if the <code>non_exhaustive_omitted_patterns_lint</code> feature is
enabled and disallowed.</p>
<h3>Why is this bad?</h3>
<p>This is probably a copy &amp; paste error. If arm bodies
are the same on purpose, you can factor them
<a href="https://doc.rust-lang.org/book/patterns.html#multiple-patterns">using <code>|</code></a>.</p>
<h3>Example</h3>
<pre><code class="language-rust">match foo {
    Bar =&gt; bar(),
    Quz =&gt; quz(),
    Baz =&gt; bar(), // &lt;= oops
}
</code></pre>
<p>This should probably be</p>
<pre><code class="language-rust">match foo {
    Bar =&gt; bar(),
    Quz =&gt; quz(),
    Baz =&gt; baz(), // &lt;= fixed
}
</code></pre>
<p>or if the original code was not a typo:</p>
<pre><code class="language-rust">match foo {
    Bar | Baz =&gt; bar(), // &lt;= shows the intent better
    Quz =&gt; quz(),
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+match_same_arms">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L573">View Source</a></div></div></div></article><article id="match_single_binding"><input id="label-match_single_binding" type="checkbox"><label for="label-match_single_binding"><h2 class="lint-title"><div class="panel-title-name" id="lint-match_single_binding">match_single_binding
<a href="#match_single_binding" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for useless match that binds to only one value.</p>
<h3>Why is this bad?</h3>
<p>Readability and needless complexity.</p>
<h3>Known problems</h3>
<p>Suggested replacements may be incorrect when <code>match</code>
is actually binding temporary value, bringing a ‘dropped while borrowed’ error.</p>
<h3>Example</h3>
<pre><code class="language-rust">match (a, b) {
    (c, d) =&gt; {
        // useless match
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let (c, d) = (a, b);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.43.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+match_single_binding">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L402">View Source</a></div></div></div></article><article id="match_str_case_mismatch"><input id="label-match_str_case_mismatch" type="checkbox"><label for="label-match_str_case_mismatch"><h2 class="lint-title"><div class="panel-title-name" id="lint-match_str_case_mismatch">match_str_case_mismatch
<a href="#match_str_case_mismatch" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>match</code> expressions modifying the case of a string with non-compliant arms</p>
<h3>Why is this bad?</h3>
<p>The arm is unreachable, which is likely a mistake</p>
<h3>Example</h3>
<pre><code class="language-rust">match &amp;*text.to_ascii_lowercase() {
    "foo" =&gt; {},
    "Bar" =&gt; {},
    _ =&gt; {},
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">match &amp;*text.to_ascii_lowercase() {
    "foo" =&gt; {},
    "bar" =&gt; {},
    _ =&gt; {},
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.58.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+match_str_case_mismatch">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L761">View Source</a></div></div></div></article><article id="match_wild_err_arm"><input id="label-match_wild_err_arm" type="checkbox"><label for="label-match_wild_err_arm"><h2 class="lint-title"><div class="panel-title-name" id="lint-match_wild_err_arm">match_wild_err_arm
<a href="#match_wild_err_arm" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for arm which matches all errors with <code>Err(_)</code>
and take drastic actions like <code>panic!</code>.</p>
<h3>Why is this bad?</h3>
<p>It is generally a bad practice, similar to
catching all exceptions in java with <code>catch(Exception)</code></p>
<h3>Example</h3>
<pre><code class="language-rust">let x: Result&lt;i32, &amp;str&gt; = Ok(3);
match x {
    Ok(_) =&gt; println!("ok"),
    Err(_) =&gt; panic!("err"),
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+match_wild_err_arm">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L208">View Source</a></div></div></div></article><article id="match_wildcard_for_single_variants"><input id="label-match_wildcard_for_single_variants" type="checkbox"><label for="label-match_wildcard_for_single_variants"><h2 class="lint-title"><div class="panel-title-name" id="lint-match_wildcard_for_single_variants">match_wildcard_for_single_variants
<a href="#match_wildcard_for_single_variants" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for wildcard enum matches for a single variant.</p>
<h3>Why is this bad?</h3>
<p>New enum variants added by library updates can be missed.</p>
<h3>Known problems</h3>
<p>Suggested replacements may not use correct path to enum
if it’s not present in the current scope.</p>
<h3>Example</h3>
<pre><code class="language-rust">match x {
    Foo::A =&gt; {},
    Foo::B =&gt; {},
    _ =&gt; {},
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">match x {
    Foo::A =&gt; {},
    Foo::B =&gt; {},
    Foo::C =&gt; {},
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.45.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+match_wildcard_for_single_variants">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L297">View Source</a></div></div></div></article><article id="maybe_infinite_iter"><input id="label-maybe_infinite_iter" type="checkbox"><label for="label-maybe_infinite_iter"><h2 class="lint-title"><div class="panel-title-name" id="lint-maybe_infinite_iter">maybe_infinite_iter
<a href="#maybe_infinite_iter" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for iteration that may be infinite.</p>
<h3>Why is this bad?</h3>
<p>While there may be places where this is acceptable
(e.g., in event streams), in most cases this is simply an error.</p>
<h3>Known problems</h3>
<p>The code may have a condition to stop iteration, but
this lint is not clever enough to analyze it.</p>
<h3>Example</h3>
<pre><code class="language-rust">let infinite_iter = 0..;
[0..].iter().zip(infinite_iter.take_while(|x| *x &gt; 5));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+maybe_infinite_iter">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/infinite_iter.rs#L30">View Source</a></div></div></div></article><article id="mem_forget"><input id="label-mem_forget" type="checkbox"><label for="label-mem_forget"><h2 class="lint-title"><div class="panel-title-name" id="lint-mem_forget">mem_forget
<a href="#mem_forget" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>std::mem::forget(t)</code> where <code>t</code> is
<code>Drop</code> or has a field that implements <code>Drop</code>.</p>
<h3>Why restrict this?</h3>
<p><code>std::mem::forget(t)</code> prevents <code>t</code> from running its destructor, possibly causing leaks.
It is not possible to detect all means of creating leaks, but it may be desirable to
prohibit the simple ones.</p>
<h3>Example</h3>
<pre><code class="language-rust">mem::forget(Rc::new(55))
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mem_forget">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/drop_forget_ref.rs#L51">View Source</a></div></div></div></article><article id="mem_replace_option_with_none"><input id="label-mem_replace_option_with_none" type="checkbox"><label for="label-mem_replace_option_with_none"><h2 class="lint-title"><div class="panel-title-name" id="lint-mem_replace_option_with_none">mem_replace_option_with_none
<a href="#mem_replace_option_with_none" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>mem::replace()</code> on an <code>Option</code> with
<code>None</code>.</p>
<h3>Why is this bad?</h3>
<p><code>Option</code> already has the method <code>take()</code> for
taking its current value (Some(..) or None) and replacing it with
<code>None</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::mem;

let mut an_option = Some(0);
let replaced = mem::replace(&amp;mut an_option, None);
</code></pre>
<p>Is better expressed with:</p>
<pre><code class="language-rust">let mut an_option = Some(0);
let taken = an_option.take();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.31.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mem_replace_option_with_none">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/mem_replace.rs#L18">View Source</a></div></div></div></article><article id="mem_replace_option_with_some"><input id="label-mem_replace_option_with_some" type="checkbox"><label for="label-mem_replace_option_with_some"><h2 class="lint-title"><div class="panel-title-name" id="lint-mem_replace_option_with_some">mem_replace_option_with_some
<a href="#mem_replace_option_with_some" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>mem::replace()</code> on an <code>Option</code> with <code>Some(…)</code>.</p>
<h3>Why is this bad?</h3>
<p><code>Option</code> already has the method <code>replace()</code> for
taking its current value (Some(…) or None) and replacing it with
<code>Some(…)</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut an_option = Some(0);
let replaced = std::mem::replace(&amp;mut an_option, Some(1));
</code></pre>
<p>Is better expressed with:</p>
<pre><code class="language-rust">let mut an_option = Some(0);
let taken = an_option.replace(1);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.87.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mem_replace_option_with_some">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/mem_replace.rs#L46">View Source</a></div></div></div></article><article id="mem_replace_with_default"><input id="label-mem_replace_with_default" type="checkbox"><label for="label-mem_replace_with_default"><h2 class="lint-title"><div class="panel-title-name" id="lint-mem_replace_with_default">mem_replace_with_default
<a href="#mem_replace_with_default" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>std::mem::replace</code> on a value of type
<code>T</code> with <code>T::default()</code>.</p>
<h3>Why is this bad?</h3>
<p><code>std::mem</code> module already has the method <code>take</code> to
take the current value and replace it with the default value of that type.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut text = String::from("foo");
let replaced = std::mem::replace(&amp;mut text, String::default());
</code></pre>
<p>Is better expressed with:</p>
<pre><code class="language-rust">let mut text = String::from("foo");
let taken = std::mem::take(&amp;mut text);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.42.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mem_replace_with_default">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/mem_replace.rs#L103">View Source</a></div></div></div></article><article id="mem_replace_with_uninit"><input id="label-mem_replace_with_uninit" type="checkbox"><label for="label-mem_replace_with_uninit"><h2 class="lint-title"><div class="panel-title-name" id="lint-mem_replace_with_uninit">mem_replace_with_uninit
<a href="#mem_replace_with_uninit" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>mem::replace(&amp;mut _, mem::uninitialized())</code>
and <code>mem::replace(&amp;mut _, mem::zeroed())</code>.</p>
<h3>Why is this bad?</h3>
<p>This will lead to undefined behavior even if the
value is overwritten later, because the uninitialized value may be
observed in the case of a panic.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::mem;

#[allow(deprecated, invalid_value)]
fn myfunc (v: &amp;mut Vec&lt;i32&gt;) {
    let taken_v = unsafe { mem::replace(v, mem::uninitialized()) };
    let new_v = may_panic(taken_v); // undefined behavior on panic
    mem::forget(mem::replace(v, new_v));
}
</code></pre>
<p>The <a href="https://docs.rs/take_mut">take_mut</a> crate offers a sound solution,
at the cost of either lazily creating a replacement value or aborting
on panic, to ensure that the uninitialized value cannot be observed.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.39.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mem_replace_with_uninit">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/mem_replace.rs#L71">View Source</a></div></div></div></article><article id="min_ident_chars"><input id="label-min_ident_chars" type="checkbox"><label for="label-min_ident_chars"><h2 class="lint-title"><div class="panel-title-name" id="lint-min_ident_chars">min_ident_chars
<a href="#min_ident_chars" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for identifiers which consist of a single character (or fewer than the configured threshold).</p>
<p>Note: This lint can be very noisy when enabled; it may be desirable to only enable it
temporarily.</p>
<h3>Why restrict this?</h3>
<p>To improve readability by requiring that every variable has a name more specific than a single letter can be.</p>
<h3>Example</h3>
<pre><code class="language-rust">for m in movies {
    let title = m.t;
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">for movie in movies {
    let title = movie.title;
}
</code></pre>
<h3>Limitations</h3>
<p>Trait implementations which use the same function or parameter name as the trait declaration will
not be warned about, even if the name is below the configured limit.</p>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allowed-idents-below-min-chars</code>:  Allowed names below the minimum allowed characters. The value <code>".."</code> can be used as part of
the list to indicate, that the configured values should be appended to the default
configuration of Clippy. By default, any configuration will replace the default value.</p>
<p>(default: <code>["i", "j", "x", "y", "z", "w", "n"]</code>)</p>
</li>
<li>
<p><code>min-ident-chars-threshold</code>:  Minimum chars an ident can have, anything below or equal to this will be linted.</p>
<p>(default: <code>1</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+min_ident_chars">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/min_ident_chars.rs#L17">View Source</a></div></div></div></article><article id="min_max"><input id="label-min_max" type="checkbox"><label for="label-min_max"><h2 class="lint-title"><div class="panel-title-name" id="lint-min_max">min_max
<a href="#min_max" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for expressions where <code>std::cmp::min</code> and <code>max</code> are
used to clamp values, but switched so that the result is constant.</p>
<h3>Why is this bad?</h3>
<p>This is in all probability not the intended outcome. At
the least it hurts readability of the code.</p>
<h3>Example</h3>
<pre><code class="language-rust">min(0, max(100, x))

// or

x.max(100).min(0)
</code></pre>
<p>It will always be equal to <code>0</code>. Probably the author meant to clamp the value
between 0 and 100, but has erroneously swapped <code>min</code> and <code>max</code>.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+min_max">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/minmax.rs#L11">View Source</a></div></div></div></article><article id="misaligned_transmute"><input id="label-misaligned_transmute" type="checkbox"><label for="label-misaligned_transmute"><h2 class="lint-title"><div class="panel-title-name" id="lint-misaligned_transmute">misaligned_transmute
<a href="#misaligned_transmute" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p>Split into <code>clippy::cast_ptr_alignment</code> and <code>clippy::transmute_ptr_to_ptr</code>.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+misaligned_transmute">Related Issues</a></div></div></div></article><article id="mismatching_type_param_order"><input id="label-mismatching_type_param_order" type="checkbox"><label for="label-mismatching_type_param_order"><h2 class="lint-title"><div class="panel-title-name" id="lint-mismatching_type_param_order">mismatching_type_param_order
<a href="#mismatching_type_param_order" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for type parameters which are positioned inconsistently between
a type definition and impl block. Specifically, a parameter in an impl
block which has the same name as a parameter in the type def, but is in
a different place.</p>
<h3>Why is this bad?</h3>
<p>Type parameters are determined by their position rather than name.
Naming type parameters inconsistently may cause you to refer to the
wrong type parameter.</p>
<h3>Limitations</h3>
<p>This lint only applies to impl blocks with simple generic params, e.g.
<code>A</code>. If there is anything more complicated, such as a tuple, it will be
ignored.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Foo&lt;A, B&gt; {
    x: A,
    y: B,
}
// inside the impl, B refers to Foo::A
impl&lt;B, A&gt; Foo&lt;B, A&gt; {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct Foo&lt;A, B&gt; {
    x: A,
    y: B,
}
impl&lt;A, B&gt; Foo&lt;A, B&gt; {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.63.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mismatching_type_param_order">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/mismatching_type_param_order.rs#L9">View Source</a></div></div></div></article><article id="misnamed_getters"><input id="label-misnamed_getters" type="checkbox"><label for="label-misnamed_getters"><h2 class="lint-title"><div class="panel-title-name" id="lint-misnamed_getters">misnamed_getters
<a href="#misnamed_getters" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for getter methods that return a field that doesn’t correspond
to the name of the method, when there is a field’s whose name matches that of the method.</p>
<h3>Why is this bad?</h3>
<p>It is most likely that such a method is a bug caused by a typo or by copy-pasting.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct A {
    a: String,
    b: String,
}

impl A {
    fn a(&amp;self) -&gt; &amp;str{
        &amp;self.b
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct A {
    a: String,
    b: String,
}

impl A {
    fn a(&amp;self) -&gt; &amp;str{
        &amp;self.a
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.67.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+misnamed_getters">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/functions/mod.rs#L325">View Source</a></div></div></div></article><article id="misrefactored_assign_op"><input id="label-misrefactored_assign_op" type="checkbox"><label for="label-misrefactored_assign_op"><h2 class="lint-title"><div class="panel-title-name" id="lint-misrefactored_assign_op">misrefactored_assign_op
<a href="#misrefactored_assign_op" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>a op= a op b</code> or <code>a op= b op a</code> patterns.</p>
<h3>Why is this bad?</h3>
<p>Most likely these are bugs where one meant to write <code>a op= b</code>.</p>
<h3>Known problems</h3>
<p>Clippy cannot know for sure if <code>a op= a op b</code> should have
been <code>a = a op a op b</code> or <code>a = a op b</code>/<code>a op= b</code>. Therefore, it suggests both.
If <code>a op= a op b</code> is really the correct behavior it should be
written as <code>a = a op a op b</code> as it’s less confusing.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut a = 5;
let b = 2;
// ...
a += a + b;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+misrefactored_assign_op">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L160">View Source</a></div></div></div></article><article id="missing_assert_message"><input id="label-missing_assert_message" type="checkbox"><label for="label-missing_assert_message"><h2 class="lint-title"><div class="panel-title-name" id="lint-missing_assert_message">missing_assert_message
<a href="#missing_assert_message" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks assertions without a custom panic message.</p>
<h3>Why restrict this?</h3>
<p>Without a good custom message, it’d be hard to understand what went wrong when the assertion fails.
A good custom message should be more about why the failure of the assertion is problematic
and not what is failed because the assertion already conveys that.</p>
<p>Although the same reasoning applies to testing functions, this lint ignores them as they would be too noisy.
Also, in most cases understanding the test failure would be easier
compared to understanding a complex invariant distributed around the codebase.</p>
<h3>Known problems</h3>
<p>This lint cannot check the quality of the custom panic messages.
Hence, you can suppress this lint simply by adding placeholder messages
like “assertion failed”. However, we recommend coming up with good messages
that provide useful information instead of placeholder messages that
don’t provide any extra information.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn call(service: Service) {
    assert!(service.ready);
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn call(service: Service) {
    assert!(service.ready, "`service.poll_ready()` must be called first to ensure that service is ready to receive requests");
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+missing_assert_message">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/missing_assert_message.rs#L9">View Source</a></div></div></div></article><article id="missing_asserts_for_indexing"><input id="label-missing_asserts_for_indexing" type="checkbox"><label for="label-missing_asserts_for_indexing"><h2 class="lint-title"><div class="panel-title-name" id="lint-missing_asserts_for_indexing">missing_asserts_for_indexing
<a href="#missing_asserts_for_indexing" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for repeated slice indexing without asserting beforehand that the length
is greater than the largest index used to index into the slice.</p>
<h3>Why restrict this?</h3>
<p>In the general case where the compiler does not have a lot of information
about the length of a slice, indexing it repeatedly will generate a bounds check
for every single index.</p>
<p>Asserting that the length of the slice is at least as large as the largest value
to index beforehand gives the compiler enough information to elide the bounds checks,
effectively reducing the number of bounds checks from however many times
the slice was indexed to just one (the assert).</p>
<h3>Drawbacks</h3>
<p>False positives. It is, in general, very difficult to predict how well
the optimizer will be able to elide bounds checks and it very much depends on
the surrounding code. For example, indexing into the slice yielded by the
<a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.chunks_exact"><code>slice::chunks_exact</code></a>
iterator will likely have all of the bounds checks elided even without an assert
if the <code>chunk_size</code> is a constant.</p>
<p>Asserts are not tracked across function calls. Asserting the length of a slice
in a different function likely gives the optimizer enough information
about the length of a slice, but this lint will not detect that.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn sum(v: &amp;[u8]) -&gt; u8 {
    // 4 bounds checks
    v[0] + v[1] + v[2] + v[3]
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn sum(v: &amp;[u8]) -&gt; u8 {
    assert!(v.len() &gt; 3);
    // no bounds checks
    v[0] + v[1] + v[2] + v[3]
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.74.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+missing_asserts_for_indexing">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/missing_asserts_for_indexing.rs#L21">View Source</a></div></div></div></article><article id="missing_const_for_fn"><input id="label-missing_const_for_fn" type="checkbox"><label for="label-missing_const_for_fn"><h2 class="lint-title"><div class="panel-title-name" id="lint-missing_const_for_fn">missing_const_for_fn
<a href="#missing_const_for_fn" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Suggests the use of <code>const</code> in functions and methods where possible.</p>
<h3>Why is this bad?</h3>
<p>Not having the function const prevents callers of the function from being const as well.</p>
<h3>Known problems</h3>
<p>Const functions are currently still being worked on, with some features only being available
on nightly. This lint does not consider all edge cases currently and the suggestions may be
incorrect if you are using this lint on stable.</p>
<p>Also, the lint only runs one pass over the code. Consider these two non-const functions:</p>
<pre><code class="language-rust">fn a() -&gt; i32 {
    0
}
fn b() -&gt; i32 {
    a()
}
</code></pre>
<p>When running Clippy, the lint will only suggest to make <code>a</code> const, because <code>b</code> at this time
can’t be const as it calls a non-const function. Making <code>a</code> const and running Clippy again,
will suggest to make <code>b</code> const, too.</p>
<p>If you are marking a public function with <code>const</code>, removing it again will break API compatibility.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn new() -&gt; Self {
    Self { random_number: 42 }
}
</code></pre>
<p>Could be a const fn:</p>
<pre><code class="language-rust">const fn new() -&gt; Self {
    Self { random_number: 42 }
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.34.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+missing_const_for_fn">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/missing_const_for_fn.rs#L17">View Source</a></div></div></div></article><article id="missing_const_for_thread_local"><input id="label-missing_const_for_thread_local" type="checkbox"><label for="label-missing_const_for_thread_local"><h2 class="lint-title"><div class="panel-title-name" id="lint-missing_const_for_thread_local">missing_const_for_thread_local
<a href="#missing_const_for_thread_local" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Suggests to use <code>const</code> in <code>thread_local!</code> macro if possible.</p>
<h3>Why is this bad?</h3>
<p>The <code>thread_local!</code> macro wraps static declarations and makes them thread-local.
It supports using a <code>const</code> keyword that may be used for declarations that can
be evaluated as a constant expression. This can enable a more efficient thread
local implementation that can avoid lazy initialization. For types that do not
need to be dropped, this can enable an even more efficient implementation that
does not need to track any additional state.</p>
<p>https://doc.rust-lang.org/std/macro.thread_local.html</p>
<h3>Example</h3>
<pre><code class="language-rust">thread_local! {
    static BUF: String = String::new();
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">thread_local! {
    static BUF: String = const { String::new() };
}
</code></pre>
<h3>Past names</h3>
<ul>
<li>thread_local_initializer_can_be_made_const</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.77.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+missing_const_for_thread_local">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/missing_const_for_thread_local.rs#L14">View Source</a></div></div></div></article><article id="missing_docs_in_private_items"><input id="label-missing_docs_in_private_items" type="checkbox"><label for="label-missing_docs_in_private_items"><h2 class="lint-title"><div class="panel-title-name" id="lint-missing_docs_in_private_items">missing_docs_in_private_items
<a href="#missing_docs_in_private_items" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns if there is missing documentation for any private documentable item.</p>
<h3>Why restrict this?</h3>
<p>Doc is good. <em>rustc</em> has a <code>MISSING_DOCS</code>
allowed-by-default lint for
public members, but has no way to enforce documentation of private items.
This lint fixes that.</p>
<h3>Configuration</h3>
<ul>
<li>
<p><code>missing-docs-allow-unused</code>:  Whether to allow fields starting with an underscore to skip documentation requirements</p>
<p>(default: <code>false</code>)</p>
</li>
<li>
<p><code>missing-docs-in-crate-items</code>:  Whether to <strong>only</strong> check for missing documentation in items visible within the current
crate. For example, <code>pub(crate)</code> items.</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+missing_docs_in_private_items">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/missing_doc.rs#L17">View Source</a></div></div></div></article><article id="missing_enforced_import_renames"><input id="label-missing_enforced_import_renames" type="checkbox"><label for="label-missing_enforced_import_renames"><h2 class="lint-title"><div class="panel-title-name" id="lint-missing_enforced_import_renames">missing_enforced_import_renames
<a href="#missing_enforced_import_renames" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for imports that do not rename the item as specified
in the <code>enforced-import-renames</code> config option.</p>
<p>Note: Even though this lint is warn-by-default, it will only trigger if
import renames are defined in the <code>clippy.toml</code> file.</p>
<h3>Why is this bad?</h3>
<p>Consistency is important; if a project has defined import renames, then they should be
followed. More practically, some item names are too vague outside of their defining scope,
in which case this can enforce a more meaningful naming.</p>
<h3>Example</h3>
<p>An example clippy.toml configuration:</p>
<pre><code class="language-toml">enforced-import-renames = [
    { path = "serde_json::Value", rename = "JsonValue" },
]
</code></pre>
<pre><code class="language-rust">use serde_json::Value;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use serde_json::Value as JsonValue;
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>enforced-import-renames</code>:  The list of imports to always rename, a fully qualified path followed by the rename.</p>
<p>(default: <code>[]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.55.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+missing_enforced_import_renames">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/missing_enforced_import_rename.rs#L14">View Source</a></div></div></div></article><article id="missing_errors_doc"><input id="label-missing_errors_doc" type="checkbox"><label for="label-missing_errors_doc"><h2 class="lint-title"><div class="panel-title-name" id="lint-missing_errors_doc">missing_errors_doc
<a href="#missing_errors_doc" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks the doc comments of publicly visible functions that
return a <code>Result</code> type and warns if there is no <code># Errors</code> section.</p>
<h3>Why is this bad?</h3>
<p>Documenting the type of errors that can be returned from a
function can help callers write code to handle the errors appropriately.</p>
<h3>Examples</h3>
<p>Since the following function returns a <code>Result</code> it has an <code># Errors</code> section in
its doc comment:</p>
<pre><code class="language-rust">/// # Errors
///
/// Will return `Err` if `filename` does not exist or the user does not have
/// permission to read it.
pub fn read(filename: String) -&gt; io::Result&lt;String&gt; {
    unimplemented!();
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>check-private-items</code>:  Whether to also run the listed lints on private items.</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.41.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+missing_errors_doc">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L141">View Source</a></div></div></div></article><article id="missing_fields_in_debug"><input id="label-missing_fields_in_debug" type="checkbox"><label for="label-missing_fields_in_debug"><h2 class="lint-title"><div class="panel-title-name" id="lint-missing_fields_in_debug">missing_fields_in_debug
<a href="#missing_fields_in_debug" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for manual <a href="https://doc.rust-lang.org/core/fmt/trait.Debug.html"><code>core::fmt::Debug</code></a> implementations that do not use all fields.</p>
<h3>Why is this bad?</h3>
<p>A common mistake is to forget to update manual <code>Debug</code> implementations when adding a new field
to a struct or a new variant to an enum.</p>
<p>At the same time, it also acts as a style lint to suggest using <a href="https://doc.rust-lang.org/core/fmt/struct.DebugStruct.html#method.finish_non_exhaustive"><code>core::fmt::DebugStruct::finish_non_exhaustive</code></a>
for the times when the user intentionally wants to leave out certain fields (e.g. to hide implementation details).</p>
<h3>Known problems</h3>
<p>This lint works based on the <code>DebugStruct</code> helper types provided by the <code>Formatter</code>,
so this won’t detect <code>Debug</code> impls that use the <code>write!</code> macro.
Oftentimes there is more logic to a <code>Debug</code> impl if it uses <code>write!</code> macro, so it tries
to be on the conservative side and not lint in those cases in an attempt to prevent false positives.</p>
<p>This lint also does not look through function calls, so calling a function does not consider fields
used inside of that function as used by the <code>Debug</code> impl.</p>
<p>Lastly, it also ignores tuple structs as their <code>DebugTuple</code> formatter does not have a <code>finish_non_exhaustive</code>
method, as well as enums because their exhaustiveness is already checked by the compiler when matching on the enum,
making it much less likely to accidentally forget to update the <code>Debug</code> impl when adding a new variant.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::fmt;
struct Foo {
    data: String,
    // implementation detail
    hidden_data: i32
}
impl fmt::Debug for Foo {
    fn fmt(&amp;self, formatter: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        formatter
            .debug_struct("Foo")
            .field("data", &amp;self.data)
            .finish()
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::fmt;
struct Foo {
    data: String,
    // implementation detail
    hidden_data: i32
}
impl fmt::Debug for Foo {
    fn fmt(&amp;self, formatter: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        formatter
            .debug_struct("Foo")
            .field("data", &amp;self.data)
            .finish_non_exhaustive()
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+missing_fields_in_debug">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/missing_fields_in_debug.rs#L16">View Source</a></div></div></div></article><article id="missing_inline_in_public_items"><input id="label-missing_inline_in_public_items" type="checkbox"><label for="label-missing_inline_in_public_items"><h2 class="lint-title"><div class="panel-title-name" id="lint-missing_inline_in_public_items">missing_inline_in_public_items
<a href="#missing_inline_in_public_items" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>It lints if an exported function, method, trait method with default impl,
or trait method impl is not <code>#[inline]</code>.</p>
<h3>Why restrict this?</h3>
<p>When a function is not marked <code>#[inline]</code>, it is not
<a href="https://github.com/rust-lang/rust/pull/116505">a “small” candidate for automatic inlining</a>, and LTO is not in use, then it is not
possible for the function to be inlined into the code of any crate other than the one in
which it is defined.  Depending on the role of the function and the relationship of the crates,
this could significantly reduce performance.</p>
<p>Certain types of crates might intend for most of the methods in their public API to be able
to be inlined across crates even when LTO is disabled.
This lint allows those crates to require all exported methods to be <code>#[inline]</code> by default, and
then opt out for specific methods where this might not make sense.</p>
<h3>Example</h3>
<pre><code class="language-rust">pub fn foo() {} // missing #[inline]
fn ok() {} // ok
#[inline] pub fn bar() {} // ok
#[inline(always)] pub fn baz() {} // ok

pub trait Bar {
  fn bar(); // ok
  fn def_bar() {} // missing #[inline]
}

struct Baz;
impl Baz {
    fn private() {} // ok
}

impl Bar for Baz {
  fn bar() {} // ok - Baz is not exported
}

pub struct PubBaz;
impl PubBaz {
    fn private() {} // ok
    pub fn not_private() {} // missing #[inline]
}

impl Bar for PubBaz {
    fn bar() {} // missing #[inline]
    fn def_bar() {} // missing #[inline]
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+missing_inline_in_public_items">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/missing_inline.rs#L11">View Source</a></div></div></div></article><article id="missing_panics_doc"><input id="label-missing_panics_doc" type="checkbox"><label for="label-missing_panics_doc"><h2 class="lint-title"><div class="panel-title-name" id="lint-missing_panics_doc">missing_panics_doc
<a href="#missing_panics_doc" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks the doc comments of publicly visible functions that
may panic and warns if there is no <code># Panics</code> section.</p>
<h3>Why is this bad?</h3>
<p>Documenting the scenarios in which panicking occurs
can help callers who do not want to panic to avoid those situations.</p>
<h3>Examples</h3>
<p>Since the following function may panic it has a <code># Panics</code> section in
its doc comment:</p>
<pre><code class="language-rust">/// # Panics
///
/// Will panic if y is 0
pub fn divide_by(x: i32, y: i32) -&gt; i32 {
    if y == 0 {
        panic!("Cannot divide by 0")
    } else {
        x / y
    }
}
</code></pre>
<p>Individual panics within a function can be ignored with <code>#[expect]</code> or
<code>#[allow]</code>:</p>
<pre><code class="language-rust">pub fn will_not_panic(x: usize) {
    #[expect(clippy::missing_panics_doc, reason = "infallible")]
    let y = NonZeroUsize::new(1).unwrap();

    // If any panics are added in the future the lint will still catch them
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>check-private-items</code>:  Whether to also run the listed lints on private items.</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.51.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+missing_panics_doc">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L170">View Source</a></div></div></div></article><article id="missing_safety_doc"><input id="label-missing_safety_doc" type="checkbox"><label for="label-missing_safety_doc"><h2 class="lint-title"><div class="panel-title-name" id="lint-missing_safety_doc">missing_safety_doc
<a href="#missing_safety_doc" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the doc comments of publicly visible
unsafe functions and warns if there is no <code># Safety</code> section.</p>
<h3>Why is this bad?</h3>
<p>Unsafe functions should document their safety
preconditions, so that users can be sure they are using them safely.</p>
<h3>Examples</h3>
<pre><code class="language-rust">/// This function should really be documented
pub unsafe fn start_apocalypse(u: &amp;mut Universe) {
    unimplemented!();
}
</code></pre>
<p>At least write a line about safety:</p>
<pre><code class="language-rust">/// # Safety
///
/// This function should not be called before the horsemen are ready.
pub unsafe fn start_apocalypse(u: &amp;mut Universe) {
    unimplemented!();
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>check-private-items</code>:  Whether to also run the listed lints on private items.</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.39.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+missing_safety_doc">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L106">View Source</a></div></div></div></article><article id="missing_spin_loop"><input id="label-missing_spin_loop" type="checkbox"><label for="label-missing_spin_loop"><h2 class="lint-title"><div class="panel-title-name" id="lint-missing_spin_loop">missing_spin_loop
<a href="#missing_spin_loop" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for empty spin loops</p>
<h3>Why is this bad?</h3>
<p>The loop body should have something like <code>thread::park()</code> or at least
<code>std::hint::spin_loop()</code> to avoid needlessly burning cycles and conserve
energy. Perhaps even better use an actual lock, if possible.</p>
<h3>Known problems</h3>
<p>This lint doesn’t currently trigger on <code>while let</code> or
<code>loop { match .. { .. } }</code> loops, which would be considered idiomatic in
combination with e.g. <code>AtomicBool::compare_exchange_weak</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">use core::sync::atomic::{AtomicBool, Ordering};
let b = AtomicBool::new(true);
// give a ref to `b` to another thread,wait for it to become false
while b.load(Ordering::Acquire) {};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">while b.load(Ordering::Acquire) {
    std::hint::spin_loop()
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.61.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+missing_spin_loop">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L554">View Source</a></div></div></div></article><article id="missing_trait_methods"><input id="label-missing_trait_methods" type="checkbox"><label for="label-missing_trait_methods"><h2 class="lint-title"><div class="panel-title-name" id="lint-missing_trait_methods">missing_trait_methods
<a href="#missing_trait_methods" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks if a provided method is used implicitly by a trait
implementation.</p>
<h3>Why restrict this?</h3>
<p>To ensure that a certain implementation implements every method; for example,
a wrapper type where every method should delegate to the corresponding method of
the inner type’s implementation.</p>
<p>This lint should typically be enabled on a specific trait <code>impl</code> item
rather than globally.</p>
<h3>Example</h3>
<pre><code class="language-rust">trait Trait {
    fn required();

    fn provided() {}
}

#[warn(clippy::missing_trait_methods)]
impl Trait for Type {
    fn required() { /* ... */ }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">trait Trait {
    fn required();

    fn provided() {}
}

#[warn(clippy::missing_trait_methods)]
impl Trait for Type {
    fn required() { /* ... */ }

    fn provided() { /* ... */ }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.66.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+missing_trait_methods">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/missing_trait_methods.rs#L10">View Source</a></div></div></div></article><article id="missing_transmute_annotations"><input id="label-missing_transmute_annotations" type="checkbox"><label for="label-missing_transmute_annotations"><h2 class="lint-title"><div class="panel-title-name" id="lint-missing_transmute_annotations">missing_transmute_annotations
<a href="#missing_transmute_annotations" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks if transmute calls have all generics specified.</p>
<h3>Why is this bad?</h3>
<p>If not, one or more unexpected types could be used during <code>transmute()</code>, potentially leading
to Undefined Behavior or other problems.</p>
<p>This is particularly dangerous in case a seemingly innocent/unrelated change causes type
inference to result in a different type. For example, if <code>transmute()</code> is the tail
expression of an <code>if</code>-branch, and the <code>else</code>-branch type changes, the compiler may silently
infer a different type to be returned by <code>transmute()</code>. That is because the compiler is
free to change the inference of a type as long as that inference is technically correct,
regardless of the programmer’s unknown expectation.</p>
<p>Both type-parameters, the input- and the output-type, to any <code>transmute()</code> should
be given explicitly: Setting the input-type explicitly avoids confusion about what the
argument’s type actually is. Setting the output-type explicitly avoids type-inference
to infer a technically correct yet unexpected type.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut x: i32 = 0;
// Avoid "naked" calls to `transmute()`!
x = std::mem::transmute([1u16, 2u16]);

// `first_answers` is intended to transmute a slice of bool to a slice of u8.
// But the programmer forgot to index the first element of the outer slice,
// so we are actually transmuting from "pointers to slices" instead of
// transmuting from "a slice of bool", causing a nonsensical result.
let the_answers: &amp;[&amp;[bool]] = &amp;[&amp;[true, false, true]];
let first_answers: &amp;[u8] = std::mem::transmute(the_answers);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = std::mem::transmute::&lt;[u16; 2], i32&gt;([1u16, 2u16]);

// The explicit type parameters on `transmute()` makes the intention clear,
// and cause a type-error if the actual types don't match our expectation.
let the_answers: &amp;[&amp;[bool]] = &amp;[&amp;[true, false, true]];
let first_answers: &amp;[u8] = std::mem::transmute::&lt;&amp;[bool], &amp;[u8]&gt;(the_answers[0]);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.79.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+missing_transmute_annotations">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/transmute/mod.rs#L420">View Source</a></div></div></div></article><article id="mistyped_literal_suffixes"><input id="label-mistyped_literal_suffixes" type="checkbox"><label for="label-mistyped_literal_suffixes"><h2 class="lint-title"><div class="panel-title-name" id="lint-mistyped_literal_suffixes">mistyped_literal_suffixes
<a href="#mistyped_literal_suffixes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns for mistyped suffix in literals</p>
<h3>Why is this bad?</h3>
<p>This is most probably a typo</p>
<h3>Known problems</h3>
<ul>
<li>Does not match on integers too large to fit in the corresponding unsigned type</li>
<li>Does not match on <code>_127</code> since that is a valid grouping for decimal and octal numbers</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">`2_32` =&gt; `2_i32`
`250_8 =&gt; `250_u8`
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.30.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mistyped_literal_suffixes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/literal_representation.rs#L40">View Source</a></div></div></div></article><article id="mixed_attributes_style"><input id="label-mixed_attributes_style" type="checkbox"><label for="label-mixed_attributes_style"><h2 class="lint-title"><div class="panel-title-name" id="lint-mixed_attributes_style">mixed_attributes_style
<a href="#mixed_attributes_style" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for items that have the same kind of attributes with mixed styles (inner/outer).</p>
<h3>Why is this bad?</h3>
<p>Having both style of said attributes makes it more complicated to read code.</p>
<h3>Known problems</h3>
<p>This lint currently has false-negatives when mixing same attributes
but they have different path symbols, for example:</p>
<pre><code class="language-rust">#[custom_attribute]
pub fn foo() {
    #![my_crate::custom_attribute]
}
</code></pre>
<h3>Example</h3>
<pre><code class="language-rust">#[cfg(linux)]
pub fn foo() {
    #![cfg(windows)]
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[cfg(linux)]
#[cfg(windows)]
pub fn foo() {
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.78.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mixed_attributes_style">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/attrs/mod.rs#L389">View Source</a></div></div></div></article><article id="mixed_case_hex_literals"><input id="label-mixed_case_hex_literals" type="checkbox"><label for="label-mixed_case_hex_literals"><h2 class="lint-title"><div class="panel-title-name" id="lint-mixed_case_hex_literals">mixed_case_hex_literals
<a href="#mixed_case_hex_literals" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns on hexadecimal literals with mixed-case letter
digits.</p>
<h3>Why is this bad?</h3>
<p>It looks confusing.</p>
<h3>Example</h3>
<pre><code class="language-rust">0x1a9BAcD
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">0x1A9BACD
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mixed_case_hex_literals">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/misc_early/mod.rs#L60">View Source</a></div></div></div></article><article id="mixed_read_write_in_expression"><input id="label-mixed_read_write_in_expression" type="checkbox"><label for="label-mixed_read_write_in_expression"><h2 class="lint-title"><div class="panel-title-name" id="lint-mixed_read_write_in_expression">mixed_read_write_in_expression
<a href="#mixed_read_write_in_expression" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for a read and a write to the same variable where
whether the read occurs before or after the write depends on the evaluation
order of sub-expressions.</p>
<h3>Why restrict this?</h3>
<p>While [the evaluation order of sub-expressions] is fully specified in Rust,
it still may be confusing to read an expression where the evaluation order
affects its behavior.</p>
<h3>Known problems</h3>
<p>Code which intentionally depends on the evaluation
order, or which is correct for any evaluation order.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut x = 0;

let a = {
    x = 1;
    1
} + x;
// Unclear whether a is 1 or 2.
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let tmp = {
    x = 1;
    1
};
let a = tmp + x;
</code></pre>
<h3>Past names</h3>
<ul>
<li>eval_order_dependence</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mixed_read_write_in_expression">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/mixed_read_write_in_expression.rs#L11">View Source</a></div></div></div></article><article id="mod_module_files"><input id="label-mod_module_files" type="checkbox"><label for="label-mod_module_files"><h2 class="lint-title"><div class="panel-title-name" id="lint-mod_module_files">mod_module_files
<a href="#mod_module_files" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks that module layout uses only self named module files; bans <code>mod.rs</code> files.</p>
<h3>Why restrict this?</h3>
<p>Having multiple module layout styles in a project can be confusing.</p>
<h3>Example</h3>
<pre><code class="language-text">src/
  stuff/
    stuff_files.rs
    mod.rs
  lib.rs
</code></pre>
<p>Use instead:</p>
<pre><code class="language-text">src/
  stuff/
    stuff_files.rs
  stuff.rs
  lib.rs
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.57.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mod_module_files">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/module_style.rs#L10">View Source</a></div></div></div></article><article id="module_inception"><input id="label-module_inception" type="checkbox"><label for="label-module_inception"><h2 class="lint-title"><div class="panel-title-name" id="lint-module_inception">module_inception
<a href="#module_inception" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for modules that have the same name as their
parent module</p>
<h3>Why is this bad?</h3>
<p>A typical beginner mistake is to have <code>mod foo;</code> and
again <code>mod foo { .. }</code> in <code>foo.rs</code>.
The expectation is that items inside the inner <code>mod foo { .. }</code> are then
available
through <code>foo::x</code>, but they are only available through
<code>foo::foo::x</code>.
If this is done on purpose, it would be better to choose a more
representative module name.</p>
<h3>Example</h3>
<pre><code class="language-rust">// lib.rs
mod foo;
// foo.rs
mod foo {
    ...
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allow-private-module-inception</code>:  Whether to allow module inception if it’s not public.</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+module_inception">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/item_name_repetitions.rs#L92">View Source</a></div></div></div></article><article id="module_name_repetitions"><input id="label-module_name_repetitions" type="checkbox"><label for="label-module_name_repetitions"><h2 class="lint-title"><div class="panel-title-name" id="lint-module_name_repetitions">module_name_repetitions
<a href="#module_name_repetitions" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects public item names that are prefixed or suffixed by the
containing public module’s name.</p>
<h3>Why is this bad?</h3>
<p>It requires the user to type the module name twice in each usage,
especially if they choose to import the module rather than its contents.</p>
<p>Lack of such repetition is also the style used in the Rust standard library;
e.g. <code>io::Error</code> and <code>fmt::Error</code> rather than <code>io::IoError</code> and <code>fmt::FmtError</code>;
and <code>array::from_ref</code> rather than <code>array::array_from_ref</code>.</p>
<h3>Known issues</h3>
<p>Glob re-exports are ignored; e.g. this will not warn even though it should:</p>
<pre><code class="language-rust">pub mod foo {
    mod iteration {
        pub struct FooIter {}
    }
    pub use iteration::*; // creates the path `foo::FooIter`
}
</code></pre>
<h3>Example</h3>
<pre><code class="language-rust">mod cake {
    struct BlackForestCake;
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">mod cake {
    struct BlackForest;
}
</code></pre>
<h3>Past names</h3>
<ul>
<li>stutter</li>
</ul>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allow-exact-repetitions</code>:  Whether an item should be allowed to have the same name as its containing module</p>
<p>(default: <code>true</code>)</p>
</li>
<li>
<p><code>allowed-prefixes</code>:  List of prefixes to allow when determining whether an item’s name ends with the module’s name.
If the rest of an item’s name is an allowed prefix (e.g. item <code>ToFoo</code> or <code>to_foo</code> in module <code>foo</code>),
then don’t emit a warning.</p>
</li>
</ul>
<h4>Example</h4>
<pre><code class="language-toml">allowed-prefixes = [ "to", "from" ]
</code></pre>
<h4>Noteworthy</h4>
<ul>
<li>
<p>By default, the following prefixes are allowed: <code>to</code>, <code>as</code>, <code>into</code>, <code>from</code>, <code>try_into</code> and <code>try_from</code></p>
</li>
<li>
<p>PascalCase variant is included automatically for each snake_case variant (e.g. if <code>try_into</code> is included,
<code>TryInto</code> will also be included)</p>
</li>
<li>
<p>Use <code>".."</code> as part of the list to indicate that the configured values should be appended to the
default configuration of Clippy. By default, any configuration will replace the default value</p>
<p>(default: <code>["to", "as", "into", "from", "try_into", "try_from"]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.33.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+module_name_repetitions">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/item_name_repetitions.rs#L48">View Source</a></div></div></div></article><article id="modulo_arithmetic"><input id="label-modulo_arithmetic" type="checkbox"><label for="label-modulo_arithmetic"><h2 class="lint-title"><div class="panel-title-name" id="lint-modulo_arithmetic">modulo_arithmetic
<a href="#modulo_arithmetic" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for modulo arithmetic.</p>
<h3>Why restrict this?</h3>
<p>The results of modulo (<code>%</code>) operation might differ
depending on the language, when negative numbers are involved.
If you interop with different languages it might be beneficial
to double check all places that use modulo arithmetic.</p>
<p>For example, in Rust <code>17 % -3 = 2</code>, but in Python <code>17 % -3 = -1</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = -17 % 3;
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allow-comparison-to-zero</code>:  Don’t lint when comparing the result of a modulo operation to zero.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.42.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+modulo_arithmetic">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L724">View Source</a></div></div></div></article><article id="modulo_one"><input id="label-modulo_one" type="checkbox"><label for="label-modulo_one"><h2 class="lint-title"><div class="panel-title-name" id="lint-modulo_one">modulo_one
<a href="#modulo_one" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for getting the remainder of integer division by one or minus
one.</p>
<h3>Why is this bad?</h3>
<p>The result for a divisor of one can only ever be zero; for
minus one it can cause panic/overflow (if the left operand is the minimal value of
the respective integer type) or results in zero. No one will write such code
deliberately, unless trying to win an Underhanded Rust Contest. Even for that
contest, it’s probably a bad idea. Use something more underhanded.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = x % 1;
let a = x % -1;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+modulo_one">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L700">View Source</a></div></div></div></article><article id="multi_assignments"><input id="label-multi_assignments" type="checkbox"><label for="label-multi_assignments"><h2 class="lint-title"><div class="panel-title-name" id="lint-multi_assignments">multi_assignments
<a href="#multi_assignments" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for nested assignments.</p>
<h3>Why is this bad?</h3>
<p>While this is in most cases already a type mismatch,
the result of an assignment being <code>()</code> can throw off people coming from languages like python or C,
where such assignments return a copy of the assigned value.</p>
<h3>Example</h3>
<pre><code class="language-rust">a = b = 42;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">b = 42;
a = b;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.65.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+multi_assignments">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/multi_assignments.rs#L6">View Source</a></div></div></div></article><article id="multiple_bound_locations"><input id="label-multiple_bound_locations" type="checkbox"><label for="label-multiple_bound_locations"><h2 class="lint-title"><div class="panel-title-name" id="lint-multiple_bound_locations">multiple_bound_locations
<a href="#multiple_bound_locations" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Check if a generic is defined both in the bound predicate and in the <code>where</code> clause.</p>
<h3>Why is this bad?</h3>
<p>It can be confusing for developers when seeing bounds for a generic in multiple places.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn ty&lt;F: std::fmt::Debug&gt;(a: F)
where
    F: Sized,
{}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn ty&lt;F&gt;(a: F)
where
    F: Sized + std::fmt::Debug,
{}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.78.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+multiple_bound_locations">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/multiple_bound_locations.rs#L11">View Source</a></div></div></div></article><article id="multiple_crate_versions"><input id="label-multiple_crate_versions" type="checkbox"><label for="label-multiple_crate_versions"><h2 class="lint-title"><div class="panel-title-name" id="lint-multiple_crate_versions">multiple_crate_versions
<a href="#multiple_crate_versions" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-cargo">cargo</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks to see if multiple versions of a crate are being
used.</p>
<h3>Why is this bad?</h3>
<p>This bloats the size of targets, and can lead to
confusing error messages when structs or traits are used interchangeably
between different versions of a crate.</p>
<h3>Known problems</h3>
<p>Because this can be caused purely by the dependencies
themselves, it’s not always possible to fix this issue.
In those cases, you can allow that specific crate using
the <code>allowed-duplicate-crates</code> configuration option.</p>
<h3>Example</h3>
<pre><code class="language-toml">[dependencies]
ctrlc = "=3.1.0"
ansi_term = "=0.11.0"
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allowed-duplicate-crates</code>:  A list of crate names to allow duplicates of</p>
<p>(default: <code>[]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+multiple_crate_versions">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/cargo/mod.rs#L121">View Source</a></div></div></div></article><article id="multiple_inherent_impl"><input id="label-multiple_inherent_impl" type="checkbox"><label for="label-multiple_inherent_impl"><h2 class="lint-title"><div class="panel-title-name" id="lint-multiple_inherent_impl">multiple_inherent_impl
<a href="#multiple_inherent_impl" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for multiple inherent implementations of a struct</p>
<p>The config option controls the scope in which multiple inherent <code>impl</code> blocks for the same
struct are linted, allowing values of <code>module</code> (only within the same module), <code>file</code>
(within the same file), or <code>crate</code> (anywhere in the crate, default).</p>
<h3>Why restrict this?</h3>
<p>Splitting the implementation of a type makes the code harder to navigate.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct X;
impl X {
    fn one() {}
}
impl X {
    fn other() {}
}
</code></pre>
<p>Could be written:</p>
<pre><code class="language-rust">struct X;
impl X {
    fn one() {}
    fn other() {}
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>inherent-impl-lint-scope</code>:  Sets the scope (“crate”, “file”, or “module”) in which duplicate inherent <code>impl</code> blocks for the same type are linted.</p>
<p>(default: <code>"crate"</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+multiple_inherent_impl">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/inherent_impl.rs#L13">View Source</a></div></div></div></article><article id="multiple_unsafe_ops_per_block"><input id="label-multiple_unsafe_ops_per_block" type="checkbox"><label for="label-multiple_unsafe_ops_per_block"><h2 class="lint-title"><div class="panel-title-name" id="lint-multiple_unsafe_ops_per_block">multiple_unsafe_ops_per_block
<a href="#multiple_unsafe_ops_per_block" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>unsafe</code> blocks that contain more than one unsafe operation.</p>
<h3>Why restrict this?</h3>
<p>Combined with <code>undocumented_unsafe_blocks</code>,
this lint ensures that each unsafe operation must be independently justified.
Combined with <code>unused_unsafe</code>, this lint also ensures
elimination of unnecessary unsafe blocks through refactoring.</p>
<h3>Example</h3>
<pre><code class="language-rust">/// Reads a `char` from the given pointer.
///
/// # Safety
///
/// `ptr` must point to four consecutive, initialized bytes which
/// form a valid `char` when interpreted in the native byte order.
fn read_char(ptr: *const u8) -&gt; char {
    // SAFETY: The caller has guaranteed that the value pointed
    // to by `bytes` is a valid `char`.
    unsafe { char::from_u32_unchecked(*ptr.cast::&lt;u32&gt;()) }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">/// Reads a `char` from the given pointer.
///
/// # Safety
///
/// - `ptr` must be 4-byte aligned, point to four consecutive
///   initialized bytes, and be valid for reads of 4 bytes.
/// - The bytes pointed to by `ptr` must represent a valid
///   `char` when interpreted in the native byte order.
fn read_char(ptr: *const u8) -&gt; char {
    // SAFETY: `ptr` is 4-byte aligned, points to four consecutive
    // initialized bytes, and is valid for reads of 4 bytes.
    let int_value = unsafe { *ptr.cast::&lt;u32&gt;() };

    // SAFETY: The caller has guaranteed that the four bytes
    // pointed to by `bytes` represent a valid `char`.
    unsafe { char::from_u32_unchecked(int_value) }
}
</code></pre>
<h3>Notes</h3>
<ul>
<li>Unsafe operations only count towards the total for the innermost
enclosing <code>unsafe</code> block.</li>
<li>Each call to a macro expanding to unsafe operations count for one
unsafe operation.</li>
<li>Taking a raw pointer to a union field is always safe and will
not be considered unsafe by this lint, even when linting code written
with a specified Rust version of 1.91 or earlier (which required
using an <code>unsafe</code> block).</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.69.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+multiple_unsafe_ops_per_block">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/multiple_unsafe_ops_per_block.rs#L15">View Source</a></div></div></div></article><article id="must_use_candidate"><input id="label-must_use_candidate" type="checkbox"><label for="label-must_use_candidate"><h2 class="lint-title"><div class="panel-title-name" id="lint-must_use_candidate">must_use_candidate
<a href="#must_use_candidate" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for public functions that have no
<code>#[must_use]</code> attribute, but return something not already marked
must-use, have no mutable arg and mutate no statics.</p>
<h3>Why is this bad?</h3>
<p>Not bad at all, this lint just shows places where
you could add the attribute.</p>
<h3>Known problems</h3>
<p>The lint only checks the arguments for mutable
types without looking if they are actually changed. On the other hand,
it also ignores a broad range of potentially interesting side effects,
because we cannot decide whether the programmer intends the function to
be called for the side effect or the result. Expect many false
positives. At least we don’t lint if the result type is unit or already
<code>#[must_use]</code>.</p>
<h3>Examples</h3>
<pre><code class="language-rust">// this could be annotated with `#[must_use]`.
pub fn id&lt;T&gt;(t: T) -&gt; T { t }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.40.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+must_use_candidate">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/functions/mod.rs#L197">View Source</a></div></div></div></article><article id="must_use_unit"><input id="label-must_use_unit" type="checkbox"><label for="label-must_use_unit"><h2 class="lint-title"><div class="panel-title-name" id="lint-must_use_unit">must_use_unit
<a href="#must_use_unit" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for a <code>#[must_use]</code> attribute on
unit-returning functions and methods.</p>
<h3>Why is this bad?</h3>
<p>Unit values are useless. The attribute is likely
a remnant of a refactoring that removed the return type.</p>
<h3>Examples</h3>
<pre><code class="language-rust">#[must_use]
fn useless() { }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.40.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+must_use_unit">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/functions/mod.rs#L153">View Source</a></div></div></div></article><article id="mut_from_ref"><input id="label-mut_from_ref" type="checkbox"><label for="label-mut_from_ref"><h2 class="lint-title"><div class="panel-title-name" id="lint-mut_from_ref">mut_from_ref
<a href="#mut_from_ref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint checks for functions that take immutable references and return
mutable ones. This will not trigger if no unsafe code exists as there
are multiple safe functions which will do this transformation</p>
<p>To be on the conservative side, if there’s at least one mutable
reference with the output lifetime, this lint will not trigger.</p>
<h3>Why is this bad?</h3>
<p>Creating a mutable reference which can be repeatably derived from an
immutable reference is unsound as it allows creating multiple live
mutable references to the same object.</p>
<p>This <a href="https://github.com/rust-lang/rust/issues/39465">error</a> actually
lead to an interim Rust release 1.15.1.</p>
<h3>Known problems</h3>
<p>This pattern is used by memory allocators to allow allocating multiple
objects while returning mutable references to each one. So long as
different mutable references are returned each time such a function may
be safe.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(&amp;Foo) -&gt; &amp;mut Bar { .. }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mut_from_ref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ptr/mod.rs#L76">View Source</a></div></div></div></article><article id="mut_mut"><input id="label-mut_mut" type="checkbox"><label for="label-mut_mut"><h2 class="lint-title"><div class="panel-title-name" id="lint-mut_mut">mut_mut
<a href="#mut_mut" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for instances of <code>mut mut</code> references.</p>
<h3>Why is this bad?</h3>
<p>This is usually just a typo or a misunderstanding of how references work.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = &amp;mut &amp;mut 1;

let mut x = &amp;mut 1;
let y = &amp;mut x;

fn foo(x: &amp;mut &amp;mut u32) {}
</code></pre>
<p>Use instead</p>
<pre><code class="language-rust">let x = &amp;mut 1;

let mut x = &amp;mut 1;
let y = &amp;mut *x; // reborrow

fn foo(x: &amp;mut u32) {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mut_mut">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/mut_mut.rs#L12">View Source</a></div></div></div></article><article id="mut_mutex_lock"><input id="label-mut_mutex_lock" type="checkbox"><label for="label-mut_mutex_lock"><h2 class="lint-title"><div class="panel-title-name" id="lint-mut_mutex_lock">mut_mutex_lock
<a href="#mut_mutex_lock" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>&amp;mut Mutex::lock</code> calls</p>
<h3>Why is this bad?</h3>
<p><code>Mutex::lock</code> is less efficient than
calling <code>Mutex::get_mut</code>. In addition you also have a statically
guarantee that the mutex isn’t locked, instead of just a runtime
guarantee.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::sync::{Arc, Mutex};

let mut value_rc = Arc::new(Mutex::new(42_u8));
let value_mutex = Arc::get_mut(&amp;mut value_rc).unwrap();

let mut value = value_mutex.lock().unwrap();
*value += 1;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::sync::{Arc, Mutex};

let mut value_rc = Arc::new(Mutex::new(42_u8));
let value_mutex = Arc::get_mut(&amp;mut value_rc).unwrap();

let value = value_mutex.get_mut().unwrap();
*value += 1;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mut_mutex_lock">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2855">View Source</a></div></div></div></article><article id="mut_range_bound"><input id="label-mut_range_bound" type="checkbox"><label for="label-mut_range_bound"><h2 class="lint-title"><div class="panel-title-name" id="lint-mut_range_bound">mut_range_bound
<a href="#mut_range_bound" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for loops with a range bound that is a mutable variable.</p>
<h3>Why is this bad?</h3>
<p>One might think that modifying the mutable variable changes the loop bounds. It doesn’t.</p>
<h3>Known problems</h3>
<p>False positive when mutation is followed by a <code>break</code>, but the <code>break</code> is not immediately
after the mutation:</p>
<pre><code class="language-rust">let mut x = 5;
for _ in 0..x {
    x += 1; // x is a range bound that is mutated
    ..; // some other expression
    break; // leaves the loop, so mutation is not an issue
}
</code></pre>
<p>False positive on nested loops (<a href="https://github.com/rust-lang/rust-clippy/issues/6072">#6072</a>)</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut foo = 42;
for i in 0..foo {
    foo -= 1;
    println!("{i}"); // prints numbers from 0 to 41, not 0 to 21
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mut_range_bound">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L362">View Source</a></div></div></div></article><article id="mutable_key_type"><input id="label-mutable_key_type" type="checkbox"><label for="label-mutable_key_type"><h2 class="lint-title"><div class="panel-title-name" id="lint-mutable_key_type">mutable_key_type
<a href="#mutable_key_type" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for sets/maps with mutable key types.</p>
<h3>Why is this bad?</h3>
<p>All of <code>HashMap</code>, <code>HashSet</code>, <code>BTreeMap</code> and
<code>BtreeSet</code> rely on either the hash or the order of keys be unchanging,
so having types with interior mutability is a bad idea.</p>
<h3>Known problems</h3>
<h4>False Positives</h4>
<p>It’s correct to use a struct that contains interior mutability as a key when its
implementation of <code>Hash</code> or <code>Ord</code> doesn’t access any of the interior mutable types.
However, this lint is unable to recognize this, so it will often cause false positives in
these cases.</p>
<h4>False Negatives</h4>
<p>This lint does not follow raw pointers (<code>*const T</code> or <code>*mut T</code>) as <code>Hash</code> and <code>Ord</code>
apply only to the <strong>address</strong> of the contained value. This can cause false negatives for
custom collections that use raw pointers internally.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::cmp::{PartialEq, Eq};
use std::collections::HashSet;
use std::hash::{Hash, Hasher};
use std::sync::atomic::AtomicUsize;

struct Bad(AtomicUsize);
impl PartialEq for Bad {
    fn eq(&amp;self, rhs: &amp;Self) -&gt; bool {
         ..
    }
}

impl Eq for Bad {}

impl Hash for Bad {
    fn hash&lt;H: Hasher&gt;(&amp;self, h: &amp;mut H) {
        ..
    }
}

fn main() {
    let _: HashSet&lt;Bad&gt; = HashSet::new();
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>ignore-interior-mutability</code>:  A list of paths to types that should be treated as if they do not contain interior mutability</p>
<p>(default: <code>["bytes::Bytes"]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.42.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mutable_key_type">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/mut_key.rs#L15">View Source</a></div></div></div></article><article id="mutex_atomic"><input id="label-mutex_atomic" type="checkbox"><label for="label-mutex_atomic"><h2 class="lint-title"><div class="panel-title-name" id="lint-mutex_atomic">mutex_atomic
<a href="#mutex_atomic" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>Mutex&lt;X&gt;</code> where an atomic will do.</p>
<h3>Why restrict this?</h3>
<p>Using a mutex just to make access to a plain bool or
reference sequential is shooting flies with cannons.
<code>std::sync::atomic::AtomicBool</code> and <code>std::sync::atomic::AtomicPtr</code> are leaner and
faster.</p>
<p>On the other hand, <code>Mutex</code>es are, in general, easier to
verify correctness. An atomic does not behave the same as
an equivalent mutex. See <a href="https://github.com/rust-lang/rust-clippy/issues/4295">this issue</a>’s
commentary for more details.</p>
<h3>Known problems</h3>
<ul>
<li>This lint cannot detect if the mutex is actually used
for waiting before a critical section.</li>
<li>This lint has a false positive that warns without considering the case
where <code>Mutex</code> is used together with <code>Condvar</code>.</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">let x = Mutex::new(&amp;y);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = AtomicBool::new(y);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mutex_atomic">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/mutex_atomic.rs#L14">View Source</a></div></div></div></article><article id="mutex_integer"><input id="label-mutex_integer" type="checkbox"><label for="label-mutex_integer"><h2 class="lint-title"><div class="panel-title-name" id="lint-mutex_integer">mutex_integer
<a href="#mutex_integer" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>Mutex&lt;X&gt;</code> where <code>X</code> is an integral
type.</p>
<h3>Why restrict this?</h3>
<p>Using a mutex just to make access to a plain integer
sequential is
shooting flies with cannons. <code>std::sync::atomic::AtomicUsize</code> is leaner and faster.</p>
<p>On the other hand, <code>Mutex</code>es are, in general, easier to
verify correctness. An atomic does not behave the same as
an equivalent mutex. See <a href="https://github.com/rust-lang/rust-clippy/issues/4295">this issue</a>’s
commentary for more details.</p>
<h3>Known problems</h3>
<ul>
<li>This lint cannot detect if the mutex is actually used
for waiting before a critical section.</li>
<li>This lint has a false positive that warns without considering the case
where <code>Mutex</code> is used together with <code>Condvar</code>.</li>
<li>This lint suggest using <code>AtomicU64</code> instead of <code>Mutex&lt;u64&gt;</code>, but
<code>AtomicU64</code> is not available on some 32-bit platforms.</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">let x = Mutex::new(0usize);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = AtomicUsize::new(0usize);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+mutex_integer">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/mutex_atomic.rs#L54">View Source</a></div></div></div></article><article id="naive_bytecount"><input id="label-naive_bytecount" type="checkbox"><label for="label-naive_bytecount"><h2 class="lint-title"><div class="panel-title-name" id="lint-naive_bytecount">naive_bytecount
<a href="#naive_bytecount" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for naive byte counts</p>
<h3>Why is this bad?</h3>
<p>The <a href="https://crates.io/crates/bytecount"><code>bytecount</code></a>
crate has methods to count your bytes faster, especially for large slices.</p>
<h3>Known problems</h3>
<p>If you have predominantly small slices, the
<code>bytecount::count(..)</code> method may actually be slower. However, if you can
ensure that less than 2³²-1 matches arise, the <code>naive_count_32(..)</code> can be
faster in those cases.</p>
<h3>Example</h3>
<pre><code class="language-rust">let count = vec.iter().filter(|x| **x == 0u8).count();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let count = bytecount::count(&amp;vec, 0u8);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+naive_bytecount">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2589">View Source</a></div></div></div></article><article id="needless_arbitrary_self_type"><input id="label-needless_arbitrary_self_type" type="checkbox"><label for="label-needless_arbitrary_self_type"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_arbitrary_self_type">needless_arbitrary_self_type
<a href="#needless_arbitrary_self_type" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>The lint checks for <code>self</code> in fn parameters that
specify the <code>Self</code>-type explicitly</p>
<h3>Why is this bad?</h3>
<p>Increases the amount and decreases the readability of code</p>
<h3>Example</h3>
<pre><code class="language-rust">enum ValType {
    I32,
    I64,
    F32,
    F64,
}

impl ValType {
    pub fn bytes(self: Self) -&gt; usize {
        match self {
            Self::I32 | Self::F32 =&gt; 4,
            Self::I64 | Self::F64 =&gt; 8,
        }
    }
}
</code></pre>
<p>Could be rewritten as</p>
<pre><code class="language-rust">enum ValType {
    I32,
    I64,
    F32,
    F64,
}

impl ValType {
    pub fn bytes(self) -&gt; usize {
        match self {
            Self::I32 | Self::F32 =&gt; 4,
            Self::I64 | Self::F64 =&gt; 8,
        }
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.47.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_arbitrary_self_type">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_arbitrary_self_type.rs#L9">View Source</a></div></div></div></article><article id="needless_as_bytes"><input id="label-needless_as_bytes" type="checkbox"><label for="label-needless_as_bytes"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_as_bytes">needless_as_bytes
<a href="#needless_as_bytes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>It detects useless calls to <code>str::as_bytes()</code> before calling <code>len()</code> or <code>is_empty()</code>.</p>
<h3>Why is this bad?</h3>
<p>The <code>len()</code> and <code>is_empty()</code> methods are also directly available on strings, and they
return identical results. In particular, <code>len()</code> on a string returns the number of
bytes.</p>
<h3>Example</h3>
<pre><code class="language-rust">let len = "some string".as_bytes().len();
let b = "some string".as_bytes().is_empty();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let len = "some string".len();
let b = "some string".is_empty();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.84.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_as_bytes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4270">View Source</a></div></div></div></article><article id="needless_bitwise_bool"><input id="label-needless_bitwise_bool" type="checkbox"><label for="label-needless_bitwise_bool"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_bitwise_bool">needless_bitwise_bool
<a href="#needless_bitwise_bool" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of bitwise and/or operators between booleans, where performance may be improved by using
a lazy and.</p>
<h3>Why is this bad?</h3>
<p>The bitwise operators do not support short-circuiting, so it may hinder code performance.
Additionally, boolean logic “masked” as bitwise logic is not caught by lints like <code>unnecessary_fold</code></p>
<h3>Known problems</h3>
<p>This lint evaluates only when the right side is determined to have no side effects. At this time, that
determination is quite conservative.</p>
<h3>Example</h3>
<pre><code class="language-rust">let (x,y) = (true, false);
if x &amp; !y {} // where both x and y are booleans
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let (x,y) = (true, false);
if x &amp;&amp; !y {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.54.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_bitwise_bool">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L746">View Source</a></div></div></div></article><article id="needless_bool"><input id="label-needless_bool" type="checkbox"><label for="label-needless_bool"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_bool">needless_bool
<a href="#needless_bool" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for expressions of the form <code>if c { true } else { false }</code> (or vice versa) and suggests using the condition directly.</p>
<h3>Why is this bad?</h3>
<p>Redundant code.</p>
<h3>Known problems</h3>
<p>Maybe false positives: Sometimes, the two branches are
painstakingly documented (which we, of course, do not detect), so they <em>may</em>
have some value. Even then, the documentation can be rewritten to match the
shorter code.</p>
<h3>Example</h3>
<pre><code class="language-rust">if x {
    false
} else {
    true
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">!x
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_bool">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_bool.rs#L14">View Source</a></div></div></div></article><article id="needless_bool_assign"><input id="label-needless_bool_assign" type="checkbox"><label for="label-needless_bool_assign"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_bool_assign">needless_bool_assign
<a href="#needless_bool_assign" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for expressions of the form <code>if c { x = true } else { x = false }</code>
(or vice versa) and suggest assigning the variable directly from the
condition.</p>
<h3>Why is this bad?</h3>
<p>Redundant code.</p>
<h3>Example</h3>
<pre><code class="language-rust">if must_keep(x, y) {
    skip = false;
} else {
    skip = true;
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">skip = !must_keep(x, y);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.71.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_bool_assign">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_bool.rs#L51">View Source</a></div></div></div></article><article id="needless_borrow"><input id="label-needless_borrow" type="checkbox"><label for="label-needless_borrow"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_borrow">needless_borrow
<a href="#needless_borrow" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for address of operations (<code>&amp;</code>) that are going to
be dereferenced immediately by the compiler.</p>
<h3>Why is this bad?</h3>
<p>Suggests that the receiver of the expression borrows
the expression.</p>
<h3>Known problems</h3>
<p>The lint cannot tell when the implementation of a trait
for <code>&amp;T</code> and <code>T</code> do different things. Removing a borrow
in such a case can change the semantics of the code.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn fun(_a: &amp;i32) {}

let x: &amp;i32 = &amp;&amp;&amp;&amp;&amp;&amp;5;
fun(&amp;x);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x: &amp;i32 = &amp;5;
fun(x);
</code></pre>
<h3>Past names</h3>
<ul>
<li>ref_in_deref</li>
</ul>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_borrow">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/dereference.rs#L61">View Source</a></div></div></div></article><article id="needless_borrowed_reference"><input id="label-needless_borrowed_reference" type="checkbox"><label for="label-needless_borrowed_reference"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_borrowed_reference">needless_borrowed_reference
<a href="#needless_borrowed_reference" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for bindings that needlessly destructure a reference and borrow the inner
value with <code>&amp;ref</code>.</p>
<h3>Why is this bad?</h3>
<p>This pattern has no effect in almost all cases.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut v = Vec::&lt;String&gt;::new();
v.iter_mut().filter(|&amp;ref a| a.is_empty());

if let &amp;[ref first, ref second] = v.as_slice() {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut v = Vec::&lt;String&gt;::new();
v.iter_mut().filter(|a| a.is_empty());

if let [first, second] = v.as_slice() {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_borrowed_reference">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_borrowed_ref.rs#L7">View Source</a></div></div></div></article><article id="needless_borrows_for_generic_args"><input id="label-needless_borrows_for_generic_args" type="checkbox"><label for="label-needless_borrows_for_generic_args"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_borrows_for_generic_args">needless_borrows_for_generic_args
<a href="#needless_borrows_for_generic_args" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for borrow operations (<code>&amp;</code>) that are used as a generic argument to a
function when the borrowed value could be used.</p>
<h3>Why is this bad?</h3>
<p>Suggests that the receiver of the expression borrows
the expression.</p>
<h3>Known problems</h3>
<p>The lint cannot tell when the implementation of a trait
for <code>&amp;T</code> and <code>T</code> do different things. Removing a borrow
in such a case can change the semantics of the code.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn f(_: impl AsRef&lt;str&gt;) {}

let x = "foo";
f(&amp;x);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn f(_: impl AsRef&lt;str&gt;) {}

let x = "foo";
f(x);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.74.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_borrows_for_generic_args">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_borrows_for_generic_args.rs#L25">View Source</a></div></div></div></article><article id="needless_character_iteration"><input id="label-needless_character_iteration" type="checkbox"><label for="label-needless_character_iteration"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_character_iteration">needless_character_iteration
<a href="#needless_character_iteration" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks if an iterator is used to check if a string is ascii.</p>
<h3>Why is this bad?</h3>
<p>The <code>str</code> type already implements the <code>is_ascii</code> method.</p>
<h3>Example</h3>
<pre><code class="language-rust">"foo".chars().all(|c| c.is_ascii());
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">"foo".is_ascii();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.81.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_character_iteration">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4200">View Source</a></div></div></div></article><article id="needless_collect"><input id="label-needless_collect" type="checkbox"><label for="label-needless_collect"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_collect">needless_collect
<a href="#needless_collect" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for functions collecting an iterator when collect
is not needed.</p>
<h3>Why is this bad?</h3>
<p><code>collect</code> causes the allocation of a new data structure,
when this allocation may not be needed.</p>
<h3>Example</h3>
<pre><code class="language-rust">let len = iterator.collect::&lt;Vec&lt;_&gt;&gt;().len();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let len = iterator.count();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.30.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_collect">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3344">View Source</a></div></div></div></article><article id="needless_continue"><input id="label-needless_continue" type="checkbox"><label for="label-needless_continue"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_continue">needless_continue
<a href="#needless_continue" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>The lint checks for <code>if</code>-statements appearing in loops
that contain a <code>continue</code> statement in either their main blocks or their
<code>else</code>-blocks, when omitting the <code>else</code>-block possibly with some
rearrangement of code can make the code easier to understand.
The lint also checks if the last statement in the loop is a <code>continue</code></p>
<h3>Why is this bad?</h3>
<p>Having explicit <code>else</code> blocks for <code>if</code> statements
containing <code>continue</code> in their THEN branch adds unnecessary branching and
nesting to the code. Having an else block containing just <code>continue</code> can
also be better written by grouping the statements following the whole <code>if</code>
statement within the THEN block and omitting the else block completely.</p>
<h3>Example</h3>
<pre><code class="language-rust">while condition() {
    update_condition();
    if x {
        // ...
    } else {
        continue;
    }
    println!("Hello, world");
}
</code></pre>
<p>Could be rewritten as</p>
<pre><code class="language-rust">while condition() {
    update_condition();
    if x {
        // ...
        println!("Hello, world");
    }
}
</code></pre>
<p>As another example, the following code</p>
<pre><code class="language-rust">loop {
    if waiting() {
        continue;
    } else {
        // Do something useful
    }
    # break;
}
</code></pre>
<p>Could be rewritten as</p>
<pre><code class="language-rust">loop {
    if waiting() {
        continue;
    }
    // Do something useful
    # break;
}
</code></pre>
<pre><code class="language-rust">
fn foo() -&gt; ErrorKind { ErrorKind::NotFound }
for _ in 0..10 {
    match foo() {
        ErrorKind::NotFound =&gt; {
            eprintln!("not found");
            continue
        }
        ErrorKind::TimedOut =&gt; {
            eprintln!("timeout");
            continue
        }
        _ =&gt; {
            eprintln!("other error");
            continue
        }
    }
}
</code></pre>
<p>Could be rewritten as</p>
<pre><code class="language-rust">
fn foo() -&gt; ErrorKind { ErrorKind::NotFound }
for _ in 0..10 {
    match foo() {
        ErrorKind::NotFound =&gt; {
            eprintln!("not found");
        }
        ErrorKind::TimedOut =&gt; {
            eprintln!("timeout");
        }
        _ =&gt; {
            eprintln!("other error");
        }
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_continue">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_continue.rs#L11">View Source</a></div></div></div></article><article id="needless_doctest_main"><input id="label-needless_doctest_main" type="checkbox"><label for="label-needless_doctest_main"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_doctest_main">needless_doctest_main
<a href="#needless_doctest_main" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>fn main() { .. }</code> in doctests</p>
<h3>Why is this bad?</h3>
<p>The test can be shorter (and likely more readable)
if the <code>fn main()</code> is left implicit.</p>
<h3>Examples</h3>
<pre><code class="language-rust">/// An example of a doctest with a `main()` function
///
/// # Examples
///
/// ```
/// fn main() {
///     // this needs not be in an `fn`
/// }
/// ```
fn needless_main() {
    unimplemented!();
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.40.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_doctest_main">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L214">View Source</a></div></div></div></article><article id="needless_else"><input id="label-needless_else" type="checkbox"><label for="label-needless_else"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_else">needless_else
<a href="#needless_else" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for empty <code>else</code> branches.</p>
<h3>Why is this bad?</h3>
<p>An empty else branch does nothing and can be removed.</p>
<h3>Example</h3>
<pre><code class="language-rust">if check() {
    println!("Check successful!");
} else {
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if check() {
    println!("Check successful!");
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_else">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_else.rs#L8">View Source</a></div></div></div></article><article id="needless_for_each"><input id="label-needless_for_each" type="checkbox"><label for="label-needless_for_each"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_for_each">needless_for_each
<a href="#needless_for_each" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>for_each</code> that would be more simply written as a
<code>for</code> loop.</p>
<h3>Why is this bad?</h3>
<p><code>for_each</code> may be used after applying iterator transformers like
<code>filter</code> for better readability and performance. It may also be used to fit a simple
operation on one line.
But when none of these apply, a simple <code>for</code> loop is more idiomatic.</p>
<h3>Example</h3>
<pre><code class="language-rust">let v = vec![0, 1, 2];
v.iter().for_each(|elem| {
    println!("{elem}");
})
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let v = vec![0, 1, 2];
for elem in &amp;v {
    println!("{elem}");
}
</code></pre>
<h3>Known Problems</h3>
<p>When doing things such as:</p>
<pre><code class="language-rust">let v = vec![0, 1, 2];
v.iter().for_each(|elem| unsafe {
    libc::printf(c"%d\n".as_ptr(), elem);
});
</code></pre>
<p>This lint will not trigger.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.53.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_for_each">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_for_each.rs#L14">View Source</a></div></div></div></article><article id="needless_ifs"><input id="label-needless_ifs" type="checkbox"><label for="label-needless_ifs"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_ifs">needless_ifs
<a href="#needless_ifs" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for empty <code>if</code> branches with no else branch.</p>
<h3>Why is this bad?</h3>
<p>It can be entirely omitted, and often the condition too.</p>
<h3>Known issues</h3>
<p>This will usually only suggest to remove the <code>if</code> statement, not the condition. Other lints
such as <code>no_effect</code> will take care of removing the condition if it’s unnecessary.</p>
<h3>Example</h3>
<pre><code class="language-rust">if really_expensive_condition(&amp;i) {}
if really_expensive_condition_with_side_effects(&amp;mut i) {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// &lt;omitted&gt;
really_expensive_condition_with_side_effects(&amp;mut i);
</code></pre>
<h3>Past names</h3>
<ul>
<li>needless_if</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_ifs">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_ifs.rs#L10">View Source</a></div></div></div></article><article id="needless_late_init"><input id="label-needless_late_init" type="checkbox"><label for="label-needless_late_init"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_late_init">needless_late_init
<a href="#needless_late_init" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for late initializations that can be replaced by a <code>let</code> statement
with an initializer.</p>
<h3>Why is this bad?</h3>
<p>Assigning in the <code>let</code> statement is less repetitive.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a;
a = 1;

let b;
match 3 {
    0 =&gt; b = "zero",
    1 =&gt; b = "one",
    _ =&gt; b = "many",
}

let c;
if true {
    c = 1;
} else {
    c = -1;
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a = 1;

let b = match 3 {
    0 =&gt; "zero",
    1 =&gt; "one",
    _ =&gt; "many",
};

let c = if true {
    1
} else {
    -1
};
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.59.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_late_init">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_late_init.rs#L15">View Source</a></div></div></div></article><article id="needless_lifetimes"><input id="label-needless_lifetimes" type="checkbox"><label for="label-needless_lifetimes"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_lifetimes">needless_lifetimes
<a href="#needless_lifetimes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for lifetime annotations which can be removed by
relying on lifetime elision.</p>
<h3>Why is this bad?</h3>
<p>The additional lifetimes make the code look more
complicated, while there is nothing out of the ordinary going on. Removing
them leads to more readable code.</p>
<h3>Known problems</h3>
<p>This lint ignores functions with <code>where</code> clauses that reference
lifetimes to prevent false positives.</p>
<h3>Example</h3>
<pre><code class="language-rust">// Unnecessary lifetime annotations
fn in_and_out&lt;'a&gt;(x: &amp;'a u8, y: u8) -&gt; &amp;'a u8 {
    x
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn elided(x: &amp;u8, y: u8) -&gt; &amp;u8 {
    x
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_lifetimes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/lifetimes.rs#L30">View Source</a></div></div></div></article><article id="needless_match"><input id="label-needless_match" type="checkbox"><label for="label-needless_match"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_match">needless_match
<a href="#needless_match" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for unnecessary <code>match</code> or match-like <code>if let</code> returns for <code>Option</code> and <code>Result</code>
when function signatures are the same.</p>
<h3>Why is this bad?</h3>
<p>This <code>match</code> block does nothing and might not be what the coder intended.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo() -&gt; Result&lt;(), i32&gt; {
    match result {
        Ok(val) =&gt; Ok(val),
        Err(err) =&gt; Err(err),
    }
}

fn bar() -&gt; Option&lt;i32&gt; {
    if let Some(val) = option {
        Some(val)
    } else {
        None
    }
}
</code></pre>
<p>Could be replaced as</p>
<pre><code class="language-rust">fn foo() -&gt; Result&lt;(), i32&gt; {
    result
}

fn bar() -&gt; Option&lt;i32&gt; {
    option
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.61.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_match">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L616">View Source</a></div></div></div></article><article id="needless_maybe_sized"><input id="label-needless_maybe_sized" type="checkbox"><label for="label-needless_maybe_sized"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_maybe_sized">needless_maybe_sized
<a href="#needless_maybe_sized" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Lints <code>?Sized</code> bounds applied to type parameters that cannot be unsized</p>
<h3>Why is this bad?</h3>
<p>The <code>?Sized</code> bound is misleading because it cannot be satisfied by an
unsized type</p>
<h3>Example</h3>
<pre><code class="language-rust">// `T` cannot be unsized because `Clone` requires it to be `Sized`
fn f&lt;T: Clone + ?Sized&gt;(t: &amp;T) {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn f&lt;T: Clone&gt;(t: &amp;T) {}

// or choose alternative bounds for `T` so that it can be unsized
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.81.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_maybe_sized">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_maybe_sized.rs#L10">View Source</a></div></div></div></article><article id="needless_option_as_deref"><input id="label-needless_option_as_deref" type="checkbox"><label for="label-needless_option_as_deref"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_option_as_deref">needless_option_as_deref
<a href="#needless_option_as_deref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for no-op uses of <code>Option::{as_deref, as_deref_mut}</code>,
for example, <code>Option&lt;&amp;T&gt;::as_deref()</code> returns the same type.</p>
<h3>Why is this bad?</h3>
<p>Redundant code and improving readability.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = Some(&amp;1);
let b = a.as_deref(); // goes from Option&lt;&amp;i32&gt; to Option&lt;&amp;i32&gt;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a = Some(&amp;1);
let b = a;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.57.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_option_as_deref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2403">View Source</a></div></div></div></article><article id="needless_option_take"><input id="label-needless_option_take" type="checkbox"><label for="label-needless_option_take"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_option_take">needless_option_take
<a href="#needless_option_take" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calling <code>take</code> function after <code>as_ref</code>.</p>
<h3>Why is this bad?</h3>
<p>Redundant code. <code>take</code> writes <code>None</code> to its argument.
In this case the modification is useless as it’s a temporary that cannot be read from afterwards.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = Some(3);
x.as_ref().take();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = Some(3);
x.as_ref();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_option_take">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2455">View Source</a></div></div></div></article><article id="needless_parens_on_range_literals"><input id="label-needless_parens_on_range_literals" type="checkbox"><label for="label-needless_parens_on_range_literals"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_parens_on_range_literals">needless_parens_on_range_literals
<a href="#needless_parens_on_range_literals" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>The lint checks for parenthesis on literals in range statements that are
superfluous.</p>
<h3>Why is this bad?</h3>
<p>Having superfluous parenthesis makes the code less readable
overhead when reading.</p>
<h3>Example</h3>
<pre><code class="language-rust">for i in (0)..10 {
  println!("{i}");
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">for i in 0..10 {
  println!("{i}");
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.63.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_parens_on_range_literals">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_parens_on_range_literals.rs#L11">View Source</a></div></div></div></article><article id="needless_pass_by_ref_mut"><input id="label-needless_pass_by_ref_mut" type="checkbox"><label for="label-needless_pass_by_ref_mut"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_pass_by_ref_mut">needless_pass_by_ref_mut
<a href="#needless_pass_by_ref_mut" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Check if a <code>&amp;mut</code> function argument is actually used mutably.</p>
<p>Be careful if the function is publicly reexported as it would break compatibility with
users of this function, when the users pass this function as an argument.</p>
<h3>Why is this bad?</h3>
<p>Less <code>mut</code> means less fights with the borrow checker. It can also lead to more
opportunities for parallelization.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(y: &amp;mut i32) -&gt; i32 {
    12 + *y
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo(y: &amp;i32) -&gt; i32 {
    12 + *y
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_pass_by_ref_mut">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_pass_by_ref_mut.rs#L25">View Source</a></div></div></div></article><article id="needless_pass_by_value"><input id="label-needless_pass_by_value" type="checkbox"><label for="label-needless_pass_by_value"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_pass_by_value">needless_pass_by_value
<a href="#needless_pass_by_value" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for functions taking arguments by value, but not
consuming them in its
body.</p>
<h3>Why is this bad?</h3>
<p>Taking arguments by reference is more flexible and can
sometimes avoid
unnecessary allocations.</p>
<h3>Known problems</h3>
<ul>
<li>This lint suggests taking an argument by reference,
however sometimes it is better to let users decide the argument type
(by using <code>Borrow</code> trait, for example), depending on how the function is used.</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(v: Vec&lt;i32&gt;) {
    assert_eq!(v.len(), 42);
}
</code></pre>
<p>should be</p>
<pre><code class="language-rust">fn foo(v: &amp;[i32]) {
    assert_eq!(v.len(), 42);
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_pass_by_value">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_pass_by_value.rs#L28">View Source</a></div></div></div></article><article id="needless_pub_self"><input id="label-needless_pub_self" type="checkbox"><label for="label-needless_pub_self"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_pub_self">needless_pub_self
<a href="#needless_pub_self" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>pub(self)</code> and <code>pub(in self)</code>.</p>
<h3>Why is this bad?</h3>
<p>It’s unnecessary, omitting the <code>pub</code> entirely will give the same results.</p>
<h3>Example</h3>
<pre><code class="language-rust">pub(self) type OptBox&lt;T&gt; = Option&lt;Box&lt;T&gt;&gt;;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">type OptBox&lt;T&gt; = Option&lt;Box&lt;T&gt;&gt;;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_pub_self">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/visibility.rs#L10">View Source</a></div></div></div></article><article id="needless_question_mark"><input id="label-needless_question_mark" type="checkbox"><label for="label-needless_question_mark"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_question_mark">needless_question_mark
<a href="#needless_question_mark" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Suggests replacing <code>Ok(x?)</code> or <code>Some(x?)</code> with <code>x</code> in return positions where the <code>?</code> operator
is not needed to convert the type of <code>x</code>.</p>
<h3>Why is this bad?</h3>
<p>There’s no reason to use <code>?</code> to short-circuit when execution of the body will end there anyway.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn f(s: &amp;str) -&gt; Option&lt;usize&gt; {
    Some(s.find('x')?)
}

fn g(s: &amp;str) -&gt; Result&lt;usize, ParseIntError&gt; {
    Ok(s.parse()?)
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn f(s: &amp;str) -&gt; Option&lt;usize&gt; {
    s.find('x')
}

fn g(s: &amp;str) -&gt; Result&lt;usize, ParseIntError&gt; {
    s.parse()
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.51.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_question_mark">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_question_mark.rs#L9">View Source</a></div></div></div></article><article id="needless_range_loop"><input id="label-needless_range_loop" type="checkbox"><label for="label-needless_range_loop"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_range_loop">needless_range_loop
<a href="#needless_range_loop" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for looping over the range of <code>0..len</code> of some
collection just to get the values by index.</p>
<h3>Why is this bad?</h3>
<p>Just iterating the collection itself makes the intent
more clear and is probably faster because it eliminates
the bounds check that is done when indexing.</p>
<h3>Example</h3>
<pre><code class="language-rust">let vec = vec!['a', 'b', 'c'];
for i in 0..vec.len() {
    println!("{}", vec[i]);
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let vec = vec!['a', 'b', 'c'];
for i in vec {
    println!("{}", i);
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_range_loop">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L67">View Source</a></div></div></div></article><article id="needless_raw_string_hashes"><input id="label-needless_raw_string_hashes" type="checkbox"><label for="label-needless_raw_string_hashes"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_raw_string_hashes">needless_raw_string_hashes
<a href="#needless_raw_string_hashes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for raw string literals with an unnecessary amount of hashes around them.</p>
<h3>Why is this bad?</h3>
<p>It’s just unnecessary, and makes it look like there’s more escaping needed than is actually
necessary.</p>
<h3>Example</h3>
<pre><code class="language-rust">let r = r###"Hello, "world"!"###;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let r = r#"Hello, "world"!"#;
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allow-one-hash-in-raw-strings</code>:  Whether to allow <code>r#""#</code> when <code>r""</code> can be used</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_raw_string_hashes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/raw_strings.rs#L36">View Source</a></div></div></div></article><article id="needless_raw_strings"><input id="label-needless_raw_strings" type="checkbox"><label for="label-needless_raw_strings"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_raw_strings">needless_raw_strings
<a href="#needless_raw_strings" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for raw string literals where a string literal can be used instead.</p>
<h3>Why restrict this?</h3>
<p>For consistent style by using simpler string literals whenever possible.</p>
<p>However, there are many cases where using a raw string literal is more
idiomatic than a string literal, so it’s opt-in.</p>
<h3>Example</h3>
<pre><code class="language-rust">let r = r"Hello, world!";
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let r = "Hello, world!";
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_raw_strings">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/raw_strings.rs#L13">View Source</a></div></div></div></article><article id="needless_return"><input id="label-needless_return" type="checkbox"><label for="label-needless_return"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_return">needless_return
<a href="#needless_return" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for return statements at the end of a block.</p>
<h3>Why is this bad?</h3>
<p>Removing the <code>return</code> and semicolon will make the code
more rusty.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(x: usize) -&gt; usize {
    return x;
}
</code></pre>
<p>simplify to</p>
<pre><code class="language-rust">fn foo(x: usize) -&gt; usize {
    x
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_return">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/returns/mod.rs#L46">View Source</a></div></div></div></article><article id="needless_return_with_question_mark"><input id="label-needless_return_with_question_mark" type="checkbox"><label for="label-needless_return_with_question_mark"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_return_with_question_mark">needless_return_with_question_mark
<a href="#needless_return_with_question_mark" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for return statements on <code>Err</code> paired with the <code>?</code> operator.</p>
<h3>Why is this bad?</h3>
<p>The <code>return</code> is unnecessary.</p>
<p>Returns may be used to add attributes to the return expression. Return
statements with attributes are therefore be accepted by this lint.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(x: usize) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    if x == 0 {
        return Err(...)?;
    }
    Ok(())
}
</code></pre>
<p>simplify to</p>
<pre><code class="language-rust">fn foo(x: usize) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    if x == 0 {
        Err(...)?;
    }
    Ok(())
}
</code></pre>
<p>if paired with <code>try_err</code>, use instead:</p>
<pre><code class="language-rust">fn foo(x: usize) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    if x == 0 {
        return Err(...);
    }
    Ok(())
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_return_with_question_mark">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/returns/mod.rs#L75">View Source</a></div></div></div></article><article id="needless_splitn"><input id="label-needless_splitn" type="checkbox"><label for="label-needless_splitn"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_splitn">needless_splitn
<a href="#needless_splitn" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>str::splitn</code> (or <code>str::rsplitn</code>) where using <code>str::split</code> would be the same.</p>
<h3>Why is this bad?</h3>
<p>The function <code>split</code> is simpler and there is no performance difference in these cases, considering
that both functions return a lazy iterator.</p>
<h3>Example</h3>
<pre><code class="language-rust">let str = "key=value=add";
let _ = str.splitn(3, '=').next().unwrap();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let str = "key=value=add";
let _ = str.split('=').next().unwrap();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.59.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_splitn">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2317">View Source</a></div></div></div></article><article id="needless_type_cast"><input id="label-needless_type_cast" type="checkbox"><label for="label-needless_type_cast"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_type_cast">needless_type_cast
<a href="#needless_type_cast" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for bindings (constants, statics, or let bindings) that are defined
with one numeric type but are consistently cast to a different type in all usages.</p>
<h3>Why is this bad?</h3>
<p>If a binding is always cast to a different type when used, it would be clearer
and more efficient to define it with the target type from the start.</p>
<h3>Example</h3>
<pre><code class="language-rust">const SIZE: u16 = 15;
let arr: [u8; SIZE as usize] = [0; SIZE as usize];
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">const SIZE: usize = 15;
let arr: [u8; SIZE] = [0; SIZE];
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.93.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_type_cast">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L817">View Source</a></div></div></div></article><article id="needless_update"><input id="label-needless_update" type="checkbox"><label for="label-needless_update"><h2 class="lint-title"><div class="panel-title-name" id="lint-needless_update">needless_update
<a href="#needless_update" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for needlessly including a base struct on update
when all fields are changed anyway.</p>
<p>This lint is not applied to structs marked with
<a href="https://doc.rust-lang.org/reference/attributes/type_system.html">non_exhaustive</a>.</p>
<h3>Why is this bad?</h3>
<p>This will cost resources (because the base has to be
somewhere), and make the code less readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">Point {
    x: 1,
    y: 1,
    z: 1,
    ..zero_point
};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// Missing field `z`
Point {
    x: 1,
    y: 1,
    ..zero_point
};
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+needless_update">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/needless_update.rs#L7">View Source</a></div></div></div></article><article id="neg_cmp_op_on_partial_ord"><input id="label-neg_cmp_op_on_partial_ord" type="checkbox"><label for="label-neg_cmp_op_on_partial_ord"><h2 class="lint-title"><div class="panel-title-name" id="lint-neg_cmp_op_on_partial_ord">neg_cmp_op_on_partial_ord
<a href="#neg_cmp_op_on_partial_ord" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the usage of negated comparison operators on types which only implement
<code>PartialOrd</code> (e.g., <code>f64</code>).</p>
<h3>Why is this bad?</h3>
<p>These operators make it easy to forget that the underlying types actually allow not only three
potential Orderings (Less, Equal, Greater) but also a fourth one (Uncomparable). This is
especially easy to miss if the operator based comparison result is negated.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = 1.0;
let b = f64::NAN;

let not_less_or_equal = !(a &lt;= b);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::cmp::Ordering;

let _not_less_or_equal = match a.partial_cmp(&amp;b) {
    None | Some(Ordering::Greater) =&gt; true,
    _ =&gt; false,
};
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+neg_cmp_op_on_partial_ord">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/neg_cmp_op_on_partial_ord.rs#L8">View Source</a></div></div></div></article><article id="neg_multiply"><input id="label-neg_multiply" type="checkbox"><label for="label-neg_multiply"><h2 class="lint-title"><div class="panel-title-name" id="lint-neg_multiply">neg_multiply
<a href="#neg_multiply" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for multiplication by -1 as a form of negation.</p>
<h3>Why is this bad?</h3>
<p>It’s more readable to just negate.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = x * -1;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a = -x;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+neg_multiply">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/neg_multiply.rs#L12">View Source</a></div></div></div></article><article id="negative_feature_names"><input id="label-negative_feature_names" type="checkbox"><label for="label-negative_feature_names"><h2 class="lint-title"><div class="panel-title-name" id="lint-negative_feature_names">negative_feature_names
<a href="#negative_feature_names" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-cargo">cargo</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for negative feature names with prefix <code>no-</code> or <code>not-</code></p>
<h3>Why is this bad?</h3>
<p>Features are supposed to be additive, and negatively-named features violate it.</p>
<h3>Example</h3>
<pre><code class="language-toml">[features]
default = []
no-abc = []
not-def = []

</code></pre>
<p>Use instead:</p>
<pre><code class="language-toml">[features]
default = ["abc", "def"]
abc = []
def = []

</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.57.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+negative_feature_names">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/cargo/mod.rs#L91">View Source</a></div></div></div></article><article id="never_loop"><input id="label-never_loop" type="checkbox"><label for="label-never_loop"><h2 class="lint-title"><div class="panel-title-name" id="lint-never_loop">never_loop
<a href="#never_loop" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for loops that will always <code>break</code>, <code>return</code> or
<code>continue</code> an outer loop.</p>
<h3>Why is this bad?</h3>
<p>This loop never loops, all it does is obfuscating the
code.</p>
<h3>Example</h3>
<pre><code class="language-rust">loop {
    ..;
    break;
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+never_loop">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L340">View Source</a></div></div></div></article><article id="new_ret_no_self"><input id="label-new_ret_no_self" type="checkbox"><label for="label-new_ret_no_self"><h2 class="lint-title"><div class="panel-title-name" id="lint-new_ret_no_self">new_ret_no_self
<a href="#new_ret_no_self" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>new</code> not returning a type that contains <code>Self</code>.</p>
<h3>Why is this bad?</h3>
<p>As a convention, <code>new</code> methods are used to make a new
instance of a type.</p>
<h3>Example</h3>
<p>In an impl block:</p>
<pre><code class="language-rust">impl Foo {
    fn new() -&gt; NotAFoo {
    }
}
</code></pre>
<pre><code class="language-rust">struct Bar(Foo);
impl Foo {
    // Bad. The type name must contain `Self`
    fn new() -&gt; Bar {
    }
}
</code></pre>
<pre><code class="language-rust">impl Foo {
    // Good. Return type contains `Self`
    fn new() -&gt; Result&lt;Foo, FooError&gt; {
    }
}
</code></pre>
<p>Or in a trait definition:</p>
<pre><code class="language-rust">pub trait Trait {
    // Bad. The type name must contain `Self`
    fn new();
}
</code></pre>
<pre><code class="language-rust">pub trait Trait {
    // Good. Return type contains `Self`
    fn new() -&gt; Self;
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+new_ret_no_self">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1104">View Source</a></div></div></div></article><article id="new_without_default"><input id="label-new_without_default" type="checkbox"><label for="label-new_without_default"><h2 class="lint-title"><div class="panel-title-name" id="lint-new_without_default">new_without_default
<a href="#new_without_default" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for public types with a <code>pub fn new() -&gt; Self</code> method and no
implementation of
<a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>.</p>
<h3>Why is this bad?</h3>
<p>The user might expect to be able to use
<a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> as the
type can be constructed without arguments.</p>
<h3>Example</h3>
<pre><code class="language-rust">pub struct Foo(Bar);

impl Foo {
    pub fn new() -&gt; Self {
        Foo(Bar::new())
    }
}
</code></pre>
<p>To fix the lint, add a <code>Default</code> implementation that delegates to <code>new</code>:</p>
<pre><code class="language-rust">pub struct Foo(Bar);

impl Default for Foo {
    fn default() -&gt; Self {
        Foo::new()
    }
}
</code></pre>
<h3>Past names</h3>
<ul>
<li>new_without_default_derive</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+new_without_default">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/new_without_default.rs#L14">View Source</a></div></div></div></article><article id="no_effect"><input id="label-no_effect" type="checkbox"><label for="label-no_effect"><h2 class="lint-title"><div class="panel-title-name" id="lint-no_effect">no_effect
<a href="#no_effect" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for statements which have no effect.</p>
<h3>Why is this bad?</h3>
<p>Unlike dead code, these statements are actually
executed. However, as they have no effect, all they do is make the code less
readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">0;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+no_effect">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/no_effect.rs#L19">View Source</a></div></div></div></article><article id="no_effect_replace"><input id="label-no_effect_replace" type="checkbox"><label for="label-no_effect_replace"><h2 class="lint-title"><div class="panel-title-name" id="lint-no_effect_replace">no_effect_replace
<a href="#no_effect_replace" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>replace</code> statements which have no effect.</p>
<h3>Why is this bad?</h3>
<p>It’s either a mistake or confusing.</p>
<h3>Example</h3>
<pre><code class="language-rust">"1234".replace("12", "12");
"1234".replacen("12", "12", 1);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.63.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+no_effect_replace">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2479">View Source</a></div></div></div></article><article id="no_effect_underscore_binding"><input id="label-no_effect_underscore_binding" type="checkbox"><label for="label-no_effect_underscore_binding"><h2 class="lint-title"><div class="panel-title-name" id="lint-no_effect_underscore_binding">no_effect_underscore_binding
<a href="#no_effect_underscore_binding" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for binding to underscore prefixed variable without side-effects.</p>
<h3>Why is this bad?</h3>
<p>Unlike dead code, these bindings are actually
executed. However, as they have no effect and shouldn’t be used further on, all they
do is make the code less readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _i_serve_no_purpose = 1;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.58.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+no_effect_underscore_binding">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/no_effect.rs#L38">View Source</a></div></div></div></article><article id="no_mangle_with_rust_abi"><input id="label-no_mangle_with_rust_abi" type="checkbox"><label for="label-no_mangle_with_rust_abi"><h2 class="lint-title"><div class="panel-title-name" id="lint-no_mangle_with_rust_abi">no_mangle_with_rust_abi
<a href="#no_mangle_with_rust_abi" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for Rust ABI functions with the <code>#[no_mangle]</code> attribute.</p>
<h3>Why is this bad?</h3>
<p>The Rust ABI is not stable, but in many simple cases matches
enough with the C ABI that it is possible to forget to add
<code>extern "C"</code> to a function called from C. Changes to the
Rust ABI can break this at any point.</p>
<h3>Example</h3>
<pre><code class="language-rust"> #[no_mangle]
 fn example(arg_one: u32, arg_two: usize) {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust"> #[no_mangle]
 extern "C" fn example(arg_one: u32, arg_two: usize) {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.69.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+no_mangle_with_rust_abi">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/no_mangle_with_rust_abi.rs#L11">View Source</a></div></div></div></article><article id="non_ascii_literal"><input id="label-non_ascii_literal" type="checkbox"><label for="label-non_ascii_literal"><h2 class="lint-title"><div class="panel-title-name" id="lint-non_ascii_literal">non_ascii_literal
<a href="#non_ascii_literal" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for non-ASCII characters in string and char literals.</p>
<h3>Why restrict this?</h3>
<p>Yeah, we know, the 90’s called and wanted their charset
back. Even so, there still are editors and other programs out there that
don’t work well with Unicode. So if the code is meant to be used
internationally, on multiple operating systems, or has other portability
requirements, activating this lint could be useful.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = String::from("€");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = String::from("\u{20ac}");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+non_ascii_literal">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unicode.rs#L30">View Source</a></div></div></div></article><article id="non_canonical_clone_impl"><input id="label-non_canonical_clone_impl" type="checkbox"><label for="label-non_canonical_clone_impl"><h2 class="lint-title"><div class="panel-title-name" id="lint-non_canonical_clone_impl">non_canonical_clone_impl
<a href="#non_canonical_clone_impl" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for non-canonical implementations of <code>Clone</code> when <code>Copy</code> is already implemented.</p>
<h3>Why is this bad?</h3>
<p>If both <code>Clone</code> and <code>Copy</code> are implemented, they must agree. This can done by dereferencing
<code>self</code> in <code>Clone</code>’s implementation, which will avoid any possibility of the implementations
becoming out of sync.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[derive(Eq, PartialEq)]
struct A(u32);

impl Clone for A {
    fn clone(&amp;self) -&gt; Self {
        Self(self.0)
    }
}

impl Copy for A {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[derive(Eq, PartialEq)]
struct A(u32);

impl Clone for A {
    fn clone(&amp;self) -&gt; Self {
        *self
    }
}

impl Copy for A {}
</code></pre>
<h3>Past names</h3>
<ul>
<li>incorrect_clone_impl_on_copy_type</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+non_canonical_clone_impl">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/non_canonical_impls.rs#L14">View Source</a></div></div></div></article><article id="non_canonical_partial_ord_impl"><input id="label-non_canonical_partial_ord_impl" type="checkbox"><label for="label-non_canonical_partial_ord_impl"><h2 class="lint-title"><div class="panel-title-name" id="lint-non_canonical_partial_ord_impl">non_canonical_partial_ord_impl
<a href="#non_canonical_partial_ord_impl" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for non-canonical implementations of <code>PartialOrd</code> when <code>Ord</code> is already implemented.</p>
<h3>Why is this bad?</h3>
<p>If both <code>PartialOrd</code> and <code>Ord</code> are implemented, they must agree. This is commonly done by
wrapping the result of <code>cmp</code> in <code>Some</code> for <code>partial_cmp</code>. Not doing this may silently
introduce an error upon refactoring.</p>
<h3>Known issues</h3>
<p>Code that calls the <code>.into()</code> method instead will be flagged, despite <code>.into()</code> wrapping it
in <code>Some</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[derive(Eq, PartialEq)]
struct A(u32);

impl Ord for A {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        // ...
    }
}

impl PartialOrd for A {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        // ...
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[derive(Eq, PartialEq)]
struct A(u32);

impl Ord for A {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        // ...
    }
}

impl PartialOrd for A {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        Some(self.cmp(other))   // or self.cmp(other).into()
    }
}
</code></pre>
<h3>Past names</h3>
<ul>
<li>incorrect_partial_ord_impl_on_ord_type</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+non_canonical_partial_ord_impl">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/non_canonical_impls.rs#L54">View Source</a></div></div></div></article><article id="non_minimal_cfg"><input id="label-non_minimal_cfg" type="checkbox"><label for="label-non_minimal_cfg"><h2 class="lint-title"><div class="panel-title-name" id="lint-non_minimal_cfg">non_minimal_cfg
<a href="#non_minimal_cfg" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>any</code> and <code>all</code> combinators in <code>cfg</code> with only one condition.</p>
<h3>Why is this bad?</h3>
<p>If there is only one condition, no need to wrap it into <code>any</code> or <code>all</code> combinators.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[cfg(any(unix))]
pub struct Bar;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[cfg(unix)]
pub struct Bar;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.71.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+non_minimal_cfg">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/attrs/mod.rs#L315">View Source</a></div></div></div></article><article id="non_octal_unix_permissions"><input id="label-non_octal_unix_permissions" type="checkbox"><label for="label-non_octal_unix_permissions"><h2 class="lint-title"><div class="panel-title-name" id="lint-non_octal_unix_permissions">non_octal_unix_permissions
<a href="#non_octal_unix_permissions" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for non-octal values used to set Unix file permissions.</p>
<h3>Why is this bad?</h3>
<p>They will be converted into octal, creating potentially
unintended file permissions.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::fs::OpenOptions;
use std::os::unix::fs::OpenOptionsExt;

let mut options = OpenOptions::new();
options.mode(644);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::fs::OpenOptions;
use std::os::unix::fs::OpenOptionsExt;

let mut options = OpenOptions::new();
options.mode(0o644);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.53.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+non_octal_unix_permissions">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/non_octal_unix_permissions.rs#L9">View Source</a></div></div></div></article><article id="non_send_fields_in_send_ty"><input id="label-non_send_fields_in_send_ty" type="checkbox"><label for="label-non_send_fields_in_send_ty"><h2 class="lint-title"><div class="panel-title-name" id="lint-non_send_fields_in_send_ty">non_send_fields_in_send_ty
<a href="#non_send_fields_in_send_ty" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint warns about a <code>Send</code> implementation for a type that
contains fields that are not safe to be sent across threads.
It tries to detect fields that can cause a soundness issue
when sent to another thread (e.g., <code>Rc</code>) while allowing <code>!Send</code> fields
that are expected to exist in a <code>Send</code> type, such as raw pointers.</p>
<h3>Why is this bad?</h3>
<p>Sending the struct to another thread effectively sends all of its fields,
and the fields that do not implement <code>Send</code> can lead to soundness bugs
such as data races when accessed in a thread
that is different from the thread that created it.</p>
<p>See:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/send-and-sync.html"><em>The Rustonomicon</em> about <em>Send and Sync</em></a></li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Send.html">The documentation of <code>Send</code></a></li>
</ul>
<h3>Known Problems</h3>
<p>This lint relies on heuristics to distinguish types that are actually
unsafe to be sent across threads and <code>!Send</code> types that are expected to
exist in  <code>Send</code> type. Its rule can filter out basic cases such as
<code>Vec&lt;*const T&gt;</code>, but it’s not perfect. Feel free to create an issue if
you have a suggestion on how this heuristic can be improved.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct ExampleStruct&lt;T&gt; {
    rc_is_not_send: Rc&lt;String&gt;,
    unbounded_generic_field: T,
}

// This impl is unsound because it allows sending `!Send` types through `ExampleStruct`
unsafe impl&lt;T&gt; Send for ExampleStruct&lt;T&gt; {}
</code></pre>
<p>Use thread-safe types like <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>std::sync::Arc</code></a>
or specify correct bounds on generic type parameters (<code>T: Send</code>).</p>
<h3>Configuration</h3>
<ul>
<li>
<p><code>enable-raw-pointer-heuristic-for-send</code>:  Whether to apply the raw pointer heuristic to determine if a type is <code>Send</code>.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.57.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+non_send_fields_in_send_ty">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/non_send_fields_in_send_ty.rs#L14">View Source</a></div></div></div></article><article id="non_std_lazy_statics"><input id="label-non_std_lazy_statics" type="checkbox"><label for="label-non_std_lazy_statics"><h2 class="lint-title"><div class="panel-title-name" id="lint-non_std_lazy_statics">non_std_lazy_statics
<a href="#non_std_lazy_statics" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Lints when <code>once_cell::sync::Lazy</code> or <code>lazy_static!</code> are used to define a static variable,
and suggests replacing such cases with <code>std::sync::LazyLock</code> instead.</p>
<p>Note: This lint will not trigger in crate with <code>no_std</code> context, or with MSRV &lt; 1.80.0. It
also will not trigger on <code>once_cell::sync::Lazy</code> usage in crates which use other types
from <code>once_cell</code>, such as <code>once_cell::race::OnceBox</code>.</p>
<h3>Why restrict this?</h3>
<ul>
<li>Reduces the need for an extra dependency</li>
<li>Enforce convention of using standard library types when possible</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">lazy_static! {
    static ref FOO: String = "foo".to_uppercase();
}
static BAR: once_cell::sync::Lazy&lt;String&gt; = once_cell::sync::Lazy::new(|| "BAR".to_lowercase());
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">static FOO: std::sync::LazyLock&lt;String&gt; = std::sync::LazyLock::new(|| "FOO".to_lowercase());
static BAR: std::sync::LazyLock&lt;String&gt; = std::sync::LazyLock::new(|| "BAR".to_lowercase());
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.86.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+non_std_lazy_statics">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/non_std_lazy_statics.rs#L17">View Source</a></div></div></div></article><article id="non_zero_suggestions"><input id="label-non_zero_suggestions" type="checkbox"><label for="label-non_zero_suggestions"><h2 class="lint-title"><div class="panel-title-name" id="lint-non_zero_suggestions">non_zero_suggestions
<a href="#non_zero_suggestions" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for conversions from <code>NonZero</code> types to regular integer types,
and suggests using <code>NonZero</code> types for the target as well.</p>
<h3>Why is this bad?</h3>
<p>Converting from <code>NonZero</code> types to regular integer types and then back to <code>NonZero</code>
types is less efficient and loses the type-safety guarantees provided by <code>NonZero</code> types.
Using <code>NonZero</code> types consistently can lead to more optimized code and prevent
certain classes of errors related to zero values.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::num::{NonZeroU32, NonZeroU64};

fn example(x: u64, y: NonZeroU32) {
    // Bad: Converting NonZeroU32 to u64 unnecessarily
    let r1 = x / u64::from(y.get());
    let r2 = x % u64::from(y.get());
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::num::{NonZeroU32, NonZeroU64};

fn example(x: u64, y: NonZeroU32) {
    // Good: Preserving the NonZero property
    let r1 = x / NonZeroU64::from(y);
    let r2 = x % NonZeroU64::from(y);
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.83.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+non_zero_suggestions">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/non_zero_suggestions.rs#L11">View Source</a></div></div></div></article><article id="nonminimal_bool"><input id="label-nonminimal_bool" type="checkbox"><label for="label-nonminimal_bool"><h2 class="lint-title"><div class="panel-title-name" id="lint-nonminimal_bool">nonminimal_bool
<a href="#nonminimal_bool" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for boolean expressions that can be written more
concisely.</p>
<h3>Why is this bad?</h3>
<p>Readability of boolean expressions suffers from
unnecessary duplication.</p>
<h3>Known problems</h3>
<p>Ignores short circuiting behavior of <code>||</code> and
<code>&amp;&amp;</code>. Ignores <code>|</code>, <code>&amp;</code> and <code>^</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">if a &amp;&amp; true {}
if !(a == b) {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if a {}
if a != b {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+nonminimal_bool">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/booleans.rs#L20">View Source</a></div></div></div></article><article id="nonsensical_open_options"><input id="label-nonsensical_open_options" type="checkbox"><label for="label-nonsensical_open_options"><h2 class="lint-title"><div class="panel-title-name" id="lint-nonsensical_open_options">nonsensical_open_options
<a href="#nonsensical_open_options" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for duplicate open options as well as combinations
that make no sense.</p>
<h3>Why is this bad?</h3>
<p>In the best case, the code will be harder to read than
necessary. I don’t know the worst case.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::fs::OpenOptions;

OpenOptions::new().read(true).truncate(true);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+nonsensical_open_options">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2891">View Source</a></div></div></div></article><article id="nonstandard_macro_braces"><input id="label-nonstandard_macro_braces" type="checkbox"><label for="label-nonstandard_macro_braces"><h2 class="lint-title"><div class="panel-title-name" id="lint-nonstandard_macro_braces">nonstandard_macro_braces
<a href="#nonstandard_macro_braces" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks that common macros are used with consistent bracing.</p>
<h3>Why is this bad?</h3>
<p>Having non-conventional braces on well-stablished macros can be confusing
when debugging, and they bring incosistencies with the rest of the ecosystem.</p>
<h3>Example</h3>
<pre><code class="language-rust">vec!{1, 2, 3};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">vec![1, 2, 3];
</code></pre>
<h3>Configuration</h3>
<ul>
<li><code>standard-macro-braces</code>:  Enforce the named macros always use the braces specified.</li>
</ul>
<p>A <code>MacroMatcher</code> can be added like so <code>{ name = "macro_name", brace = "(" }</code>. If the macro
could be used with a full path two <code>MacroMatcher</code>s have to be added one with the full path
<code>crate_name::macro_name</code> and one with just the macro name.</p>
<p>(default: <code>[]</code>)</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.55.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+nonstandard_macro_braces">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/nonstandard_macro_braces.rs#L14">View Source</a></div></div></div></article><article id="not_unsafe_ptr_arg_deref"><input id="label-not_unsafe_ptr_arg_deref" type="checkbox"><label for="label-not_unsafe_ptr_arg_deref"><h2 class="lint-title"><div class="panel-title-name" id="lint-not_unsafe_ptr_arg_deref">not_unsafe_ptr_arg_deref
<a href="#not_unsafe_ptr_arg_deref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for public functions that dereference raw pointer
arguments but are not marked <code>unsafe</code>.</p>
<h3>Why is this bad?</h3>
<p>The function should almost definitely be marked <code>unsafe</code>, since for an
arbitrary raw pointer, there is no way of telling for sure if it is valid.</p>
<p>In general, this lint should <strong>never be disabled</strong> unless it is definitely a
false positive (please submit an issue if so) since it breaks Rust’s
soundness guarantees, directly exposing API users to potentially dangerous
program behavior. This is also true for internal APIs, as it is easy to leak
unsoundness.</p>
<h3>Context</h3>
<p>In Rust, an <code>unsafe {...}</code> block is used to indicate that the code in that
section has been verified in some way that the compiler can not. For a
function that accepts a raw pointer then accesses the pointer’s data, this is
generally impossible as the incoming pointer could point anywhere, valid or
not. So, the signature should be marked <code>unsafe fn</code>: this indicates that the
function’s caller must provide some verification that the arguments it sends
are valid (and then call the function within an <code>unsafe</code> block).</p>
<h3>Known problems</h3>
<ul>
<li>It does not check functions recursively so if the pointer is passed to a
private non-<code>unsafe</code> function which does the dereferencing, the lint won’t
trigger (false negative).</li>
<li>It only checks for arguments whose type are raw pointers, not raw pointers
got from an argument in some other way (<code>fn foo(bar: &amp;[*const u8])</code> or
<code>some_argument.get_raw_ptr()</code>) (false negative).</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">pub fn foo(x: *const u8) {
    println!("{}", unsafe { *x });
}

// this call "looks" safe but will segfault or worse!
// foo(invalid_ptr);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">pub unsafe fn foo(x: *const u8) {
    println!("{}", unsafe { *x });
}

// this would cause a compiler error for calling without `unsafe`
// foo(invalid_ptr);

// sound call if the caller knows the pointer is valid
unsafe { foo(valid_ptr); }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+not_unsafe_ptr_arg_deref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/functions/mod.rs#L93">View Source</a></div></div></div></article><article id="obfuscated_if_else"><input id="label-obfuscated_if_else" type="checkbox"><label for="label-obfuscated_if_else"><h2 class="lint-title"><div class="panel-title-name" id="lint-obfuscated_if_else">obfuscated_if_else
<a href="#obfuscated_if_else" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for unnecessary method chains that can be simplified into <code>if .. else ..</code>.</p>
<h3>Why is this bad?</h3>
<p>This can be written more clearly with <code>if .. else ..</code></p>
<h3>Limitations</h3>
<p>This lint currently only looks for usages of
<code>.{then, then_some}(..).{unwrap_or, unwrap_or_else, unwrap_or_default}(..)</code>, but will be expanded
to account for similar patterns.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = true;
x.then_some("a").unwrap_or("b");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = true;
if x { "a" } else { "b" };
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.64.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+obfuscated_if_else">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2497">View Source</a></div></div></div></article><article id="octal_escapes"><input id="label-octal_escapes" type="checkbox"><label for="label-octal_escapes"><h2 class="lint-title"><div class="panel-title-name" id="lint-octal_escapes">octal_escapes
<a href="#octal_escapes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>\0</code> escapes in string and byte literals that look like octal
character escapes in C.</p>
<h3>Why is this bad?</h3>
<p>C and other languages support octal character escapes in strings, where
a backslash is followed by up to three octal digits. For example, <code>\033</code>
stands for the ASCII character 27 (ESC). Rust does not support this
notation, but has the escape code <code>\0</code> which stands for a null
byte/character, and any following digits do not form part of the escape
sequence. Therefore, <code>\033</code> is not a compiler error but the result may
be surprising.</p>
<h3>Known problems</h3>
<p>The actual meaning can be the intended one. <code>\x00</code> can be used in these
cases to be unambiguous.</p>
<p>The lint does not trigger for format strings in <code>print!()</code>, <code>write!()</code>
and friends since the string is already preprocessed when Clippy lints
can see it.</p>
<h3>Example</h3>
<pre><code class="language-rust">let one = "\033[1m Bold? \033[0m";  // \033 intended as escape
let two = "\033\0";                 // \033 intended as null-3-3
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let one = "\x1b[1mWill this be bold?\x1b[0m";
let two = "\x0033\x00";
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.59.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+octal_escapes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/octal_escapes.rs#L10">View Source</a></div></div></div></article><article id="ok_expect"><input id="label-ok_expect" type="checkbox"><label for="label-ok_expect"><h2 class="lint-title"><div class="panel-title-name" id="lint-ok_expect">ok_expect
<a href="#ok_expect" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>ok().expect(..)</code>.</p>
<p>Note: This lint only triggers for code marked compatible
with versions of the compiler older than Rust 1.82.0.</p>
<h3>Why is this bad?</h3>
<p>Because you usually call <code>expect()</code> on the <code>Result</code>
directly to get a better error message.</p>
<h3>Example</h3>
<pre><code class="language-rust">x.ok().expect("why did I do this again?");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">x.expect("why did I do this again?");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ok_expect">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L476">View Source</a></div></div></div></article><article id="only_used_in_recursion"><input id="label-only_used_in_recursion" type="checkbox"><label for="label-only_used_in_recursion"><h2 class="lint-title"><div class="panel-title-name" id="lint-only_used_in_recursion">only_used_in_recursion
<a href="#only_used_in_recursion" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for arguments that are only used in recursion with no side-effects.</p>
<h3>Why is this bad?</h3>
<p>It could contain a useless calculation and can make function simpler.</p>
<p>The arguments can be involved in calculations and assignments but as long as
the calculations have no side-effects (function calls or mutating dereference)
and the assigned variables are also only in recursion, it is useless.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn f(a: usize, b: usize) -&gt; usize {
    if a == 0 {
        1
    } else {
        f(a - 1, b + 1)
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn f(a: usize) -&gt; usize {
    if a == 0 {
        1
    } else {
        f(a - 1)
    }
}
</code></pre>
<h3>Known problems</h3>
<p>Too many code paths in the linting code are currently untested and prone to produce false
positives or are prone to have performance implications.</p>
<p>In some cases, this would not catch all useless arguments.</p>
<pre><code class="language-rust">fn foo(a: usize, b: usize) -&gt; usize {
    let f = |x| x + 1;

    if a == 0 {
        1
    } else {
        foo(a - 1, f(b))
    }
}
</code></pre>
<p>For example, the argument <code>b</code> is only used in recursion, but the lint would not catch it.</p>
<p>List of some examples that can not be caught:</p>
<ul>
<li>binary operation of non-primitive types</li>
<li>closure usage</li>
<li>some <code>break</code> relative operations</li>
<li>struct pattern binding</li>
</ul>
<p>Also, when you recurse the function name with path segments, it is not possible to detect.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.61.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+only_used_in_recursion">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/only_used_in_recursion.rs#L19">View Source</a></div></div></div></article><article id="op_ref"><input id="label-op_ref" type="checkbox"><label for="label-op_ref"><h2 class="lint-title"><div class="panel-title-name" id="lint-op_ref">op_ref
<a href="#op_ref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for arguments to <code>==</code> which have their address
taken to satisfy a bound
and suggests to dereference the other argument instead</p>
<h3>Why is this bad?</h3>
<p>It is more idiomatic to dereference the other argument.</p>
<h3>Example</h3>
<pre><code class="language-rust">&amp;x == y
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">x == *y
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+op_ref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L421">View Source</a></div></div></div></article><article id="option_as_ref_cloned"><input id="label-option_as_ref_cloned" type="checkbox"><label for="label-option_as_ref_cloned"><h2 class="lint-title"><div class="panel-title-name" id="lint-option_as_ref_cloned">option_as_ref_cloned
<a href="#option_as_ref_cloned" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.as_ref().cloned()</code> and <code>.as_mut().cloned()</code> on <code>Option</code>s</p>
<h3>Why is this bad?</h3>
<p>This can be written more concisely by cloning the <code>Option</code> directly.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(bar: &amp;Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {
    bar.as_ref().cloned()
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo(bar: &amp;Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {
    bar.clone()
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.77.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+option_as_ref_cloned">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4001">View Source</a></div></div></div></article><article id="option_as_ref_deref"><input id="label-option_as_ref_deref" type="checkbox"><label for="label-option_as_ref_deref"><h2 class="lint-title"><div class="panel-title-name" id="lint-option_as_ref_deref">option_as_ref_deref
<a href="#option_as_ref_deref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>_.as_ref().map(Deref::deref)</code> or its aliases (such as String::as_str).</p>
<h3>Why is this bad?</h3>
<p>Readability, this can be written more concisely as
<code>_.as_deref()</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">opt.as_ref().map(String::as_str)
</code></pre>
<p>Can be written as</p>
<pre><code class="language-rust">opt.as_deref()
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.42.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+option_as_ref_deref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1845">View Source</a></div></div></div></article><article id="option_env_unwrap"><input id="label-option_env_unwrap" type="checkbox"><label for="label-option_env_unwrap"><h2 class="lint-title"><div class="panel-title-name" id="lint-option_env_unwrap">option_env_unwrap
<a href="#option_env_unwrap" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>option_env!(...).unwrap()</code> and
suggests usage of the <code>env!</code> macro.</p>
<h3>Why is this bad?</h3>
<p>Unwrapping the result of <code>option_env!</code> will panic
at run-time if the environment variable doesn’t exist, whereas <code>env!</code>
catches it at compile-time.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = option_env!("HOME").unwrap();
</code></pre>
<p>Is better expressed as:</p>
<pre><code class="language-rust">let _ = env!("HOME");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.43.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+option_env_unwrap">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/option_env_unwrap.rs#L8">View Source</a></div></div></div></article><article id="option_filter_map"><input id="label-option_filter_map" type="checkbox"><label for="label-option_filter_map"><h2 class="lint-title"><div class="panel-title-name" id="lint-option_filter_map">option_filter_map
<a href="#option_filter_map" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for iterators of <code>Option</code>s using <code>.filter(Option::is_some).map(Option::unwrap)</code> that may
be replaced with a <code>.flatten()</code> call.</p>
<h3>Why is this bad?</h3>
<p><code>Option</code> is like a collection of 0-1 things, so <code>flatten</code>
automatically does this without suspicious-looking <code>unwrap</code> calls.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = std::iter::empty::&lt;Option&lt;i32&gt;&gt;().filter(Option::is_some).map(Option::unwrap);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = std::iter::empty::&lt;Option&lt;i32&gt;&gt;().flatten();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.53.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+option_filter_map">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1186">View Source</a></div></div></div></article><article id="option_if_let_else"><input id="label-option_if_let_else" type="checkbox"><label for="label-option_if_let_else"><h2 class="lint-title"><div class="panel-title-name" id="lint-option_if_let_else">option_if_let_else
<a href="#option_if_let_else" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Lints usage of <code>if let Some(v) = ... { y } else { x }</code> and
<code>match .. { Some(v) =&gt; y, None/_ =&gt; x }</code> which are more
idiomatically done with <code>Option::map_or</code> (if the else bit is a pure
expression) or <code>Option::map_or_else</code> (if the else bit is an impure
expression).</p>
<h3>Why is this bad?</h3>
<p>Using the dedicated functions of the <code>Option</code> type is clearer and
more concise than an <code>if let</code> expression.</p>
<h3>Notes</h3>
<p>This lint uses a deliberately conservative metric for checking if the
inside of either body contains loop control expressions <code>break</code> or
<code>continue</code> (which cannot be used within closures). If these are found,
this lint will not be raised.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = if let Some(foo) = optional {
    foo
} else {
    5
};
let _ = match optional {
    Some(val) =&gt; val + 1,
    None =&gt; 5
};
let _ = if let Some(foo) = optional {
    foo
} else {
    let y = do_complicated_function();
    y*y
};
</code></pre>
<p>should be</p>
<pre><code class="language-rust">let _ = optional.map_or(5, |foo| foo);
let _ = optional.map_or(5, |val| val + 1);
let _ = optional.map_or_else(||{
    let y = do_complicated_function();
    y*y
}, |foo| foo);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.47.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+option_if_let_else">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/option_if_let_else.rs#L24">View Source</a></div></div></div></article><article id="option_map_or_err_ok"><input id="label-option_map_or_err_ok" type="checkbox"><label for="label-option_map_or_err_ok"><h2 class="lint-title"><div class="panel-title-name" id="lint-option_map_or_err_ok">option_map_or_err_ok
<a href="#option_map_or_err_ok" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p><code>clippy::manual_ok_or</code> covers this case.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">1.87.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+option_map_or_err_ok">Related Issues</a></div></div></div></article><article id="option_map_or_none"><input id="label-option_map_or_none" type="checkbox"><label for="label-option_map_or_none"><h2 class="lint-title"><div class="panel-title-name" id="lint-option_map_or_none">option_map_or_none
<a href="#option_map_or_none" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>_.map_or(None, _)</code>.</p>
<h3>Why is this bad?</h3>
<p>Readability, this can be written more concisely as
<code>_.and_then(_)</code>.</p>
<h3>Known problems</h3>
<p>The order of the arguments is not in execution order.</p>
<h3>Example</h3>
<pre><code class="language-rust">opt.map_or(None, |a| Some(a + 1));
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">opt.and_then(|a| Some(a + 1));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+option_map_or_none">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L602">View Source</a></div></div></div></article><article id="option_map_unit_fn"><input id="label-option_map_unit_fn" type="checkbox"><label for="label-option_map_unit_fn"><h2 class="lint-title"><div class="panel-title-name" id="lint-option_map_unit_fn">option_map_unit_fn
<a href="#option_map_unit_fn" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>option.map(f)</code> where f is a function
or closure that returns the unit type <code>()</code>.</p>
<h3>Why is this bad?</h3>
<p>Readability, this can be written more clearly with
an if let statement</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: Option&lt;String&gt; = do_stuff();
x.map(log_err_msg);
x.map(|msg| log_err_msg(format_msg(msg)));
</code></pre>
<p>The correct use would be:</p>
<pre><code class="language-rust">let x: Option&lt;String&gt; = do_stuff();
if let Some(msg) = x {
    log_err_msg(msg);
}

if let Some(msg) = x {
    log_err_msg(format_msg(msg));
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+option_map_unit_fn">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/map_unit_fn.rs#L12">View Source</a></div></div></div></article><article id="option_option"><input id="label-option_option" type="checkbox"><label for="label-option_option"><h2 class="lint-title"><div class="panel-title-name" id="lint-option_option">option_option
<a href="#option_option" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>Option&lt;Option&lt;_&gt;&gt;</code> in function signatures and type
definitions</p>
<h3>Why is this bad?</h3>
<p><code>Option&lt;_&gt;</code> represents an optional value. <code>Option&lt;Option&lt;_&gt;&gt;</code>
represents an optional value which itself wraps an optional. This is logically the
same thing as an optional value but has an unneeded extra level of wrapping.</p>
<p>If you have a case where <code>Some(Some(_))</code>, <code>Some(None)</code> and <code>None</code> are distinct cases,
consider a custom <code>enum</code> instead, with clear names for each case.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn get_data() -&gt; Option&lt;Option&lt;u32&gt;&gt; {
    None
}
</code></pre>
<p>Better:</p>
<pre><code class="language-rust">pub enum Contents {
    Data(Vec&lt;u8&gt;), // Was Some(Some(Vec&lt;u8&gt;))
    NotYetFetched, // Was Some(None)
    None,          // Was None
}

fn get_data() -&gt; Contents {
    Contents::None
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+option_option">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/types/mod.rs#L84">View Source</a></div></div></div></article><article id="or_fun_call"><input id="label-or_fun_call" type="checkbox"><label for="label-or_fun_call"><h2 class="lint-title"><div class="panel-title-name" id="lint-or_fun_call">or_fun_call
<a href="#or_fun_call" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>.or(foo(..))</code>, <code>.unwrap_or(foo(..))</code>,
<code>.or_insert(foo(..))</code> etc., and suggests to use <code>.or_else(|| foo(..))</code>,
<code>.unwrap_or_else(|| foo(..))</code>, <code>.unwrap_or_default()</code> or <code>.or_default()</code>
etc. instead.</p>
<h3>Why is this bad?</h3>
<p>The function will always be called. This is only bad if it allocates or
does some non-trivial amount of work.</p>
<h3>Known problems</h3>
<p>If the function has side-effects, not calling it will change the
semantic of the program, but you shouldn’t rely on that.</p>
<p>The lint also cannot figure out whether the function you call is
actually expensive to call or not.</p>
<h3>Example</h3>
<pre><code class="language-rust">foo.unwrap_or(String::from("empty"));
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">foo.unwrap_or_else(|| String::from("empty"));
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+or_fun_call">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L922">View Source</a></div></div></div></article><article id="or_then_unwrap"><input id="label-or_then_unwrap" type="checkbox"><label for="label-or_then_unwrap"><h2 class="lint-title"><div class="panel-title-name" id="lint-or_then_unwrap">or_then_unwrap
<a href="#or_then_unwrap" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>.or(…).unwrap()</code> calls to Options and Results.</p>
<h3>Why is this bad?</h3>
<p>You should use <code>.unwrap_or(…)</code> instead for clarity.</p>
<h3>Example</h3>
<pre><code class="language-rust">// Result
let value = result.or::&lt;Error&gt;(Ok(fallback)).unwrap();

// Option
let value = option.or(Some(fallback)).unwrap();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// Result
let value = result.unwrap_or(fallback);

// Option
let value = option.unwrap_or(fallback);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.61.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+or_then_unwrap">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L957">View Source</a></div></div></div></article><article id="out_of_bounds_indexing"><input id="label-out_of_bounds_indexing" type="checkbox"><label for="label-out_of_bounds_indexing"><h2 class="lint-title"><div class="panel-title-name" id="lint-out_of_bounds_indexing">out_of_bounds_indexing
<a href="#out_of_bounds_indexing" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for out of bounds array indexing with a constant
index.</p>
<h3>Why is this bad?</h3>
<p>This will always panic at runtime.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = [1, 2, 3, 4];

x[9];
&amp;x[2..9];
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// Index within bounds

x[0];
x[3];
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+out_of_bounds_indexing">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/indexing_slicing.rs#L12">View Source</a></div></div></div></article><article id="overly_complex_bool_expr"><input id="label-overly_complex_bool_expr" type="checkbox"><label for="label-overly_complex_bool_expr"><h2 class="lint-title"><div class="panel-title-name" id="lint-overly_complex_bool_expr">overly_complex_bool_expr
<a href="#overly_complex_bool_expr" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for boolean expressions that contain terminals that
can be eliminated.</p>
<h3>Why is this bad?</h3>
<p>This is most likely a logic bug.</p>
<h3>Known problems</h3>
<p>Ignores short circuiting behavior.</p>
<h3>Example</h3>
<pre><code class="language-rust">// The `b` is unnecessary, the expression is equivalent to `if a`.
if a &amp;&amp; b || a { ... }
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if a {}
</code></pre>
<h3>Past names</h3>
<ul>
<li>logic_bug</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+overly_complex_bool_expr">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/booleans.rs#L50">View Source</a></div></div></div></article><article id="owned_cow"><input id="label-owned_cow" type="checkbox"><label for="label-owned_cow"><h2 class="lint-title"><div class="panel-title-name" id="lint-owned_cow">owned_cow
<a href="#owned_cow" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects needlessly owned <code>Cow</code> types.</p>
<h3>Why is this bad?</h3>
<p>The borrowed types are usually more flexible, in that e.g. a
<code>Cow&lt;'_, str&gt;</code> can accept both <code>&amp;str</code> and <code>String</code> while
<code>Cow&lt;'_, String&gt;</code> can only accept <code>&amp;String</code> and <code>String</code>. In
particular, <code>&amp;str</code> is more general, because it allows for string
literals while <code>&amp;String</code> can only be borrowed from a heap-owned
<code>String</code>).</p>
<h3>Known Problems</h3>
<p>The lint does not check for usage of the type. There may be external
interfaces that require the use of an owned type.</p>
<p>At least the <code>CString</code> type also has a different API than <code>CStr</code>: The
former has an <code>as_bytes</code> method which the latter calls <code>to_bytes</code>.
There is no guarantee that other types won’t gain additional methods
leading to a similar mismatch.</p>
<p>In addition, the lint only checks for the known problematic types
<code>String</code>, <code>Vec&lt;_&gt;</code>, <code>CString</code>, <code>OsString</code> and <code>PathBuf</code>. Custom types
that implement <code>ToOwned</code> will not be detected.</p>
<h3>Example</h3>
<pre><code class="language-rust">let wrogn: std::borrow::Cow&lt;'_, Vec&lt;u8&gt;&gt;;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let right: std::borrow::Cow&lt;'_, [u8]&gt;;
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.87.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+owned_cow">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/types/mod.rs#L355">View Source</a></div></div></div></article><article id="panic"><input id="label-panic" type="checkbox"><label for="label-panic"><h2 class="lint-title"><div class="panel-title-name" id="lint-panic">panic
<a href="#panic" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>panic!</code>.</p>
<h3>Why restrict this?</h3>
<p>This macro, or panics in general, may be unwanted in production code.</p>
<h3>Example</h3>
<pre><code class="language-rust">panic!("even with a good reason");
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allow-panic-in-tests</code>:  Whether <code>panic</code> should be allowed in test functions or <code>#[cfg(test)]</code></p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.40.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+panic">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/panic_unimplemented.rs#L23">View Source</a></div></div></div></article><article id="panic_in_result_fn"><input id="label-panic_in_result_fn" type="checkbox"><label for="label-panic_in_result_fn"><h2 class="lint-title"><div class="panel-title-name" id="lint-panic_in_result_fn">panic_in_result_fn
<a href="#panic_in_result_fn" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>panic!</code> or assertions in a function whose return type is <code>Result</code>.</p>
<h3>Why restrict this?</h3>
<p>For some codebases, it is desirable for functions of type result to return an error instead of crashing. Hence panicking macros should be avoided.</p>
<h3>Known problems</h3>
<p>Functions called from a function returning a <code>Result</code> may invoke a panicking macro. This is not checked.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn result_with_panic() -&gt; Result&lt;bool, String&gt;
{
    panic!("error");
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn result_without_panic() -&gt; Result&lt;bool, String&gt; {
    Err(String::from("error"))
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.48.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+panic_in_result_fn">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/panic_in_result_fn.rs#L14">View Source</a></div></div></div></article><article id="panicking_overflow_checks"><input id="label-panicking_overflow_checks" type="checkbox"><label for="label-panicking_overflow_checks"><h2 class="lint-title"><div class="panel-title-name" id="lint-panicking_overflow_checks">panicking_overflow_checks
<a href="#panicking_overflow_checks" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects C-style underflow/overflow checks.</p>
<h3>Why is this bad?</h3>
<p>These checks will, by default, panic in debug builds rather than check
whether the operation caused an overflow.</p>
<h3>Example</h3>
<pre><code class="language-rust">if a + b &lt; a {
    // handle overflow
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if a.checked_add(b).is_none() {
    // handle overflow
}
</code></pre>
<p>Or:</p>
<pre><code class="language-rust">if a.overflowing_add(b).1 {
    // handle overflow
}
</code></pre>
<h3>Past names</h3>
<ul>
<li>overflow_check_conditional</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+panicking_overflow_checks">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/panicking_overflow_checks.rs#L8">View Source</a></div></div></div></article><article id="panicking_unwrap"><input id="label-panicking_unwrap" type="checkbox"><label for="label-panicking_unwrap"><h2 class="lint-title"><div class="panel-title-name" id="lint-panicking_unwrap">panicking_unwrap
<a href="#panicking_unwrap" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls of <code>unwrap[_err]()</code> that will always fail.</p>
<h3>Why is this bad?</h3>
<p>If panicking is desired, an explicit <code>panic!()</code> should be used.</p>
<h3>Known problems</h3>
<p>This lint only checks <code>if</code> conditions not assignments.
So something like <code>let x: Option&lt;()&gt; = None; x.unwrap();</code> will not be recognized.</p>
<h3>Example</h3>
<pre><code class="language-rust">if option.is_none() {
    do_something_with(option.unwrap())
}
</code></pre>
<p>This code will always panic. The if condition should probably be inverted.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+panicking_unwrap">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unwrap.rs#L56">View Source</a></div></div></div></article><article id="partial_pub_fields"><input id="label-partial_pub_fields" type="checkbox"><label for="label-partial_pub_fields"><h2 class="lint-title"><div class="panel-title-name" id="lint-partial_pub_fields">partial_pub_fields
<a href="#partial_pub_fields" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks whether some but not all fields of a <code>struct</code> are public.</p>
<p>Either make all fields of a type public, or make none of them public</p>
<h3>Why restrict this?</h3>
<p>Most types should either be:</p>
<ul>
<li>Abstract data types: complex objects with opaque implementation which guard
interior invariants and expose intentionally limited API to the outside world.</li>
<li>Data: relatively simple objects which group a bunch of related attributes together,
but have no invariants.</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">pub struct Color {
    pub r: u8,
    pub g: u8,
    b: u8,
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">pub struct Color {
    pub r: u8,
    pub g: u8,
    pub b: u8,
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.66.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+partial_pub_fields">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/partial_pub_fields.rs#L6">View Source</a></div></div></div></article><article id="partialeq_ne_impl"><input id="label-partialeq_ne_impl" type="checkbox"><label for="label-partialeq_ne_impl"><h2 class="lint-title"><div class="panel-title-name" id="lint-partialeq_ne_impl">partialeq_ne_impl
<a href="#partialeq_ne_impl" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for manual re-implementations of <code>PartialEq::ne</code>.</p>
<h3>Why is this bad?</h3>
<p><code>PartialEq::ne</code> is required to always return the
negated result of <code>PartialEq::eq</code>, which is exactly what the default
implementation does. Therefore, there should never be any need to
re-implement it.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Foo;

impl PartialEq for Foo {
    fn eq(&amp;self, other: &amp;Foo) -&gt; bool { true }
    fn ne(&amp;self, other: &amp;Foo) -&gt; bool { !(self == other) }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+partialeq_ne_impl">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/partialeq_ne_impl.rs#L7">View Source</a></div></div></div></article><article id="partialeq_to_none"><input id="label-partialeq_to_none" type="checkbox"><label for="label-partialeq_to_none"><h2 class="lint-title"><div class="panel-title-name" id="lint-partialeq_to_none">partialeq_to_none
<a href="#partialeq_to_none" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for binary comparisons to a literal <code>Option::None</code>.</p>
<h3>Why is this bad?</h3>
<p>A programmer checking if some <code>foo</code> is <code>None</code> via a comparison <code>foo == None</code>
is usually inspired from other programming languages (e.g. <code>foo is None</code>
in Python).
Checking if a value of type <code>Option&lt;T&gt;</code> is (not) equal to <code>None</code> in that
way relies on <code>T: PartialEq</code> to do the comparison, which is unneeded.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(f: Option&lt;u32&gt;) -&gt; &amp;'static str {
    if f != None { "yay" } else { "nay" }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo(f: Option&lt;u32&gt;) -&gt; &amp;'static str {
    if f.is_some() { "yay" } else { "nay" }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.65.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+partialeq_to_none">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/partialeq_to_none.rs#L10">View Source</a></div></div></div></article><article id="path_buf_push_overwrite"><input id="label-path_buf_push_overwrite" type="checkbox"><label for="label-path_buf_push_overwrite"><h2 class="lint-title"><div class="panel-title-name" id="lint-path_buf_push_overwrite">path_buf_push_overwrite
<a href="#path_buf_push_overwrite" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<ul>
<li>Checks for <a href="https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.push">push</a>
calls on <code>PathBuf</code> that can cause overwrites.</li>
</ul>
<h3>Why is this bad?</h3>
<p>Calling <code>push</code> with a root path at the start can overwrite the
previous defined path.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::path::PathBuf;

let mut x = PathBuf::from("/foo");
x.push("/bar");
assert_eq!(x, PathBuf::from("/bar"));
</code></pre>
<p>Could be written:</p>
<pre><code class="language-rust">use std::path::PathBuf;

let mut x = PathBuf::from("/foo");
x.push("bar");
assert_eq!(x, PathBuf::from("/foo/bar"));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.36.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+path_buf_push_overwrite">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2950">View Source</a></div></div></div></article><article id="path_ends_with_ext"><input id="label-path_ends_with_ext" type="checkbox"><label for="label-path_ends_with_ext"><h2 class="lint-title"><div class="panel-title-name" id="lint-path_ends_with_ext">path_ends_with_ext
<a href="#path_ends_with_ext" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Looks for calls to <code>Path::ends_with</code> calls where the argument looks like a file extension.</p>
<p>By default, Clippy has a short list of known filenames that start with a dot
but aren’t necessarily file extensions (e.g. the <code>.git</code> folder), which are allowed by default.
The <code>allowed-dotfiles</code> configuration can be used to allow additional
file extensions that Clippy should not lint.</p>
<h3>Why is this bad?</h3>
<p>This doesn’t actually compare file extensions. Rather, <code>ends_with</code> compares the given argument
to the last <strong>component</strong> of the path and checks if it matches exactly.</p>
<h3>Known issues</h3>
<p>File extensions are often at most three characters long, so this only lints in those cases
in an attempt to avoid false positives.
Any extension names longer than that are assumed to likely be real path components and are
therefore ignored.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn is_markdown(path: &amp;Path) -&gt; bool {
    path.ends_with(".md")
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn is_markdown(path: &amp;Path) -&gt; bool {
    path.extension().is_some_and(|ext| ext == "md")
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allowed-dotfiles</code>:  Additional dotfiles (files or directories starting with a dot) to allow</p>
<p>(default: <code>[]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.74.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+path_ends_with_ext">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3709">View Source</a></div></div></div></article><article id="pathbuf_init_then_push"><input id="label-pathbuf_init_then_push" type="checkbox"><label for="label-pathbuf_init_then_push"><h2 class="lint-title"><div class="panel-title-name" id="lint-pathbuf_init_then_push">pathbuf_init_then_push
<a href="#pathbuf_init_then_push" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>push</code> immediately after creating a new <code>PathBuf</code>.</p>
<h3>Why is this bad?</h3>
<p>Multiple <code>.join()</code> calls are usually easier to read than multiple <code>.push</code>
calls across multiple statements. It might also be possible to use
<code>PathBuf::from</code> instead.</p>
<h3>Known problems</h3>
<p><code>.join()</code> introduces an implicit <code>clone()</code>. <code>PathBuf::from</code> can alternatively be
used when the <code>PathBuf</code> is newly constructed. This will avoid the implicit clone.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut path_buf = PathBuf::new();
path_buf.push("foo");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let path_buf = PathBuf::from("foo");
// or
let path_buf = PathBuf::new().join("foo");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.82.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+pathbuf_init_then_push">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/pathbuf_init_then_push.rs#L13">View Source</a></div></div></div></article><article id="pattern_type_mismatch"><input id="label-pattern_type_mismatch" type="checkbox"><label for="label-pattern_type_mismatch"><h2 class="lint-title"><div class="panel-title-name" id="lint-pattern_type_mismatch">pattern_type_mismatch
<a href="#pattern_type_mismatch" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for patterns that aren’t exact representations of the types
they are applied to.</p>
<p>To satisfy this lint, you will have to adjust either the expression that is matched
against or the pattern itself, as well as the bindings that are introduced by the
adjusted patterns. For matching you will have to either dereference the expression
with the <code>*</code> operator, or amend the patterns to explicitly match against <code>&amp;&lt;pattern&gt;</code>
or <code>&amp;mut &lt;pattern&gt;</code> depending on the reference mutability. For the bindings you need
to use the inverse. You can leave them as plain bindings if you wish for the value
to be copied, but you must use <code>ref mut &lt;variable&gt;</code> or <code>ref &lt;variable&gt;</code> to construct
a reference into the matched structure.</p>
<p>If you are looking for a way to learn about ownership semantics in more detail, it
is recommended to look at IDE options available to you to highlight types, lifetimes
and reference semantics in your code. The available tooling would expose these things
in a general way even outside of the various pattern matching mechanics. Of course
this lint can still be used to highlight areas of interest and ensure a good understanding
of ownership semantics.</p>
<h3>Why restrict this?</h3>
<p>It increases ownership hints in the code, and will guard against some changes
in ownership.</p>
<h3>Example</h3>
<p>This example shows the basic adjustments necessary to satisfy the lint. Note how
the matched expression is explicitly dereferenced with <code>*</code> and the <code>inner</code> variable
is bound to a shared borrow via <code>ref inner</code>.</p>
<pre><code class="language-rust">// Bad
let value = &amp;Some(Box::new(23));
match value {
    Some(inner) =&gt; println!("{}", inner),
    None =&gt; println!("none"),
}

// Good
let value = &amp;Some(Box::new(23));
match *value {
    Some(ref inner) =&gt; println!("{}", inner),
    None =&gt; println!("none"),
}
</code></pre>
<p>The following example demonstrates one of the advantages of the more verbose style.
Note how the second version uses <code>ref mut a</code> to explicitly declare <code>a</code> a shared mutable
borrow, while <code>b</code> is simply taken by value. This ensures that the loop body cannot
accidentally modify the wrong part of the structure.</p>
<pre><code class="language-rust">// Bad
let mut values = vec![(2, 3), (3, 4)];
for (a, b) in &amp;mut values {
    *a += *b;
}

// Good
let mut values = vec![(2, 3), (3, 4)];
for &amp;mut (ref mut a, b) in &amp;mut values {
    *a += b;
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.47.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+pattern_type_mismatch">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/pattern_type_mismatch.rs#L11">View Source</a></div></div></div></article><article id="permissions_set_readonly_false"><input id="label-permissions_set_readonly_false" type="checkbox"><label for="label-permissions_set_readonly_false"><h2 class="lint-title"><div class="panel-title-name" id="lint-permissions_set_readonly_false">permissions_set_readonly_false
<a href="#permissions_set_readonly_false" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>std::fs::Permissions.set_readonly</code> with argument <code>false</code>.</p>
<h3>Why is this bad?</h3>
<p>On Unix platforms this results in the file being world writable,
equivalent to <code>chmod a+w &lt;file&gt;</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::fs::File;
let f = File::create("foo.txt").unwrap();
let metadata = f.metadata().unwrap();
let mut permissions = metadata.permissions();
permissions.set_readonly(false);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.68.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+permissions_set_readonly_false">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/permissions_set_readonly_false.rs#L9">View Source</a></div></div></div></article><article id="pointer_format"><input id="label-pointer_format" type="checkbox"><label for="label-pointer_format"><h2 class="lint-title"><div class="panel-title-name" id="lint-pointer_format">pointer_format
<a href="#pointer_format" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects <a href="https://doc.rust-lang.org/std/fmt/index.html#formatting-traits">pointer format</a> as well as <code>Debug</code> formatting of raw pointers or function pointers
or any types that have a derived <code>Debug</code> impl that recursively contains them.</p>
<h3>Why restrict this?</h3>
<p>The addresses are only useful in very specific contexts, and certain projects may want to keep addresses of
certain data structures or functions from prying hacker eyes as an additional line of security.</p>
<h3>Known problems</h3>
<p>The lint currently only looks through derived <code>Debug</code> implementations. Checking whether a manual
implementation prints an address is left as an exercise to the next lint implementer.</p>
<h3>Example</h3>
<pre><code class="language-rust">let foo = &amp;0_u32;
fn bar() {}
println!("{:p}", foo);
let _ = format!("{:?}", &amp;(bar as fn()));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.89.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+pointer_format">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/format_args.rs#L204">View Source</a></div></div></div></article><article id="pointers_in_nomem_asm_block"><input id="label-pointers_in_nomem_asm_block" type="checkbox"><label for="label-pointers_in_nomem_asm_block"><h2 class="lint-title"><div class="panel-title-name" id="lint-pointers_in_nomem_asm_block">pointers_in_nomem_asm_block
<a href="#pointers_in_nomem_asm_block" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks if any pointer is being passed to an asm! block with <code>nomem</code> option.</p>
<h3>Why is this bad?</h3>
<p><code>nomem</code> forbids any reads or writes to memory and passing a pointer suggests
that either of those will happen.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn f(p: *mut u32) {
    unsafe { core::arch::asm!("mov [{p}], 42", p = in(reg) p, options(nomem, nostack)); }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn f(p: *mut u32) {
    unsafe { core::arch::asm!("mov [{p}], 42", p = in(reg) p, options(nostack)); }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.81.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+pointers_in_nomem_asm_block">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/pointers_in_nomem_asm_block.rs#L8">View Source</a></div></div></div></article><article id="possible_missing_comma"><input id="label-possible_missing_comma" type="checkbox"><label for="label-possible_missing_comma"><h2 class="lint-title"><div class="panel-title-name" id="lint-possible_missing_comma">possible_missing_comma
<a href="#possible_missing_comma" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for possible missing comma in an array. It lints if
an array element is a binary operator expression and it lies on two lines.</p>
<h3>Why is this bad?</h3>
<p>This could lead to unexpected results.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = &amp;[
    -1, -2, -3 // &lt;= no comma here
    -4, -5, -6
];
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+possible_missing_comma">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/formatting.rs#L119">View Source</a></div></div></div></article><article id="possible_missing_else"><input id="label-possible_missing_else" type="checkbox"><label for="label-possible_missing_else"><h2 class="lint-title"><div class="panel-title-name" id="lint-possible_missing_else">possible_missing_else
<a href="#possible_missing_else" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for an <code>if</code> expression followed by either a block or another <code>if</code> that
looks like it should have an <code>else</code> between them.</p>
<h3>Why is this bad?</h3>
<p>This is probably some refactoring remnant, even if the code is correct, it
might look confusing.</p>
<h3>Example</h3>
<pre><code class="language-rust">if foo {
} { // looks like an `else` is missing here
}

if foo {
} if bar { // looks like an `else` is missing here
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.91.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+possible_missing_else">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/formatting.rs#L94">View Source</a></div></div></div></article><article id="precedence"><input id="label-precedence" type="checkbox"><label for="label-precedence"><h2 class="lint-title"><div class="panel-title-name" id="lint-precedence">precedence
<a href="#precedence" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for operations where precedence may be unclear and suggests to add parentheses.
It catches a mixed usage of arithmetic and bit shifting/combining operators,
as well as method calls applied to closures.</p>
<h3>Why is this bad?</h3>
<p>Not everyone knows the precedence of those operators by
heart, so expressions like these may trip others trying to reason about the
code.</p>
<h3>Example</h3>
<p><code>1 &lt;&lt; 2 + 3</code> equals 32, while <code>(1 &lt;&lt; 2) + 3</code> equals 7</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+precedence">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/precedence.rs#L10">View Source</a></div></div></div></article><article id="precedence_bits"><input id="label-precedence_bits" type="checkbox"><label for="label-precedence_bits"><h2 class="lint-title"><div class="panel-title-name" id="lint-precedence_bits">precedence_bits
<a href="#precedence_bits" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for bit shifting operations combined with bit masking/combining operators
and suggest using parentheses.</p>
<h3>Why restrict this?</h3>
<p>Not everyone knows the precedence of those operators by
heart, so expressions like these may trip others trying to reason about the
code.</p>
<h3>Example</h3>
<p><code>0x2345 &amp; 0xF000 &gt;&gt; 12</code> equals 5, while <code>(0x2345 &amp; 0xF000) &gt;&gt; 12</code> equals 2</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.86.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+precedence_bits">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/precedence.rs#L29">View Source</a></div></div></div></article><article id="print_in_format_impl"><input id="label-print_in_format_impl" type="checkbox"><label for="label-print_in_format_impl"><h2 class="lint-title"><div class="panel-title-name" id="lint-print_in_format_impl">print_in_format_impl
<a href="#print_in_format_impl" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>println</code>, <code>print</code>, <code>eprintln</code> or <code>eprint</code> in an
implementation of a formatting trait.</p>
<h3>Why is this bad?</h3>
<p>Using a print macro is likely unintentional since formatting traits
should write to the <code>Formatter</code>, not stdout/stderr.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::fmt::{Display, Error, Formatter};

struct S;
impl Display for S {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt; {
        println!("S");

        Ok(())
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::fmt::{Display, Error, Formatter};

struct S;
impl Display for S {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt; {
        writeln!(f, "S");

        Ok(())
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.61.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+print_in_format_impl">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/format_impl.rs#L52">View Source</a></div></div></div></article><article id="print_literal"><input id="label-print_literal" type="checkbox"><label for="label-print_literal"><h2 class="lint-title"><div class="panel-title-name" id="lint-print_literal">print_literal
<a href="#print_literal" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint warns about the use of literals as <code>print!</code>/<code>println!</code> args.</p>
<h3>Why is this bad?</h3>
<p>Using literals as <code>println!</code> args is inefficient
(c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary
(i.e., just put the literal in the format string)</p>
<h3>Example</h3>
<pre><code class="language-rust">println!("{}", "foo");
</code></pre>
<p>use the literal without formatting:</p>
<pre><code class="language-rust">println!("foo");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+print_literal">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/write/mod.rs#L129">View Source</a></div></div></div></article><article id="print_stderr"><input id="label-print_stderr" type="checkbox"><label for="label-print_stderr"><h2 class="lint-title"><div class="panel-title-name" id="lint-print_stderr">print_stderr
<a href="#print_stderr" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for printing on <em>stderr</em>. The purpose of this lint
is to catch debugging remnants.</p>
<h3>Why restrict this?</h3>
<p>People often print on <em>stderr</em> while debugging an
application and might forget to remove those prints afterward.</p>
<h3>Known problems</h3>
<p>Only catches <code>eprint!</code> and <code>eprintln!</code> calls.</p>
<h3>Example</h3>
<pre><code class="language-rust">eprintln!("Hello world!");
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allow-print-in-tests</code>:  Whether print macros (ex. <code>println!</code>) should be allowed in test functions or <code>#[cfg(test)]</code></p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.50.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+print_stderr">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/write/mod.rs#L84">View Source</a></div></div></div></article><article id="print_stdout"><input id="label-print_stdout" type="checkbox"><label for="label-print_stdout"><h2 class="lint-title"><div class="panel-title-name" id="lint-print_stdout">print_stdout
<a href="#print_stdout" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for printing on <em>stdout</em>. The purpose of this lint
is to catch debugging remnants.</p>
<h3>Why restrict this?</h3>
<p>People often print on <em>stdout</em> while debugging an
application and might forget to remove those prints afterward.</p>
<h3>Known problems</h3>
<p>Only catches <code>print!</code> and <code>println!</code> calls.</p>
<h3>Example</h3>
<pre><code class="language-rust">println!("Hello world!");
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allow-print-in-tests</code>:  Whether print macros (ex. <code>println!</code>) should be allowed in test functions or <code>#[cfg(test)]</code></p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+print_stdout">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/write/mod.rs#L62">View Source</a></div></div></div></article><article id="print_with_newline"><input id="label-print_with_newline" type="checkbox"><label for="label-print_with_newline"><h2 class="lint-title"><div class="panel-title-name" id="lint-print_with_newline">print_with_newline
<a href="#print_with_newline" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint warns when you use <code>print!()</code> with a format
string that ends in a newline.</p>
<h3>Why is this bad?</h3>
<p>You should use <code>println!()</code> instead, which appends the
newline.</p>
<h3>Example</h3>
<pre><code class="language-rust">print!("Hello {}!\n", name);
</code></pre>
<p>use println!() instead</p>
<pre><code class="language-rust">println!("Hello {}!", name);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+print_with_newline">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/write/mod.rs#L37">View Source</a></div></div></div></article><article id="println_empty_string"><input id="label-println_empty_string" type="checkbox"><label for="label-println_empty_string"><h2 class="lint-title"><div class="panel-title-name" id="lint-println_empty_string">println_empty_string
<a href="#println_empty_string" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint warns when you use <code>println!("")</code> to
print a newline.</p>
<h3>Why is this bad?</h3>
<p>You should use <code>println!()</code>, which is simpler.</p>
<h3>Example</h3>
<pre><code class="language-rust">println!("");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">println!();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+println_empty_string">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/write/mod.rs#L14">View Source</a></div></div></div></article><article id="ptr_arg"><input id="label-ptr_arg" type="checkbox"><label for="label-ptr_arg"><h2 class="lint-title"><div class="panel-title-name" id="lint-ptr_arg">ptr_arg
<a href="#ptr_arg" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint checks for function arguments of type <code>&amp;String</code>, <code>&amp;Vec</code>,
<code>&amp;PathBuf</code>, and <code>Cow&lt;_&gt;</code>. It will also suggest you replace <code>.clone()</code> calls
with the appropriate <code>.to_owned()</code>/<code>to_string()</code> calls.</p>
<h3>Why is this bad?</h3>
<p>Requiring the argument to be of the specific type
makes the function less useful for no benefit; slices in the form of <code>&amp;[T]</code>
or <code>&amp;str</code> usually suffice and can be obtained from other types, too.</p>
<h3>Known problems</h3>
<p>There may be <code>fn(&amp;Vec)</code>-typed references pointing to your function.
If you have them, you will get a compiler error after applying this lint’s
suggestions. You then have the choice to undo your changes or change the
type of the reference.</p>
<p>Note that if the function is part of your public interface, there may be
other crates referencing it, of which you may not be aware. Carefully
deprecate the function before applying the lint suggestions in this case.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(&amp;Vec&lt;u32&gt;) { .. }
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo(&amp;[u32]) { .. }
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ptr_arg">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ptr/mod.rs#L10">View Source</a></div></div></div></article><article id="ptr_as_ptr"><input id="label-ptr_as_ptr" type="checkbox"><label for="label-ptr_as_ptr"><h2 class="lint-title"><div class="panel-title-name" id="lint-ptr_as_ptr">ptr_as_ptr
<a href="#ptr_as_ptr" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>as</code> casts between raw pointers that don’t change their
constness, namely <code>*const T</code> to <code>*const U</code> and <code>*mut T</code> to <code>*mut U</code>.</p>
<h3>Why is this bad?</h3>
<p>Though <code>as</code> casts between raw pointers are not terrible,
<code>pointer::cast</code> is safer because it cannot accidentally change the
pointer’s mutability, nor cast the pointer to other types like <code>usize</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let ptr: *const u32 = &amp;42_u32;
let mut_ptr: *mut u32 = &amp;mut 42_u32;
let _ = ptr as *const i32;
let _ = mut_ptr as *mut i32;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let ptr: *const u32 = &amp;42_u32;
let mut_ptr: *mut u32 = &amp;mut 42_u32;
let _ = ptr.cast::&lt;i32&gt;();
let _ = mut_ptr.cast::&lt;i32&gt;();
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.51.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ptr_as_ptr">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L384">View Source</a></div></div></div></article><article id="ptr_cast_constness"><input id="label-ptr_cast_constness" type="checkbox"><label for="label-ptr_cast_constness"><h2 class="lint-title"><div class="panel-title-name" id="lint-ptr_cast_constness">ptr_cast_constness
<a href="#ptr_cast_constness" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>as</code> casts between raw pointers that change their constness, namely <code>*const T</code> to
<code>*mut T</code> and <code>*mut T</code> to <code>*const T</code>.</p>
<h3>Why is this bad?</h3>
<p>Though <code>as</code> casts between raw pointers are not terrible, <code>pointer::cast_mut</code> and
<code>pointer::cast_const</code> are safer because they cannot accidentally cast the pointer to another
type. Or, when null pointers are involved, <code>null()</code> and <code>null_mut()</code> can be used directly.</p>
<h3>Example</h3>
<pre><code class="language-rust">let ptr: *const u32 = &amp;42_u32;
let mut_ptr = ptr as *mut u32;
let ptr = mut_ptr as *const u32;
let ptr1 = std::ptr::null::&lt;u32&gt;() as *mut u32;
let ptr2 = std::ptr::null_mut::&lt;u32&gt;() as *const u32;
let ptr3 = std::ptr::null::&lt;u32&gt;().cast_mut();
let ptr4 = std::ptr::null_mut::&lt;u32&gt;().cast_const();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let ptr: *const u32 = &amp;42_u32;
let mut_ptr = ptr.cast_mut();
let ptr = mut_ptr.cast_const();
let ptr1 = std::ptr::null_mut::&lt;u32&gt;();
let ptr2 = std::ptr::null::&lt;u32&gt;();
let ptr3 = std::ptr::null_mut::&lt;u32&gt;();
let ptr4 = std::ptr::null::&lt;u32&gt;();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ptr_cast_constness">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L414">View Source</a></div></div></div></article><article id="ptr_eq"><input id="label-ptr_eq" type="checkbox"><label for="label-ptr_eq"><h2 class="lint-title"><div class="panel-title-name" id="lint-ptr_eq">ptr_eq
<a href="#ptr_eq" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Use <code>std::ptr::eq</code> when applicable</p>
<h3>Why is this bad?</h3>
<p><code>ptr::eq</code> can be used to compare <code>&amp;T</code> references
(which coerce to <code>*const T</code> implicitly) by their address rather than
comparing the values they point to.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = &amp;[1, 2, 3];
let b = &amp;[1, 2, 3];

assert!(a as *const _ as usize == b as *const _ as usize);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a = &amp;[1, 2, 3];
let b = &amp;[1, 2, 3];

assert!(std::ptr::eq(a, b));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ptr_eq">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ptr/mod.rs#L109">View Source</a></div></div></div></article><article id="ptr_offset_by_literal"><input id="label-ptr_offset_by_literal" type="checkbox"><label for="label-ptr_offset_by_literal"><h2 class="lint-title"><div class="panel-title-name" id="lint-ptr_offset_by_literal">ptr_offset_by_literal
<a href="#ptr_offset_by_literal" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of the <code>offset</code> pointer method with an integer
literal.</p>
<h3>Why is this bad?</h3>
<p>The <code>add</code> and <code>sub</code> methods more accurately express the intent.</p>
<h3>Example</h3>
<pre><code class="language-rust">let vec = vec![b'a', b'b', b'c'];
let ptr = vec.as_ptr();

unsafe {
    ptr.offset(-8);
}
</code></pre>
<p>Could be written:</p>
<pre><code class="language-rust">let vec = vec![b'a', b'b', b'c'];
let ptr = vec.as_ptr();

unsafe {
    ptr.sub(8);
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.92.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ptr_offset_by_literal">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1732">View Source</a></div></div></div></article><article id="ptr_offset_with_cast"><input id="label-ptr_offset_with_cast" type="checkbox"><label for="label-ptr_offset_with_cast"><h2 class="lint-title"><div class="panel-title-name" id="lint-ptr_offset_with_cast">ptr_offset_with_cast
<a href="#ptr_offset_with_cast" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of the <code>offset</code> pointer method with a <code>usize</code> casted to an
<code>isize</code>.</p>
<h3>Why is this bad?</h3>
<p>If we’re always increasing the pointer address, we can avoid the numeric
cast by using the <code>add</code> method instead.</p>
<h3>Example</h3>
<pre><code class="language-rust">let vec = vec![b'a', b'b', b'c'];
let ptr = vec.as_ptr();
let offset = 1_usize;

unsafe {
    ptr.offset(offset as isize);
}
</code></pre>
<p>Could be written:</p>
<pre><code class="language-rust">let vec = vec![b'a', b'b', b'c'];
let ptr = vec.as_ptr();
let offset = 1_usize;

unsafe {
    ptr.add(offset);
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.30.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ptr_offset_with_cast">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1766">View Source</a></div></div></div></article><article id="pub_enum_variant_names"><input id="label-pub_enum_variant_names" type="checkbox"><label for="label-pub_enum_variant_names"><h2 class="lint-title"><div class="panel-title-name" id="lint-pub_enum_variant_names">pub_enum_variant_names
<a href="#pub_enum_variant_names" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p><code>clippy::enum_variant_names</code> now covers this case via the <code>avoid-breaking-exported-api</code> config.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">1.54.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+pub_enum_variant_names">Related Issues</a></div></div></div></article><article id="pub_underscore_fields"><input id="label-pub_underscore_fields" type="checkbox"><label for="label-pub_underscore_fields"><h2 class="lint-title"><div class="panel-title-name" id="lint-pub_underscore_fields">pub_underscore_fields
<a href="#pub_underscore_fields" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks whether any field of the struct is prefixed with an <code>_</code> (underscore) and also marked
<code>pub</code> (public)</p>
<h3>Why is this bad?</h3>
<p>Fields prefixed with an <code>_</code> are inferred as unused, which suggests it should not be marked
as <code>pub</code>, because marking it as <code>pub</code> infers it will be used.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct FileHandle {
    pub _descriptor: usize,
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct FileHandle {
    _descriptor: usize,
}
</code></pre>
<p>OR</p>
<pre><code class="language-rust">struct FileHandle {
    pub descriptor: usize,
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>pub-underscore-fields-behavior</code>:  Lint “public” fields in a struct that are prefixed with an underscore based on their
exported visibility, or whether they are marked as “pub”.</p>
<p>(default: <code>"PubliclyExported"</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.77.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+pub_underscore_fields">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/pub_underscore_fields.rs#L10">View Source</a></div></div></div></article><article id="pub_use"><input id="label-pub_use" type="checkbox"><label for="label-pub_use"><h2 class="lint-title"><div class="panel-title-name" id="lint-pub_use">pub_use
<a href="#pub_use" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Restricts the usage of <code>pub use ...</code></p>
<h3>Why restrict this?</h3>
<p>A project may wish to limit <code>pub use</code> instances to prevent
unintentional exports, or to encourage placing exported items directly in public modules.</p>
<h3>Example</h3>
<pre><code class="language-rust">pub mod outer {
    mod inner {
        pub struct Test {}
    }
    pub use inner::Test;
}

use outer::Test;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">pub mod outer {
    pub struct Test {}
}

use outer::Test;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+pub_use">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/pub_use.rs#L6">View Source</a></div></div></div></article><article id="pub_with_shorthand"><input id="label-pub_with_shorthand" type="checkbox"><label for="label-pub_with_shorthand"><h2 class="lint-title"><div class="panel-title-name" id="lint-pub_with_shorthand">pub_with_shorthand
<a href="#pub_with_shorthand" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>pub(&lt;loc&gt;)</code> with <code>in</code>.</p>
<h3>Why restrict this?</h3>
<p>Consistency. Use it or don’t, just be consistent about it.</p>
<p>Also see the <code>pub_without_shorthand</code> lint for an alternative.</p>
<h3>Example</h3>
<pre><code class="language-rust">pub(super) type OptBox&lt;T&gt; = Option&lt;Box&lt;T&gt;&gt;;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">pub(in super) type OptBox&lt;T&gt; = Option&lt;Box&lt;T&gt;&gt;;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+pub_with_shorthand">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/visibility.rs#L30">View Source</a></div></div></div></article><article id="pub_without_shorthand"><input id="label-pub_without_shorthand" type="checkbox"><label for="label-pub_without_shorthand"><h2 class="lint-title"><div class="panel-title-name" id="lint-pub_without_shorthand">pub_without_shorthand
<a href="#pub_without_shorthand" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>pub(&lt;loc&gt;)</code> without <code>in</code>.</p>
<p>Note: As you cannot write a module’s path in <code>pub(&lt;loc&gt;)</code>, this will only trigger on
<code>pub(super)</code> and the like.</p>
<h3>Why restrict this?</h3>
<p>Consistency. Use it or don’t, just be consistent about it.</p>
<p>Also see the <code>pub_with_shorthand</code> lint for an alternative.</p>
<h3>Example</h3>
<pre><code class="language-rust">pub(in super) type OptBox&lt;T&gt; = Option&lt;Box&lt;T&gt;&gt;;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">pub(super) type OptBox&lt;T&gt; = Option&lt;Box&lt;T&gt;&gt;;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+pub_without_shorthand">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/visibility.rs#L52">View Source</a></div></div></div></article><article id="question_mark"><input id="label-question_mark" type="checkbox"><label for="label-question_mark"><h2 class="lint-title"><div class="panel-title-name" id="lint-question_mark">question_mark
<a href="#question_mark" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for expressions that could be replaced by the <code>?</code> operator.</p>
<h3>Why is this bad?</h3>
<p>Using the <code>?</code> operator is shorter and more idiomatic.</p>
<h3>Example</h3>
<pre><code class="language-rust">if option.is_none() {
    return None;
}
</code></pre>
<p>Could be written:</p>
<pre><code class="language-rust">option?;
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+question_mark">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/question_mark.rs#L29">View Source</a></div></div></div></article><article id="question_mark_used"><input id="label-question_mark_used" type="checkbox"><label for="label-question_mark_used"><h2 class="lint-title"><div class="panel-title-name" id="lint-question_mark_used">question_mark_used
<a href="#question_mark_used" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for expressions that use the <code>?</code> operator and rejects them.</p>
<h3>Why restrict this?</h3>
<p>Sometimes code wants to avoid the <code>?</code> operator because for instance a local
block requires a macro to re-throw errors to attach additional information to the
error.</p>
<h3>Example</h3>
<pre><code class="language-rust">let result = expr?;
</code></pre>
<p>Could be written:</p>
<pre><code class="language-rust">utility_macro!(expr);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.69.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+question_mark_used">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/question_mark_used.rs#L7">View Source</a></div></div></div></article><article id="range_minus_one"><input id="label-range_minus_one" type="checkbox"><label for="label-range_minus_one"><h2 class="lint-title"><div class="panel-title-name" id="lint-range_minus_one">range_minus_one
<a href="#range_minus_one" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for inclusive ranges where 1 is subtracted from
the upper bound, e.g., <code>x..=(y-1)</code>.</p>
<h3>Why is this bad?</h3>
<p>The code is more readable with an exclusive range
like <code>x..y</code>.</p>
<h3>Limitations</h3>
<p>The lint is conservative and will trigger only when switching
from an inclusive to an exclusive range is provably safe from
a typing point of view. This corresponds to situations where
the range is used as an iterator, or for indexing.</p>
<h3>Example</h3>
<pre><code class="language-rust">for i in x..=(y-1) {
    // ..
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">for i in x..y {
    // ..
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+range_minus_one">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ranges.rs#L69">View Source</a></div></div></div></article><article id="range_plus_one"><input id="label-range_plus_one" type="checkbox"><label for="label-range_plus_one"><h2 class="lint-title"><div class="panel-title-name" id="lint-range_plus_one">range_plus_one
<a href="#range_plus_one" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for exclusive ranges where 1 is added to the
upper bound, e.g., <code>x..(y+1)</code>.</p>
<h3>Why is this bad?</h3>
<p>The code is more readable with an inclusive range
like <code>x..=y</code>.</p>
<h3>Limitations</h3>
<p>The lint is conservative and will trigger only when switching
from an exclusive to an inclusive range is provably safe from
a typing point of view. This corresponds to situations where
the range is used as an iterator, or for indexing.</p>
<h3>Known problems</h3>
<p>Will add unnecessary pair of parentheses when the
expression is not wrapped in a pair but starts with an opening parenthesis
and ends with a closing one.
I.e., <code>let _ = (f()+1)..(f()+1)</code> results in <code>let _ = ((f()+1)..=f())</code>.</p>
<p>Also in many cases, inclusive ranges are still slower to run than
exclusive ranges, because they essentially add an extra branch that
LLVM may fail to hoist out of the loop.</p>
<h3>Example</h3>
<pre><code class="language-rust">for i in x..(y+1) {
    // ..
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">for i in x..=y {
    // ..
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+range_plus_one">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ranges.rs#L21">View Source</a></div></div></div></article><article id="range_step_by_zero"><input id="label-range_step_by_zero" type="checkbox"><label for="label-range_step_by_zero"><h2 class="lint-title"><div class="panel-title-name" id="lint-range_step_by_zero">range_step_by_zero
<a href="#range_step_by_zero" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p><code>Iterator::step_by(0)</code> now panics and is no longer an infinite iterator.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+range_step_by_zero">Related Issues</a></div></div></div></article><article id="range_zip_with_len"><input id="label-range_zip_with_len" type="checkbox"><label for="label-range_zip_with_len"><h2 class="lint-title"><div class="panel-title-name" id="lint-range_zip_with_len">range_zip_with_len
<a href="#range_zip_with_len" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for zipping a collection with the range of
<code>0.._.len()</code>.</p>
<h3>Why is this bad?</h3>
<p>The code is better expressed with <code>.enumerate()</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = x.iter().zip(0..x.len());
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = x.iter().enumerate();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+range_zip_with_len">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2982">View Source</a></div></div></div></article><article id="rc_buffer"><input id="label-rc_buffer" type="checkbox"><label for="label-rc_buffer"><h2 class="lint-title"><div class="panel-title-name" id="lint-rc_buffer">rc_buffer
<a href="#rc_buffer" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code> when <code>T</code> is a mutable buffer type such as <code>String</code> or <code>Vec</code>.</p>
<h3>Why restrict this?</h3>
<p>Expressions such as <code>Rc&lt;String&gt;</code> usually have no advantage over <code>Rc&lt;str&gt;</code>, since
it is larger and involves an extra level of indirection, and doesn’t implement <code>Borrow&lt;str&gt;</code>.</p>
<p>While mutating a buffer type would still be possible with <code>Rc::get_mut()</code>, it only
works if there are no additional references yet, which usually defeats the purpose of
enclosing it in a shared ownership type. Instead, additionally wrapping the inner
type with an interior mutable container (such as <code>RefCell</code> or <code>Mutex</code>) would normally
be used.</p>
<h3>Known problems</h3>
<p>This pattern can be desirable to avoid the overhead of a <code>RefCell</code> or <code>Mutex</code> for
cases where mutation only happens before there are any additional references.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(interned: Rc&lt;String&gt;) { ... }
</code></pre>
<p>Better:</p>
<pre><code class="language-rust">fn foo(interned: Rc&lt;str&gt;) { ... }
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.48.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+rc_buffer">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/types/mod.rs#L214">View Source</a></div></div></div></article><article id="rc_clone_in_vec_init"><input id="label-rc_clone_in_vec_init" type="checkbox"><label for="label-rc_clone_in_vec_init"><h2 class="lint-title"><div class="panel-title-name" id="lint-rc_clone_in_vec_init">rc_clone_in_vec_init
<a href="#rc_clone_in_vec_init" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for reference-counted pointers (<code>Arc</code>, <code>Rc</code>, <code>rc::Weak</code>, and <code>sync::Weak</code>)
in <code>vec![elem; len]</code></p>
<h3>Why is this bad?</h3>
<p>This will create <code>elem</code> once and clone it <code>len</code> times - doing so with <code>Arc</code>/<code>Rc</code>/<code>Weak</code>
is a bit misleading, as it will create references to the same pointer, rather
than different instances.</p>
<h3>Example</h3>
<pre><code class="language-rust">let v = vec![std::sync::Arc::new("some data".to_string()); 100];
// or
let v = vec![std::rc::Rc::new("some data".to_string()); 100];
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// Initialize each value separately:
let mut data = Vec::with_capacity(100);
for _ in 0..100 {
    data.push(std::rc::Rc::new("some data".to_string()));
}

// Or if you want clones of the same reference,
// Create the reference beforehand to clarify that
// it should be cloned for each value
let data = std::rc::Rc::new("some data".to_string());
let v = vec![data; 100];
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.63.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+rc_clone_in_vec_init">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/rc_clone_in_vec_init.rs#L13">View Source</a></div></div></div></article><article id="rc_mutex"><input id="label-rc_mutex" type="checkbox"><label for="label-rc_mutex"><h2 class="lint-title"><div class="panel-title-name" id="lint-rc_mutex">rc_mutex
<a href="#rc_mutex" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>Rc&lt;Mutex&lt;T&gt;&gt;</code>.</p>
<h3>Why restrict this?</h3>
<p><code>Rc</code> is used in single thread and <code>Mutex</code> is used in multi thread.
Consider using <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> in single thread or <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> in multi thread.</p>
<h3>Known problems</h3>
<p>Sometimes combining generic types can lead to the requirement that a
type use Rc in conjunction with Mutex. We must consider those cases false positives, but
alas they are quite hard to rule out. Luckily they are also rare.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::rc::Rc;
use std::sync::Mutex;
fn foo(interned: Rc&lt;Mutex&lt;i32&gt;&gt;) { ... }
</code></pre>
<p>Better:</p>
<pre><code class="language-rust">use std::rc::Rc;
use std::cell::RefCell
fn foo(interned: Rc&lt;RefCell&lt;i32&gt;&gt;) { ... }
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.55.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+rc_mutex">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/types/mod.rs#L322">View Source</a></div></div></div></article><article id="read_line_without_trim"><input id="label-read_line_without_trim" type="checkbox"><label for="label-read_line_without_trim"><h2 class="lint-title"><div class="panel-title-name" id="lint-read_line_without_trim">read_line_without_trim
<a href="#read_line_without_trim" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Looks for calls to [<code>Stdin::read_line</code>] to read a line from the standard input
into a string, then later attempting to use that string for an operation that will never
work for strings with a trailing newline character in it (e.g. parsing into a <code>i32</code>).</p>
<h3>Why is this bad?</h3>
<p>The operation will always fail at runtime no matter what the user enters, thus
making it a useless operation.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut input = String::new();
std::io::stdin().read_line(&amp;mut input).expect("Failed to read a line");
let num: i32 = input.parse().expect("Not a number!");
assert_eq!(num, 42); // we never even get here!
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut input = String::new();
std::io::stdin().read_line(&amp;mut input).expect("Failed to read a line");
let num: i32 = input.trim_end().parse().expect("Not a number!");
//                  ^^^^^^^^^^^ remove the trailing newline
assert_eq!(num, 42);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+read_line_without_trim">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3508">View Source</a></div></div></div></article><article id="read_zero_byte_vec"><input id="label-read_zero_byte_vec" type="checkbox"><label for="label-read_zero_byte_vec"><h2 class="lint-title"><div class="panel-title-name" id="lint-read_zero_byte_vec">read_zero_byte_vec
<a href="#read_zero_byte_vec" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint catches reads into a zero-length <code>Vec</code>.
Especially in the case of a call to <code>with_capacity</code>, this lint warns that read
gets the number of bytes from the <code>Vec</code>’s length, not its capacity.</p>
<h3>Why is this bad?</h3>
<p>Reading zero bytes is almost certainly not the intended behavior.</p>
<h3>Known problems</h3>
<p>In theory, a very unusual read implementation could assign some semantic meaning
to zero-byte reads. But it seems exceptionally unlikely that code intending to do
a zero-byte read would allocate a <code>Vec</code> for it.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::io;
fn foo&lt;F: io::Read&gt;(mut f: F) {
    let mut data = Vec::with_capacity(100);
    f.read(&amp;mut data).unwrap();
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::io;
fn foo&lt;F: io::Read&gt;(mut f: F) {
    let mut data = Vec::with_capacity(100);
    data.resize(100, 0);
    f.read(&amp;mut data).unwrap();
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.63.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+read_zero_byte_vec">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/read_zero_byte_vec.rs#L13">View Source</a></div></div></div></article><article id="readonly_write_lock"><input id="label-readonly_write_lock" type="checkbox"><label for="label-readonly_write_lock"><h2 class="lint-title"><div class="panel-title-name" id="lint-readonly_write_lock">readonly_write_lock
<a href="#readonly_write_lock" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Looks for calls to <code>RwLock::write</code> where the lock is only used for reading.</p>
<h3>Why is this bad?</h3>
<p>The write portion of <code>RwLock</code> is exclusive, meaning that no other thread
can access the lock while this writer is active.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::sync::RwLock;
fn assert_is_zero(lock: &amp;RwLock&lt;i32&gt;) {
    let num = lock.write().unwrap();
    assert_eq!(*num, 0);
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::sync::RwLock;
fn assert_is_zero(lock: &amp;RwLock&lt;i32&gt;) {
    let num = lock.read().unwrap();
    assert_eq!(*num, 0);
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+readonly_write_lock">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3654">View Source</a></div></div></div></article><article id="recursive_format_impl"><input id="label-recursive_format_impl" type="checkbox"><label for="label-recursive_format_impl"><h2 class="lint-title"><div class="panel-title-name" id="lint-recursive_format_impl">recursive_format_impl
<a href="#recursive_format_impl" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for format trait implementations (e.g. <code>Display</code>) with a recursive call to itself
which uses <code>self</code> as a parameter.
This is typically done indirectly with the <code>write!</code> macro or with <code>to_string()</code>.</p>
<h3>Why is this bad?</h3>
<p>This will lead to infinite recursion and a stack overflow.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::fmt;

struct Structure(i32);
impl fmt::Display for Structure {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "{}", self.to_string())
    }
}

</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::fmt;

struct Structure(i32);
impl fmt::Display for Structure {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "{}", self.0)
    }
}
</code></pre>
<h3>Past names</h3>
<ul>
<li>to_string_in_display</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.48.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+recursive_format_impl">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/format_impl.rs#L13">View Source</a></div></div></div></article><article id="redundant_allocation"><input id="label-redundant_allocation" type="checkbox"><label for="label-redundant_allocation"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_allocation">redundant_allocation
<a href="#redundant_allocation" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of redundant allocations anywhere in the code.</p>
<h3>Why is this bad?</h3>
<p>Expressions such as <code>Rc&lt;&amp;T&gt;</code>, <code>Rc&lt;Rc&lt;T&gt;&gt;</code>, <code>Rc&lt;Arc&lt;T&gt;&gt;</code>, <code>Rc&lt;Box&lt;T&gt;&gt;</code>, <code>Arc&lt;&amp;T&gt;</code>, <code>Arc&lt;Rc&lt;T&gt;&gt;</code>,
<code>Arc&lt;Arc&lt;T&gt;&gt;</code>, <code>Arc&lt;Box&lt;T&gt;&gt;</code>, <code>Box&lt;&amp;T&gt;</code>, <code>Box&lt;Rc&lt;T&gt;&gt;</code>, <code>Box&lt;Arc&lt;T&gt;&gt;</code>, <code>Box&lt;Box&lt;T&gt;&gt;</code>, add an unnecessary level of indirection.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(bar: Rc&lt;&amp;usize&gt;) {}
</code></pre>
<p>Better:</p>
<pre><code class="language-rust">fn foo(bar: &amp;usize) {}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.44.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_allocation">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/types/mod.rs#L189">View Source</a></div></div></div></article><article id="redundant_as_str"><input id="label-redundant_as_str" type="checkbox"><label for="label-redundant_as_str"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_as_str">redundant_as_str
<a href="#redundant_as_str" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>as_str()</code> on a <code>String</code> chained with a method available on the <code>String</code> itself.</p>
<h3>Why is this bad?</h3>
<p>The <code>as_str()</code> conversion is pointless and can be removed for simplicity and cleanliness.</p>
<h3>Example</h3>
<pre><code class="language-rust">let owned_string = "This is a string".to_owned();
owned_string.as_str().as_bytes()
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let owned_string = "This is a string".to_owned();
owned_string.as_bytes()
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.74.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_as_str">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3748">View Source</a></div></div></div></article><article id="redundant_async_block"><input id="label-redundant_async_block" type="checkbox"><label for="label-redundant_async_block"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_async_block">redundant_async_block
<a href="#redundant_async_block" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>async</code> block that only returns <code>await</code> on a future.</p>
<h3>Why is this bad?</h3>
<p>It is simpler and more efficient to use the future directly.</p>
<h3>Example</h3>
<pre><code class="language-rust">let f = async {
    1 + 2
};
let fut = async {
    f.await
};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let f = async {
    1 + 2
};
let fut = f;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_async_block">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/redundant_async_block.rs#L11">View Source</a></div></div></div></article><article id="redundant_at_rest_pattern"><input id="label-redundant_at_rest_pattern" type="checkbox"><label for="label-redundant_at_rest_pattern"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_at_rest_pattern">redundant_at_rest_pattern
<a href="#redundant_at_rest_pattern" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>[all @ ..]</code> patterns.</p>
<h3>Why is this bad?</h3>
<p>In all cases, <code>all</code> works fine and can often make code simpler, as you possibly won’t need
to convert from say a <code>Vec</code> to a slice by dereferencing.</p>
<h3>Example</h3>
<pre><code class="language-rust">if let [all @ ..] = &amp;*v {
    // NOTE: Type is a slice here
    println!("all elements: {all:#?}");
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if let all = v {
    // NOTE: Type is a `Vec` here
    println!("all elements: {all:#?}");
}
// or
println!("all elements: {v:#?}");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_at_rest_pattern">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/misc_early/mod.rs#L275">View Source</a></div></div></div></article><article id="redundant_clone"><input id="label-redundant_clone" type="checkbox"><label for="label-redundant_clone"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_clone">redundant_clone
<a href="#redundant_clone" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for a redundant <code>clone()</code> (and its relatives) which clones an owned
value that is going to be dropped without further use.</p>
<h3>Why is this bad?</h3>
<p>It is not always possible for the compiler to eliminate useless
allocations and deallocations generated by redundant <code>clone()</code>s.</p>
<h3>Known problems</h3>
<p>False-negatives: analysis performed by this lint is conservative and limited.</p>
<h3>Example</h3>
<pre><code class="language-rust">{
    let x = Foo::new();
    call(x.clone());
    call(x.clone()); // this can just pass `x`
}

["lorem", "ipsum"].join(" ").to_string();

Path::new("/a/b").join("c").to_path_buf();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.32.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_clone">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/redundant_clone.rs#L26">View Source</a></div></div></div></article><article id="redundant_closure"><input id="label-redundant_closure" type="checkbox"><label for="label-redundant_closure"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_closure">redundant_closure
<a href="#redundant_closure" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for closures which just call another function where
the function can be called directly. <code>unsafe</code> functions, calls where types
get adjusted or where the callee is marked <code>#[track_caller]</code> are ignored.</p>
<h3>Why is this bad?</h3>
<p>Needlessly creating a closure adds code for no benefit
and gives the optimizer more work.</p>
<h3>Example</h3>
<pre><code class="language-rust">xs.map(|x| foo(x))
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// where `foo(_)` is a plain function that takes the exact argument type of `x`.
xs.map(foo)
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_closure">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/eta_reduction.rs#L21">View Source</a></div></div></div></article><article id="redundant_closure_call"><input id="label-redundant_closure_call" type="checkbox"><label for="label-redundant_closure_call"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_closure_call">redundant_closure_call
<a href="#redundant_closure_call" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects closures called in the same expression where they
are defined.</p>
<h3>Why is this bad?</h3>
<p>It is unnecessarily adding to the expression’s
complexity.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = (|| 42)();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a = 42;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_closure_call">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/redundant_closure_call.rs#L16">View Source</a></div></div></div></article><article id="redundant_closure_for_method_calls"><input id="label-redundant_closure_for_method_calls" type="checkbox"><label for="label-redundant_closure_for_method_calls"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_closure_for_method_calls">redundant_closure_for_method_calls
<a href="#redundant_closure_for_method_calls" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for closures which only invoke a method on the closure
argument and can be replaced by referencing the method directly.</p>
<h3>Why is this bad?</h3>
<p>It’s unnecessary to create the closure.</p>
<h3>Example</h3>
<pre><code class="language-rust">Some('a').map(|s| s.to_uppercase());
</code></pre>
<p>may be rewritten as</p>
<pre><code class="language-rust">Some('a').map(char::to_uppercase);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.35.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_closure_for_method_calls">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/eta_reduction.rs#L47">View Source</a></div></div></div></article><article id="redundant_comparisons"><input id="label-redundant_comparisons" type="checkbox"><label for="label-redundant_comparisons"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_comparisons">redundant_comparisons
<a href="#redundant_comparisons" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for ineffective double comparisons against constants.</p>
<h3>Why is this bad?</h3>
<p>Only one of the comparisons has any effect on the result, the programmer
probably intended to flip one of the comparison operators, or compare a
different value entirely.</p>
<h3>Example</h3>
<pre><code class="language-rust">if status_code &lt;= 400 &amp;&amp; status_code &lt; 500 {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_comparisons">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L339">View Source</a></div></div></div></article><article id="redundant_else"><input id="label-redundant_else" type="checkbox"><label for="label-redundant_else"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_else">redundant_else
<a href="#redundant_else" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>else</code> blocks that can be removed without changing semantics.</p>
<h3>Why is this bad?</h3>
<p>The <code>else</code> block adds unnecessary indentation and verbosity.</p>
<h3>Known problems</h3>
<p>Some may prefer to keep the <code>else</code> block for clarity.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn my_func(count: u32) {
    if count == 0 {
        print!("Nothing to do");
        return;
    } else {
        print!("Moving on...");
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn my_func(count: u32) {
    if count == 0 {
        print!("Nothing to do");
        return;
    }
    print!("Moving on...");
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.50.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_else">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/redundant_else.rs#L10">View Source</a></div></div></div></article><article id="redundant_feature_names"><input id="label-redundant_feature_names" type="checkbox"><label for="label-redundant_feature_names"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_feature_names">redundant_feature_names
<a href="#redundant_feature_names" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-cargo">cargo</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for feature names with prefix <code>use-</code>, <code>with-</code> or suffix <code>-support</code></p>
<h3>Why is this bad?</h3>
<p>These prefixes and suffixes have no significant meaning.</p>
<h3>Example</h3>
<pre><code class="language-toml">[features]
default = ["use-abc", "with-def", "ghi-support"]
use-abc = []  // redundant
with-def = []   // redundant
ghi-support = []   // redundant
</code></pre>
<p>Use instead:</p>
<pre><code class="language-toml">[features]
default = ["abc", "def", "ghi"]
abc = []
def = []
ghi = []
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.57.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_feature_names">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/cargo/mod.rs#L59">View Source</a></div></div></div></article><article id="redundant_field_names"><input id="label-redundant_field_names" type="checkbox"><label for="label-redundant_field_names"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_field_names">redundant_field_names
<a href="#redundant_field_names" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for fields in struct literals where shorthands
could be used.</p>
<h3>Why is this bad?</h3>
<p>If the field and variable names are the same,
the field name is redundant.</p>
<h3>Example</h3>
<pre><code class="language-rust">let bar: u8 = 123;

struct Foo {
    bar: u8,
}

let foo = Foo { bar: bar };
</code></pre>
<p>the last line can be simplified to</p>
<pre><code class="language-rust">let foo = Foo { bar };
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_field_names">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/redundant_field_names.rs#L9">View Source</a></div></div></div></article><article id="redundant_guards"><input id="label-redundant_guards" type="checkbox"><label for="label-redundant_guards"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_guards">redundant_guards
<a href="#redundant_guards" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for unnecessary guards in match expressions.</p>
<h3>Why is this bad?</h3>
<p>It’s more complex and much less readable. Making it part of the pattern can improve
exhaustiveness checking as well.</p>
<h3>Example</h3>
<pre><code class="language-rust">match x {
    Some(x) if matches!(x, Some(1)) =&gt; ..,
    Some(x) if x == Some(2) =&gt; ..,
    _ =&gt; todo!(),
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">match x {
    Some(Some(1)) =&gt; ..,
    Some(Some(2)) =&gt; ..,
    _ =&gt; todo!(),
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_guards">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L945">View Source</a></div></div></div></article><article id="redundant_iter_cloned"><input id="label-redundant_iter_cloned" type="checkbox"><label for="label-redundant_iter_cloned"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_iter_cloned">redundant_iter_cloned
<a href="#redundant_iter_cloned" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>Iterator::cloned</code> where the original value could be used
instead.</p>
<h3>Why is this bad?</h3>
<p>It is not always possible for the compiler to eliminate useless allocations and
deallocations generated by redundant <code>clone()</code>s.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = vec![String::new()];
let _ = x.iter().cloned().map(|x| x.len());
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = vec![String::new()];
let _ = x.iter().map(|x| x.len());
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.92.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_iter_cloned">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4654">View Source</a></div></div></div></article><article id="redundant_locals"><input id="label-redundant_locals" type="checkbox"><label for="label-redundant_locals"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_locals">redundant_locals
<a href="#redundant_locals" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for redundant redefinitions of local bindings.</p>
<h3>Why is this bad?</h3>
<p>Redundant redefinitions of local bindings do not change behavior other than variable’s lifetimes and are likely to be unintended.</p>
<p>These rebindings can be intentional to shorten the lifetimes of variables because they affect when the <code>Drop</code> implementation is called. Other than that, they do not affect your code’s meaning but they <em>may</em> affect <code>rustc</code>’s stack allocation.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = 0;
let a = a;

fn foo(b: i32) {
    let b = b;
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a = 0;
// no redefinition with the same name

fn foo(b: i32) {
  // no redefinition with the same name
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_locals">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/redundant_locals.rs#L14">View Source</a></div></div></div></article><article id="redundant_pattern"><input id="label-redundant_pattern" type="checkbox"><label for="label-redundant_pattern"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_pattern">redundant_pattern
<a href="#redundant_pattern" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for patterns in the form <code>name @ _</code>.</p>
<h3>Why is this bad?</h3>
<p>It’s almost always more readable to just use direct
bindings.</p>
<h3>Example</h3>
<pre><code class="language-rust">match v {
    Some(x) =&gt; (),
    y @ _ =&gt; (),
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">match v {
    Some(x) =&gt; (),
    y =&gt; (),
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_pattern">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/misc_early/mod.rs#L205">View Source</a></div></div></div></article><article id="redundant_pattern_matching"><input id="label-redundant_pattern_matching" type="checkbox"><label for="label-redundant_pattern_matching"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_pattern_matching">redundant_pattern_matching
<a href="#redundant_pattern_matching" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Lint for redundant pattern matching over <code>Result</code>, <code>Option</code>,
<code>std::task::Poll</code>, <code>std::net::IpAddr</code> or <code>bool</code>s</p>
<h3>Why is this bad?</h3>
<p>It’s more concise and clear to just use the proper
utility function or using the condition directly</p>
<h3>Known problems</h3>
<p>For suggestions involving bindings in patterns, this will change the drop order for the matched type.
Both <code>if let</code> and <code>while let</code> will drop the value at the end of the block, both <code>if</code> and <code>while</code> will drop the
value before entering the block. For most types this change will not matter, but for a few
types this will not be an acceptable change (e.g. locks). See the
<a href="https://doc.rust-lang.org/reference/destructors.html#drop-scopes">reference</a> for more about
drop order.</p>
<h3>Example</h3>
<pre><code class="language-rust">if let Ok(_) = Ok::&lt;i32, i32&gt;(42) {}
if let Err(_) = Err::&lt;i32, i32&gt;(42) {}
if let None = None::&lt;()&gt; {}
if let Some(_) = Some(42) {}
if let Poll::Pending = Poll::Pending::&lt;()&gt; {}
if let Poll::Ready(_) = Poll::Ready(42) {}
if let IpAddr::V4(_) = IpAddr::V4(Ipv4Addr::LOCALHOST) {}
if let IpAddr::V6(_) = IpAddr::V6(Ipv6Addr::LOCALHOST) {}
match Ok::&lt;i32, i32&gt;(42) {
    Ok(_) =&gt; true,
    Err(_) =&gt; false,
};

let cond = true;
if let true = cond {}
matches!(cond, true);
</code></pre>
<p>The more idiomatic use would be:</p>
<pre><code class="language-rust">if Ok::&lt;i32, i32&gt;(42).is_ok() {}
if Err::&lt;i32, i32&gt;(42).is_err() {}
if None::&lt;()&gt;.is_none() {}
if Some(42).is_some() {}
if Poll::Pending::&lt;()&gt;.is_pending() {}
if Poll::Ready(42).is_ready() {}
if IpAddr::V4(Ipv4Addr::LOCALHOST).is_ipv4() {}
if IpAddr::V6(Ipv6Addr::LOCALHOST).is_ipv6() {}
Ok::&lt;i32, i32&gt;(42).is_ok();

let cond = true;
if cond {}
cond;
</code></pre>
<h3>Past names</h3>
<ul>
<li>if_let_redundant_pattern_matching</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.31.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_pattern_matching">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L470">View Source</a></div></div></div></article><article id="redundant_pub_crate"><input id="label-redundant_pub_crate" type="checkbox"><label for="label-redundant_pub_crate"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_pub_crate">redundant_pub_crate
<a href="#redundant_pub_crate" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for items declared <code>pub(crate)</code> that are not crate visible because they
are inside a private module.</p>
<h3>Why is this bad?</h3>
<p>Writing <code>pub(crate)</code> is misleading when it’s redundant due to the parent
module’s visibility.</p>
<h3>Example</h3>
<pre><code class="language-rust">mod internal {
    pub(crate) fn internal_fn() { }
}
</code></pre>
<p>This function is not visible outside the module and it can be declared with <code>pub</code> or
private visibility</p>
<pre><code class="language-rust">mod internal {
    pub fn internal_fn() { }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.44.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_pub_crate">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/redundant_pub_crate.rs#L11">View Source</a></div></div></div></article><article id="redundant_slicing"><input id="label-redundant_slicing" type="checkbox"><label for="label-redundant_slicing"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_slicing">redundant_slicing
<a href="#redundant_slicing" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for redundant slicing expressions which use the full range, and
do not change the type.</p>
<h3>Why is this bad?</h3>
<p>It unnecessarily adds complexity to the expression.</p>
<h3>Known problems</h3>
<p>If the type being sliced has an implementation of <code>Index&lt;RangeFull&gt;</code>
that actually changes anything then it can’t be removed. However, this would be surprising
to people reading the code and should have a note with it.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn get_slice(x: &amp;[u32]) -&gt; &amp;[u32] {
    &amp;x[..]
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn get_slice(x: &amp;[u32]) -&gt; &amp;[u32] {
    x
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.51.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_slicing">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/redundant_slicing.rs#L14">View Source</a></div></div></div></article><article id="redundant_static_lifetimes"><input id="label-redundant_static_lifetimes" type="checkbox"><label for="label-redundant_static_lifetimes"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_static_lifetimes">redundant_static_lifetimes
<a href="#redundant_static_lifetimes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for constants and statics with an explicit <code>'static</code> lifetime.</p>
<h3>Why is this bad?</h3>
<p>Adding <code>'static</code> to every reference can create very
complicated types.</p>
<h3>Example</h3>
<pre><code class="language-rust">const FOO: &amp;'static [(&amp;'static str, &amp;'static str, fn(&amp;Bar) -&gt; bool)] =
&amp;[...]
static FOO: &amp;'static [(&amp;'static str, &amp;'static str, fn(&amp;Bar) -&gt; bool)] =
&amp;[...]
</code></pre>
<p>This code can be rewritten as</p>
<pre><code class="language-rust"> const FOO: &amp;[(&amp;str, &amp;str, fn(&amp;Bar) -&gt; bool)] = &amp;[...]
 static FOO: &amp;[(&amp;str, &amp;str, fn(&amp;Bar) -&gt; bool)] = &amp;[...]
</code></pre>
<h3>Past names</h3>
<ul>
<li>const_static_lifetime</li>
</ul>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.37.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_static_lifetimes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/redundant_static_lifetimes.rs#L11">View Source</a></div></div></div></article><article id="redundant_test_prefix"><input id="label-redundant_test_prefix" type="checkbox"><label for="label-redundant_test_prefix"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_test_prefix">redundant_test_prefix
<a href="#redundant_test_prefix" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for test functions (functions annotated with <code>#[test]</code>) that are prefixed
with <code>test_</code> which is redundant.</p>
<h3>Why is this bad?</h3>
<p>This is redundant because test functions are already annotated with <code>#[test]</code>.
Moreover, it clutters the output of <code>cargo test</code> since test functions are expanded as
<code>module::tests::test_use_case</code> in the output. Without the redundant prefix, the output
becomes <code>module::tests::use_case</code>, which is more readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_use_case() {
      // test code
  }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn use_case() {
      // test code
  }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.88.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_test_prefix">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/redundant_test_prefix.rs#L15">View Source</a></div></div></div></article><article id="redundant_type_annotations"><input id="label-redundant_type_annotations" type="checkbox"><label for="label-redundant_type_annotations"><h2 class="lint-title"><div class="panel-title-name" id="lint-redundant_type_annotations">redundant_type_annotations
<a href="#redundant_type_annotations" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns about needless / redundant type annotations.</p>
<h3>Why restrict this?</h3>
<p>Code without type annotations is shorter and in most cases
more idiomatic and easier to modify.</p>
<h3>Limitations</h3>
<p>This lint doesn’t support:</p>
<ul>
<li>Generics</li>
<li>Refs returned from anything else than a <code>MethodCall</code></li>
<li>Complex types (tuples, arrays, etc…)</li>
<li><code>Path</code> to anything else than a primitive type.</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">let foo: String = String::new();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let foo = String::new();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+redundant_type_annotations">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/redundant_type_annotations.rs#L10">View Source</a></div></div></div></article><article id="ref_as_ptr"><input id="label-ref_as_ptr" type="checkbox"><label for="label-ref_as_ptr"><h2 class="lint-title"><div class="panel-title-name" id="lint-ref_as_ptr">ref_as_ptr
<a href="#ref_as_ptr" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for casts of references to pointer using <code>as</code>
and suggests <code>std::ptr::from_ref</code> and <code>std::ptr::from_mut</code> instead.</p>
<h3>Why is this bad?</h3>
<p>Using <code>as</code> casts may result in silently changing mutability or type.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a_ref = &amp;1;
let a_ptr = a_ref as *const _;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a_ref = &amp;1;
let a_ptr = std::ptr::from_ref(a_ref);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.78.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ref_as_ptr">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L714">View Source</a></div></div></div></article><article id="ref_binding_to_reference"><input id="label-ref_binding_to_reference" type="checkbox"><label for="label-ref_binding_to_reference"><h2 class="lint-title"><div class="panel-title-name" id="lint-ref_binding_to_reference">ref_binding_to_reference
<a href="#ref_binding_to_reference" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>ref</code> bindings which create a reference to a reference.</p>
<h3>Why is this bad?</h3>
<p>The address-of operator at the use site is clearer about the need for a reference.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = Some("");
if let Some(ref x) = x {
    // use `x` here
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = Some("");
if let Some(x) = x {
    // use `&amp;x` here
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.54.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ref_binding_to_reference">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/dereference.rs#L95">View Source</a></div></div></div></article><article id="ref_option"><input id="label-ref_option" type="checkbox"><label for="label-ref_option"><h2 class="lint-title"><div class="panel-title-name" id="lint-ref_option">ref_option
<a href="#ref_option" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns when a function signature uses <code>&amp;Option&lt;T&gt;</code> instead of <code>Option&lt;&amp;T&gt;</code>.</p>
<h3>Why is this bad?</h3>
<p>More flexibility, better memory optimization, and more idiomatic Rust code.</p>
<p><code>&amp;Option&lt;T&gt;</code> in a function signature breaks encapsulation because the caller must own T
and move it into an Option to call with it. When returned, the owner must internally store
it as <code>Option&lt;T&gt;</code> in order to return it.
At a lower level, <code>&amp;Option&lt;T&gt;</code> points to memory with the <code>presence</code> bit flag plus the <code>T</code> value,
whereas <code>Option&lt;&amp;T&gt;</code> is usually <a href="https://doc.rust-lang.org/1.81.0/std/option/index.html#representation">optimized</a>
to a single pointer, so it may be more optimal.</p>
<p>See this <a href="https://www.youtube.com/watch?v=6c7pZYP_iIE">YouTube video</a> by
Logan Smith for an in-depth explanation of why this is important.</p>
<h3>Known problems</h3>
<p>This lint recommends changing the function signatures, but it cannot
automatically change the function calls or the function implementations.</p>
<h3>Example</h3>
<pre><code class="language-rust">// caller uses  foo(&amp;opt)
fn foo(a: &amp;Option&lt;String&gt;) {}
fn bar(&amp;self) -&gt; &amp;Option&lt;String&gt; { &amp;None }
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// caller should use  `foo1(opt.as_ref())`
fn foo1(a: Option&lt;&amp;String&gt;) {}
// better yet, use string slice  `foo2(opt.as_deref())`
fn foo2(a: Option&lt;&amp;str&gt;) {}
fn bar(&amp;self) -&gt; Option&lt;&amp;String&gt; { None }
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.83.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ref_option">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/functions/mod.rs#L429">View Source</a></div></div></div></article><article id="ref_option_ref"><input id="label-ref_option_ref" type="checkbox"><label for="label-ref_option_ref"><h2 class="lint-title"><div class="panel-title-name" id="lint-ref_option_ref">ref_option_ref
<a href="#ref_option_ref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>&amp;Option&lt;&amp;T&gt;</code>.</p>
<h3>Why is this bad?</h3>
<p>Since <code>&amp;</code> is Copy, it’s useless to have a
reference on <code>Option&lt;&amp;T&gt;</code>.</p>
<h3>Known problems</h3>
<p>It may be irrelevant to use this lint on
public API code as it will make a breaking change to apply it.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: &amp;Option&lt;&amp;u32&gt; = &amp;Some(&amp;0u32);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x: Option&lt;&amp;u32&gt; = Some(&amp;0u32);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ref_option_ref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ref_option_ref.rs#L10">View Source</a></div></div></div></article><article id="ref_patterns"><input id="label-ref_patterns" type="checkbox"><label for="label-ref_patterns"><h2 class="lint-title"><div class="panel-title-name" id="lint-ref_patterns">ref_patterns
<a href="#ref_patterns" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usages of the <code>ref</code> keyword.</p>
<h3>Why restrict this?</h3>
<p>The <code>ref</code> keyword can be confusing for people unfamiliar with it, and often
it is more concise to use <code>&amp;</code> instead.</p>
<h3>Example</h3>
<pre><code class="language-rust">let opt = Some(5);
if let Some(ref foo) = opt {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let opt = Some(5);
if let Some(foo) = &amp;opt {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.71.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+ref_patterns">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ref_patterns.rs#L6">View Source</a></div></div></div></article><article id="regex_creation_in_loops"><input id="label-regex_creation_in_loops" type="checkbox"><label for="label-regex_creation_in_loops"><h2 class="lint-title"><div class="panel-title-name" id="lint-regex_creation_in_loops">regex_creation_in_loops
<a href="#regex_creation_in_loops" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <a href="https://crates.io/crates/regex">regex</a> compilation inside a loop with a literal.</p>
<h3>Why is this bad?</h3>
<p>Compiling a regex is a much more expensive operation than using one, and a compiled regex can be used multiple times.
This is documented as an antipattern <a href="https://docs.rs/regex/latest/regex/#avoid-re-compiling-regexes-especially-in-a-loop">on the regex documentation</a></p>
<h3>Example</h3>
<pre><code class="language-rust">for haystack in haystacks {
    let regex = regex::Regex::new(MY_REGEX).unwrap();
    if regex.is_match(haystack) {
        // Perform operation
    }
}
</code></pre>
<p>can be replaced with</p>
<pre><code class="language-rust">let regex = regex::Regex::new(MY_REGEX).unwrap();
for haystack in haystacks {
    if regex.is_match(haystack) {
        // Perform operation
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.84.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+regex_creation_in_loops">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/regex.rs#L70">View Source</a></div></div></div></article><article id="regex_macro"><input id="label-regex_macro" type="checkbox"><label for="label-regex_macro"><h2 class="lint-title"><div class="panel-title-name" id="lint-regex_macro">regex_macro
<a href="#regex_macro" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p>The <code>regex!</code> macro was removed from the regex crate in 2018.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">1.47.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+regex_macro">Related Issues</a></div></div></div></article><article id="renamed_function_params"><input id="label-renamed_function_params" type="checkbox"><label for="label-renamed_function_params"><h2 class="lint-title"><div class="panel-title-name" id="lint-renamed_function_params">renamed_function_params
<a href="#renamed_function_params" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Lints when the name of function parameters from trait impl is
different than its default implementation.</p>
<h3>Why restrict this?</h3>
<p>Using the default name for parameters of a trait method is more consistent.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct A(u32);

impl PartialEq for A {
    fn eq(&amp;self, b: &amp;Self) -&gt; bool {
        self.0 == b.0
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct A(u32);

impl PartialEq for A {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 == other.0
    }
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li><code>allow-renamed-params-for</code>:  List of trait paths to ignore when checking renamed function parameters.</li>
</ul>
<h4>Example</h4>
<pre><code class="language-toml">allow-renamed-params-for = [ "std::convert::From" ]
</code></pre>
<h4>Noteworthy</h4>
<ul>
<li>
<p>By default, the following traits are ignored: <code>From</code>, <code>TryFrom</code>, <code>FromStr</code></p>
</li>
<li>
<p><code>".."</code> can be used as part of the list to indicate that the configured values should be appended to the
default configuration of Clippy. By default, any configuration will replace the default value.</p>
<p>(default: <code>["core::convert::From", "core::convert::TryFrom", "core::str::FromStr"]</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.80.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+renamed_function_params">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/functions/mod.rs#L395">View Source</a></div></div></div></article><article id="repeat_once"><input id="label-repeat_once" type="checkbox"><label for="label-repeat_once"><h2 class="lint-title"><div class="panel-title-name" id="lint-repeat_once">repeat_once
<a href="#repeat_once" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.repeat(1)</code> and suggest the following method for each types.</p>
<ul>
<li><code>.to_string()</code> for <code>str</code></li>
<li><code>.clone()</code> for <code>String</code></li>
<li><code>.to_vec()</code> for <code>slice</code></li>
</ul>
<p>The lint will evaluate constant expressions and values as arguments of <code>.repeat(..)</code> and emit a message if
they are equivalent to <code>1</code>. (Related discussion in <a href="https://github.com/rust-lang/rust-clippy/issues/7306">rust-clippy#7306</a>)</p>
<h3>Why is this bad?</h3>
<p>For example, <code>String.repeat(1)</code> is equivalent to <code>.clone()</code>. If cloning
the string is the intention behind this, <code>clone()</code> should be used.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn main() {
    let x = String::from("hello world").repeat(1);
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn main() {
    let x = String::from("hello world").clone();
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.47.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+repeat_once">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3007">View Source</a></div></div></div></article><article id="repeat_vec_with_capacity"><input id="label-repeat_vec_with_capacity" type="checkbox"><label for="label-repeat_vec_with_capacity"><h2 class="lint-title"><div class="panel-title-name" id="lint-repeat_vec_with_capacity">repeat_vec_with_capacity
<a href="#repeat_vec_with_capacity" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Looks for patterns such as <code>vec![Vec::with_capacity(x); n]</code> or <code>iter::repeat(Vec::with_capacity(x))</code>.</p>
<h3>Why is this bad?</h3>
<p>These constructs work by cloning the element, but cloning a <code>Vec&lt;_&gt;</code> does not
respect the old vector’s capacity and effectively discards it.</p>
<p>This makes <code>iter::repeat(Vec::with_capacity(x))</code> especially suspicious because the user most certainly
expected that the yielded <code>Vec&lt;_&gt;</code> will have the requested capacity, otherwise one can simply write
<code>iter::repeat(Vec::new())</code> instead and it will have the same effect.</p>
<p>Similarly for <code>vec![x; n]</code>, the element <code>x</code> is cloned to fill the vec.
Unlike <code>iter::repeat</code> however, the vec repeat macro does not have to clone the value <code>n</code> times
but just <code>n - 1</code> times, because it can reuse the passed value for the last slot.
That means that the last <code>Vec&lt;_&gt;</code> gets the requested capacity but all other ones do not.</p>
<h3>Example</h3>
<pre><code class="language-rust">
let _: Vec&lt;Vec&lt;u8&gt;&gt; = vec![Vec::with_capacity(42); 123];
let _: Vec&lt;Vec&lt;u8&gt;&gt; = iter::repeat(Vec::with_capacity(42)).take(123).collect();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">
let _: Vec&lt;Vec&lt;u8&gt;&gt; = iter::repeat_with(|| Vec::with_capacity(42)).take(123).collect();
//                                      ^^^ this closure executes 123 times
//                                          and the vecs will have the expected capacity
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.76.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+repeat_vec_with_capacity">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/repeat_vec_with_capacity.rs#L25">View Source</a></div></div></div></article><article id="replace_box"><input id="label-replace_box" type="checkbox"><label for="label-replace_box"><h2 class="lint-title"><div class="panel-title-name" id="lint-replace_box">replace_box
<a href="#replace_box" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects assignments of <code>Default::default()</code> or <code>Box::new(value)</code>
to a place of type <code>Box&lt;T&gt;</code>.</p>
<h3>Why is this bad?</h3>
<p>This incurs an extra heap allocation compared to assigning the boxed
storage.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut b = Box::new(1u32);
b = Default::default();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut b = Box::new(1u32);
*b = Default::default();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.92.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+replace_box">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/replace_box.rs#L18">View Source</a></div></div></div></article><article id="replace_consts"><input id="label-replace_consts" type="checkbox"><label for="label-replace_consts"><h2 class="lint-title"><div class="panel-title-name" id="lint-replace_consts">replace_consts
<a href="#replace_consts" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p><code>min_value</code> and <code>max_value</code> are now deprecated.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">1.44.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+replace_consts">Related Issues</a></div></div></div></article><article id="repr_packed_without_abi"><input id="label-repr_packed_without_abi" type="checkbox"><label for="label-repr_packed_without_abi"><h2 class="lint-title"><div class="panel-title-name" id="lint-repr_packed_without_abi">repr_packed_without_abi
<a href="#repr_packed_without_abi" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for items with <code>#[repr(packed)]</code>-attribute without ABI qualification</p>
<h3>Why is this bad?</h3>
<p>Without qualification, <code>repr(packed)</code> implies <code>repr(Rust)</code>. The Rust-ABI is inherently unstable.
While this is fine as long as the type is accessed correctly within Rust-code, most uses
of <code>#[repr(packed)]</code> involve FFI and/or data structures specified by network-protocols or
other external specifications. In such situations, the unstable Rust-ABI implied in
<code>#[repr(packed)]</code> may lead to future bugs should the Rust-ABI change.</p>
<p>In case you are relying on a well defined and stable memory layout, qualify the type’s
representation using the <code>C</code>-ABI. Otherwise, if the type in question is only ever
accessed from Rust-code according to Rust’s rules, use the <code>Rust</code>-ABI explicitly.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[repr(packed)]
struct NetworkPacketHeader {
    header_length: u8,
    header_version: u16
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[repr(C, packed)]
struct NetworkPacketHeader {
    header_length: u8,
    header_version: u16
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.85.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+repr_packed_without_abi">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/attrs/mod.rs#L277">View Source</a></div></div></div></article><article id="reserve_after_initialization"><input id="label-reserve_after_initialization" type="checkbox"><label for="label-reserve_after_initialization"><h2 class="lint-title"><div class="panel-title-name" id="lint-reserve_after_initialization">reserve_after_initialization
<a href="#reserve_after_initialization" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Informs the user about a more concise way to create a vector with a known capacity.</p>
<h3>Why is this bad?</h3>
<p>The <code>Vec::with_capacity</code> constructor is less complex.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut v: Vec&lt;usize&gt; = vec![];
v.reserve(10);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut v: Vec&lt;usize&gt; = Vec::with_capacity(10);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.74.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+reserve_after_initialization">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/reserve_after_initialization.rs#L13">View Source</a></div></div></div></article><article id="rest_pat_in_fully_bound_structs"><input id="label-rest_pat_in_fully_bound_structs" type="checkbox"><label for="label-rest_pat_in_fully_bound_structs"><h2 class="lint-title"><div class="panel-title-name" id="lint-rest_pat_in_fully_bound_structs">rest_pat_in_fully_bound_structs
<a href="#rest_pat_in_fully_bound_structs" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for unnecessary ‘..’ pattern binding on struct when all fields are explicitly matched.</p>
<h3>Why restrict this?</h3>
<p>Correctness and readability. It’s like having a wildcard pattern after
matching all enum variants explicitly.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = A { a: 5 };

match a {
    A { a: 5, .. } =&gt; {},
    _ =&gt; {},
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">match a {
    A { a: 5 } =&gt; {},
    _ =&gt; {},
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.43.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+rest_pat_in_fully_bound_structs">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L436">View Source</a></div></div></div></article><article id="result_filter_map"><input id="label-result_filter_map" type="checkbox"><label for="label-result_filter_map"><h2 class="lint-title"><div class="panel-title-name" id="lint-result_filter_map">result_filter_map
<a href="#result_filter_map" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for iterators of <code>Result</code>s using <code>.filter(Result::is_ok).map(Result::unwrap)</code> that may
be replaced with a <code>.flatten()</code> call.</p>
<h3>Why is this bad?</h3>
<p><code>Result</code> implements <code>IntoIterator&lt;Item = T&gt;</code>. This means that <code>Result</code> can be flattened
automatically without suspicious-looking <code>unwrap</code> calls.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = std::iter::empty::&lt;Result&lt;i32, ()&gt;&gt;().filter(Result::is_ok).map(Result::unwrap);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = std::iter::empty::&lt;Result&lt;i32, ()&gt;&gt;().flatten();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.77.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+result_filter_map">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3863">View Source</a></div></div></div></article><article id="result_large_err"><input id="label-result_large_err" type="checkbox"><label for="label-result_large_err"><h2 class="lint-title"><div class="panel-title-name" id="lint-result_large_err">result_large_err
<a href="#result_large_err" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for functions that return <code>Result</code> with an unusually large
<code>Err</code>-variant.</p>
<h3>Why is this bad?</h3>
<p>A <code>Result</code> is at least as large as the <code>Err</code>-variant. While we
expect that variant to be seldom used, the compiler needs to reserve
and move that much memory every single time.
Furthermore, errors are often simply passed up the call-stack, making
use of the <code>?</code>-operator and its type-conversion mechanics. If the
<code>Err</code>-variant further up the call-stack stores the <code>Err</code>-variant in
question (as library code often does), it itself needs to be at least
as large, propagating the problem.</p>
<h3>Known problems</h3>
<p>The size determined by Clippy is platform-dependent.</p>
<h3>Examples</h3>
<pre><code class="language-rust">pub enum ParseError {
    UnparsedBytes([u8; 512]),
    UnexpectedEof,
}

// The `Result` has at least 512 bytes, even in the `Ok`-case
pub fn parse() -&gt; Result&lt;(), ParseError&gt; {
    Ok(())
}
</code></pre>
<p>should be</p>
<pre><code class="language-rust">pub enum ParseError {
    UnparsedBytes(Box&lt;[u8; 512]&gt;),
    UnexpectedEof,
}

// The `Result` is slightly larger than a pointer
pub fn parse() -&gt; Result&lt;(), ParseError&gt; {
    Ok(())
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>large-error-ignored</code>:  A list of paths to types that should be ignored as overly large <code>Err</code>-variants in a
<code>Result</code> returned from a function</p>
<p>(default: <code>[]</code>)</p>
</li>
<li>
<p><code>large-error-threshold</code>:  The maximum size of the <code>Err</code>-variant in a <code>Result</code> returned from a function</p>
<p>(default: <code>128</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.65.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+result_large_err">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/functions/mod.rs#L277">View Source</a></div></div></div></article><article id="result_map_or_into_option"><input id="label-result_map_or_into_option" type="checkbox"><label for="label-result_map_or_into_option"><h2 class="lint-title"><div class="panel-title-name" id="lint-result_map_or_into_option">result_map_or_into_option
<a href="#result_map_or_into_option" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>_.map_or(None, Some)</code>.</p>
<h3>Why is this bad?</h3>
<p>Readability, this can be written more concisely as
<code>_.ok()</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">assert_eq!(Some(1), r.map_or(None, Some));
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">assert_eq!(Some(1), r.ok());
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.44.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+result_map_or_into_option">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L630">View Source</a></div></div></div></article><article id="result_map_unit_fn"><input id="label-result_map_unit_fn" type="checkbox"><label for="label-result_map_unit_fn"><h2 class="lint-title"><div class="panel-title-name" id="lint-result_map_unit_fn">result_map_unit_fn
<a href="#result_map_unit_fn" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>result.map(f)</code> where f is a function
or closure that returns the unit type <code>()</code>.</p>
<h3>Why is this bad?</h3>
<p>Readability, this can be written more clearly with
an if let statement</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: Result&lt;String, String&gt; = do_stuff();
x.map(log_err_msg);
x.map(|msg| log_err_msg(format_msg(msg)));
</code></pre>
<p>The correct use would be:</p>
<pre><code class="language-rust">let x: Result&lt;String, String&gt; = do_stuff();
if let Ok(msg) = x {
    log_err_msg(msg);
};
if let Ok(msg) = x {
    log_err_msg(format_msg(msg));
};
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+result_map_unit_fn">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/map_unit_fn.rs#L54">View Source</a></div></div></div></article><article id="result_unit_err"><input id="label-result_unit_err" type="checkbox"><label for="label-result_unit_err"><h2 class="lint-title"><div class="panel-title-name" id="lint-result_unit_err">result_unit_err
<a href="#result_unit_err" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for public functions that return a <code>Result</code>
with an <code>Err</code> type of <code>()</code>. It suggests using a custom type that
implements <code>std::error::Error</code>.</p>
<h3>Why is this bad?</h3>
<p>Unit does not implement <code>Error</code> and carries no
further information about what went wrong.</p>
<h3>Known problems</h3>
<p>Of course, this lint assumes that <code>Result</code> is used
for a fallible operation (which is after all the intended use). However
code may opt to (mis)use it as a basic two-variant-enum. In that case,
the suggestion is misguided, and the code should use a custom enum
instead.</p>
<h3>Examples</h3>
<pre><code class="language-rust">pub fn read_u8() -&gt; Result&lt;u8, ()&gt; { Err(()) }
</code></pre>
<p>should become</p>
<pre><code class="language-rust">use std::fmt;

#[derive(Debug)]
pub struct EndOfStream;

impl fmt::Display for EndOfStream {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "End of Stream")
    }
}

impl std::error::Error for EndOfStream { }

pub fn read_u8() -&gt; Result&lt;u8, EndOfStream&gt; { Err(EndOfStream) }
</code></pre>
<p>Note that there are crates that simplify creating the error type, e.g.
<a href="https://docs.rs/thiserror"><code>thiserror</code></a>.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+result_unit_err">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/functions/mod.rs#L227">View Source</a></div></div></div></article><article id="return_and_then"><input id="label-return_and_then" type="checkbox"><label for="label-return_and_then"><h2 class="lint-title"><div class="panel-title-name" id="lint-return_and_then">return_and_then
<a href="#return_and_then" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detect functions that end with <code>Option::and_then</code> or <code>Result::and_then</code>, and suggest using
the <code>?</code> operator instead.</p>
<h3>Why is this bad?</h3>
<p>The <code>and_then</code> method is used to chain a computation that returns an <code>Option</code> or a <code>Result</code>.
This can be replaced with the <code>?</code> operator, which is more concise and idiomatic.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn test(opt: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    opt.and_then(|n| {
        if n &gt; 1 {
            Some(n + 1)
        } else {
            None
       }
    })
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn test(opt: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    let n = opt?;
    if n &gt; 1 {
        Some(n + 1)
    } else {
        None
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.86.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+return_and_then">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4458">View Source</a></div></div></div></article><article id="return_self_not_must_use"><input id="label-return_self_not_must_use" type="checkbox"><label for="label-return_self_not_must_use"><h2 class="lint-title"><div class="panel-title-name" id="lint-return_self_not_must_use">return_self_not_must_use
<a href="#return_self_not_must_use" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint warns when a method returning <code>Self</code> doesn’t have the <code>#[must_use]</code> attribute.</p>
<h3>Why is this bad?</h3>
<p>Methods returning <code>Self</code> often create new values, having the <code>#[must_use]</code> attribute
prevents users from “forgetting” to use the newly created value.</p>
<p>The <code>#[must_use]</code> attribute can be added to the type itself to ensure that instances
are never forgotten. Functions returning a type marked with <code>#[must_use]</code> will not be
linted, as the usage is already enforced by the type attribute.</p>
<h3>Limitations</h3>
<p>This lint is only applied on methods taking a <code>self</code> argument. It would be mostly noise
if it was added on constructors for example.</p>
<h3>Example</h3>
<pre><code class="language-rust">pub struct Bar;
impl Bar {
    // Missing attribute
    pub fn bar(&amp;self) -&gt; Self {
        Self
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// It's better to have the `#[must_use]` attribute on the method like this:
pub struct Bar;
impl Bar {
    #[must_use]
    pub fn bar(&amp;self) -&gt; Self {
        Self
    }
}

// Or on the type definition like this:
#[must_use]
pub struct Bar;
impl Bar {
    pub fn bar(&amp;self) -&gt; Self {
        Self
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.59.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+return_self_not_must_use">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/return_self_not_must_use.rs#L12">View Source</a></div></div></div></article><article id="reversed_empty_ranges"><input id="label-reversed_empty_ranges" type="checkbox"><label for="label-reversed_empty_ranges"><h2 class="lint-title"><div class="panel-title-name" id="lint-reversed_empty_ranges">reversed_empty_ranges
<a href="#reversed_empty_ranges" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for range expressions <code>x..y</code> where both <code>x</code> and <code>y</code>
are constant and <code>x</code> is greater to <code>y</code>. Also triggers if <code>x</code> is equal to <code>y</code> when they are conditions to a <code>for</code> loop.</p>
<h3>Why is this bad?</h3>
<p>Empty ranges yield no values so iterating them is a no-op.
Moreover, trying to use a reversed range to index a slice will panic at run-time.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn main() {
    (10..=0).for_each(|x| println!("{}", x));

    let arr = [1, 2, 3, 4, 5];
    let sub = &amp;arr[3..1];
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn main() {
    (0..=10).rev().for_each(|x| println!("{}", x));

    let arr = [1, 2, 3, 4, 5];
    let sub = &amp;arr[1..3];
}
</code></pre>
<h3>Past names</h3>
<ul>
<li>reverse_range_loop</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.45.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+reversed_empty_ranges">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ranges.rs#L107">View Source</a></div></div></div></article><article id="same_functions_in_if_condition"><input id="label-same_functions_in_if_condition" type="checkbox"><label for="label-same_functions_in_if_condition"><h2 class="lint-title"><div class="panel-title-name" id="lint-same_functions_in_if_condition">same_functions_in_if_condition
<a href="#same_functions_in_if_condition" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for consecutive <code>if</code>s with the same function call.</p>
<h3>Why is this bad?</h3>
<p>This is probably a copy &amp; paste error.
Despite the fact that function can have side effects and <code>if</code> works as
intended, such an approach is implicit and can be considered a “code smell”.</p>
<h3>Example</h3>
<pre><code class="language-rust">if foo() == bar {
    …
} else if foo() == bar {
    …
}
</code></pre>
<p>This probably should be:</p>
<pre><code class="language-rust">if foo() == bar {
    …
} else if foo() == baz {
    …
}
</code></pre>
<p>or if the original code was not a typo and called function mutates a state,
consider move the mutation out of the <code>if</code> condition to avoid similarity to
a copy &amp; paste error:</p>
<pre><code class="language-rust">let first = foo();
if first == bar {
    …
} else {
    let second = foo();
    if second == bar {
    …
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.41.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+same_functions_in_if_condition">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/ifs/mod.rs#L46">View Source</a></div></div></div></article><article id="same_item_push"><input id="label-same_item_push" type="checkbox"><label for="label-same_item_push"><h2 class="lint-title"><div class="panel-title-name" id="lint-same_item_push">same_item_push
<a href="#same_item_push" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks whether a for loop is being used to push a constant
value into a Vec.</p>
<h3>Why is this bad?</h3>
<p>This kind of operation can be expressed more succinctly with
<code>vec![item; SIZE]</code> or <code>vec.resize(NEW_SIZE, item)</code> and using these alternatives may also
have better performance.</p>
<h3>Example</h3>
<pre><code class="language-rust">let item1 = 2;
let item2 = 3;
let mut vec: Vec&lt;u8&gt; = Vec::new();
for _ in 0..20 {
    vec.push(item1);
}
for _ in 0..30 {
    vec.push(item2);
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let item1 = 2;
let item2 = 3;
let mut vec: Vec&lt;u8&gt; = vec![item1; 20];
vec.resize(20 + 30, item2);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.47.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+same_item_push">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L458">View Source</a></div></div></div></article><article id="same_length_and_capacity"><input id="label-same_length_and_capacity" type="checkbox"><label for="label-same_length_and_capacity"><h2 class="lint-title"><div class="panel-title-name" id="lint-same_length_and_capacity">same_length_and_capacity
<a href="#same_length_and_capacity" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usages of <code>Vec::from_raw_parts</code> and <code>String::from_raw_parts</code>
where the same expression is used for the length and the capacity.</p>
<h3>Why is this bad?</h3>
<p>If the same expression is being passed for the length and
capacity, it is most likely a semantic error. In the case of a
Vec, for example, the only way to end up with one that has
the same length and capacity is by going through a boxed slice,
e.g. <code>Box::from(some_vec)</code>, which shrinks the capacity to match
the length.</p>
<h3>Example</h3>
<pre><code class="language-rust">#![feature(vec_into_raw_parts)]
let mut original: Vec::&lt;i32&gt; = Vec::with_capacity(20);
original.extend([1, 2, 3, 4, 5]);

let (ptr, mut len, cap) = original.into_raw_parts();

// I will add three more integers:
unsafe {
   let ptr = ptr as *mut i32;

   for i in 6..9 {
       *ptr.add(i - 1) = i as i32;
       len += 1;
   }
}

// But I forgot the capacity was separate from the length:
let reconstructed = unsafe { Vec::from_raw_parts(ptr, len, len) };
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#![feature(vec_into_raw_parts)]
let mut original: Vec::&lt;i32&gt; = Vec::with_capacity(20);
original.extend([1, 2, 3, 4, 5]);

let (ptr, mut len, cap) = original.into_raw_parts();

// I will add three more integers:
unsafe {
   let ptr = ptr as *mut i32;

   for i in 6..9 {
       *ptr.add(i - 1) = i as i32;
       len += 1;
   }
}

// This time, leverage the previously saved capacity:
let reconstructed = unsafe { Vec::from_raw_parts(ptr, len, cap) };
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.93.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+same_length_and_capacity">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/same_length_and_capacity.rs#L9">View Source</a></div></div></div></article><article id="same_name_method"><input id="label-same_name_method" type="checkbox"><label for="label-same_name_method"><h2 class="lint-title"><div class="panel-title-name" id="lint-same_name_method">same_name_method
<a href="#same_name_method" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>It lints if a struct has two methods with the same name:
one from a trait, another not from a trait.</p>
<h3>Why restrict this?</h3>
<p>Confusing.</p>
<h3>Example</h3>
<pre><code class="language-rust">trait T {
    fn foo(&amp;self) {}
}

struct S;

impl T for S {
    fn foo(&amp;self) {}
}

impl S {
    fn foo(&amp;self) {}
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.57.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+same_name_method">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/same_name_method.rs#L12">View Source</a></div></div></div></article><article id="search_is_some"><input id="label-search_is_some" type="checkbox"><label for="label-search_is_some"><h2 class="lint-title"><div class="panel-title-name" id="lint-search_is_some">search_is_some
<a href="#search_is_some" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for an iterator or string search (such as <code>find()</code>,
<code>position()</code>, or <code>rposition()</code>) followed by a call to <code>is_some()</code> or <code>is_none()</code>.</p>
<h3>Why is this bad?</h3>
<p>Readability, this can be written more concisely as:</p>
<ul>
<li><code>_.any(_)</code>, or <code>_.contains(_)</code> for <code>is_some()</code>,</li>
<li><code>!_.any(_)</code>, or <code>!_.contains(_)</code> for <code>is_none()</code>.</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">let vec = vec![1];
vec.iter().find(|x| **x == 0).is_some();

"hello world".find("world").is_none();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let vec = vec![1];
vec.iter().any(|x| *x == 0);

!"hello world".contains("world");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+search_is_some">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L865">View Source</a></div></div></div></article><article id="seek_from_current"><input id="label-seek_from_current" type="checkbox"><label for="label-seek_from_current"><h2 class="lint-title"><div class="panel-title-name" id="lint-seek_from_current">seek_from_current
<a href="#seek_from_current" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks if the <code>seek</code> method of the <code>Seek</code> trait is called with <code>SeekFrom::Current(0)</code>,
and if it is, suggests using <code>stream_position</code> instead.</p>
<h3>Why is this bad?</h3>
<p>Readability. Use dedicated method.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::fs::File;
use std::io::{self, Write, Seek, SeekFrom};

fn main() -&gt; io::Result&lt;()&gt; {
    let mut f = File::create("foo.txt")?;
    f.write_all(b"Hello")?;
    eprintln!("Written {} bytes", f.seek(SeekFrom::Current(0))?);

    Ok(())
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::{self, Write, Seek, SeekFrom};

fn main() -&gt; io::Result&lt;()&gt; {
    let mut f = File::create("foo.txt")?;
    f.write_all(b"Hello")?;
    eprintln!("Written {} bytes", f.stream_position()?);

    Ok(())
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.67.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+seek_from_current">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3270">View Source</a></div></div></div></article><article id="seek_to_start_instead_of_rewind"><input id="label-seek_to_start_instead_of_rewind" type="checkbox"><label for="label-seek_to_start_instead_of_rewind"><h2 class="lint-title"><div class="panel-title-name" id="lint-seek_to_start_instead_of_rewind">seek_to_start_instead_of_rewind
<a href="#seek_to_start_instead_of_rewind" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for jumps to the start of a stream that implements <code>Seek</code>
and uses the <code>seek</code> method providing <code>Start</code> as parameter.</p>
<h3>Why is this bad?</h3>
<p>Readability. There is a specific method that was implemented for
this exact scenario.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo&lt;T: io::Seek&gt;(t: &amp;mut T) {
    t.seek(io::SeekFrom::Start(0));
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo&lt;T: io::Seek&gt;(t: &amp;mut T) {
    t.rewind();
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.67.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+seek_to_start_instead_of_rewind">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3313">View Source</a></div></div></div></article><article id="self_assignment"><input id="label-self_assignment" type="checkbox"><label for="label-self_assignment"><h2 class="lint-title"><div class="panel-title-name" id="lint-self_assignment">self_assignment
<a href="#self_assignment" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for explicit self-assignments.</p>
<h3>Why is this bad?</h3>
<p>Self-assignments are redundant and unlikely to be
intentional.</p>
<h3>Known problems</h3>
<p>If expression contains any deref coercions or
indexing operations they are assumed not to have any side effects.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Event {
    x: i32,
}

fn copy_position(a: &amp;mut Event, b: &amp;Event) {
    a.x = a.x;
}
</code></pre>
<p>Should be:</p>
<pre><code class="language-rust">struct Event {
    x: i32,
}

fn copy_position(a: &amp;mut Event, b: &amp;Event) {
    a.x = b.x;
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.48.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+self_assignment">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L775">View Source</a></div></div></div></article><article id="self_named_constructors"><input id="label-self_named_constructors" type="checkbox"><label for="label-self_named_constructors"><h2 class="lint-title"><div class="panel-title-name" id="lint-self_named_constructors">self_named_constructors
<a href="#self_named_constructors" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns when constructors have the same name as their types.</p>
<h3>Why is this bad?</h3>
<p>Repeating the name of the type is redundant.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Foo {}

impl Foo {
    pub fn foo() -&gt; Foo {
        Foo {}
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct Foo {}

impl Foo {
    pub fn new() -&gt; Foo {
        Foo {}
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.55.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+self_named_constructors">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/self_named_constructors.rs#L8">View Source</a></div></div></div></article><article id="self_named_module_files"><input id="label-self_named_module_files" type="checkbox"><label for="label-self_named_module_files"><h2 class="lint-title"><div class="panel-title-name" id="lint-self_named_module_files">self_named_module_files
<a href="#self_named_module_files" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks that module layout uses only <code>mod.rs</code> files.</p>
<h3>Why restrict this?</h3>
<p>Having multiple module layout styles in a project can be confusing.</p>
<h3>Example</h3>
<pre><code class="language-text">src/
  stuff/
    stuff_files.rs
  stuff.rs
  lib.rs
</code></pre>
<p>Use instead:</p>
<pre><code class="language-text">src/
  stuff/
    stuff_files.rs
    mod.rs
  lib.rs
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.57.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+self_named_module_files">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/module_style.rs#L39">View Source</a></div></div></div></article><article id="self_only_used_in_recursion"><input id="label-self_only_used_in_recursion" type="checkbox"><label for="label-self_only_used_in_recursion"><h2 class="lint-title"><div class="panel-title-name" id="lint-self_only_used_in_recursion">self_only_used_in_recursion
<a href="#self_only_used_in_recursion" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>self</code> receiver that is only used in recursion with no side-effects.</p>
<h3>Why is this bad?</h3>
<p>It may be possible to remove the <code>self</code> argument, allowing the function to be
used without an object of type <code>Self</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Foo;
impl Foo {
    fn f(&amp;self, n: u32) -&gt; u32 {
        if n == 0 {
            1
        } else {
            n * self.f(n - 1)
        }
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct Foo;
impl Foo {
    fn f(n: u32) -&gt; u32 {
        if n == 0 {
            1
        } else {
            n * Self::f(n - 1)
        }
    }
}
</code></pre>
<h3>Known problems</h3>
<p>Too many code paths in the linting code are currently untested and prone to produce false
positives or are prone to have performance implications.</p>
<p>In some cases, this would not catch all useless arguments.</p>
<pre><code class="language-rust">struct Foo;
impl Foo {
    fn foo(&amp;self, a: usize) -&gt; usize {
        let f = |x| x;

        if a == 0 {
            1
        } else {
            f(self).foo(a)
        }
    }
}
</code></pre>
<p>For example, here <code>self</code> is only used in recursion, but the lint would not catch it.</p>
<p>List of some examples that can not be caught:</p>
<ul>
<li>binary operation of non-primitive types</li>
<li>closure usage</li>
<li>some <code>break</code> relative operations</li>
<li>struct pattern binding</li>
</ul>
<p>Also, when you recurse the function name with path segments, it is not possible to detect.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.92.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+self_only_used_in_recursion">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/only_used_in_recursion.rs#L90">View Source</a></div></div></div></article><article id="semicolon_if_nothing_returned"><input id="label-semicolon_if_nothing_returned" type="checkbox"><label for="label-semicolon_if_nothing_returned"><h2 class="lint-title"><div class="panel-title-name" id="lint-semicolon_if_nothing_returned">semicolon_if_nothing_returned
<a href="#semicolon_if_nothing_returned" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Looks for blocks of expressions and fires if the last expression returns
<code>()</code> but is not followed by a semicolon.</p>
<h3>Why is this bad?</h3>
<p>The semicolon might be optional but when extending the block with new
code, it doesn’t require a change in previous last line.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn main() {
    println!("Hello world")
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn main() {
    println!("Hello world");
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.52.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+semicolon_if_nothing_returned">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/semicolon_if_nothing_returned.rs#L9">View Source</a></div></div></div></article><article id="semicolon_inside_block"><input id="label-semicolon_inside_block" type="checkbox"><label for="label-semicolon_inside_block"><h2 class="lint-title"><div class="panel-title-name" id="lint-semicolon_inside_block">semicolon_inside_block
<a href="#semicolon_inside_block" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Suggests moving the semicolon after a block to the inside of the block, after its last
expression.</p>
<h3>Why restrict this?</h3>
<p>For consistency it’s best to have the semicolon inside/outside the block. Either way is fine
and this lint suggests inside the block.
Take a look at <code>semicolon_outside_block</code> for the other alternative.</p>
<h3>Example</h3>
<pre><code class="language-rust">unsafe { f(x) };
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">unsafe { f(x); }
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>semicolon-inside-block-ignore-singleline</code>:  Whether to lint only if it’s multiline.</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.68.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+semicolon_inside_block">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/semicolon_block.rs#L10">View Source</a></div></div></div></article><article id="semicolon_outside_block"><input id="label-semicolon_outside_block" type="checkbox"><label for="label-semicolon_outside_block"><h2 class="lint-title"><div class="panel-title-name" id="lint-semicolon_outside_block">semicolon_outside_block
<a href="#semicolon_outside_block" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Suggests moving the semicolon from a block’s final expression outside of the block.</p>
<h3>Why restrict this?</h3>
<p>For consistency it’s best to have the semicolon inside/outside the block. Either way is fine
and this lint suggests outside the block.
Take a look at <code>semicolon_inside_block</code> for the other alternative.</p>
<h3>Example</h3>
<pre><code class="language-rust">unsafe { f(x); }
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">unsafe { f(x) };
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>semicolon-outside-block-ignore-multiline</code>:  Whether to lint only if it’s singleline.</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.68.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+semicolon_outside_block">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/semicolon_block.rs#L39">View Source</a></div></div></div></article><article id="separated_literal_suffix"><input id="label-separated_literal_suffix" type="checkbox"><label for="label-separated_literal_suffix"><h2 class="lint-title"><div class="panel-title-name" id="lint-separated_literal_suffix">separated_literal_suffix
<a href="#separated_literal_suffix" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns if literal suffixes are separated by an underscore.
To enforce separated literal suffix style,
see the <code>unseparated_literal_suffix</code> lint.</p>
<h3>Why restrict this?</h3>
<p>Suffix style should be consistent.</p>
<h3>Example</h3>
<pre><code class="language-rust">123832_i32
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">123832i32
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.58.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+separated_literal_suffix">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/misc_early/mod.rs#L116">View Source</a></div></div></div></article><article id="serde_api_misuse"><input id="label-serde_api_misuse" type="checkbox"><label for="label-serde_api_misuse"><h2 class="lint-title"><div class="panel-title-name" id="lint-serde_api_misuse">serde_api_misuse
<a href="#serde_api_misuse" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for misuses of the serde API.</p>
<h3>Why is this bad?</h3>
<p>Serde is very finicky about how its API should be
used, but the type system can’t be used to enforce it (yet?).</p>
<h3>Example</h3>
<p>Implementing <code>Visitor::visit_string</code> but not
<code>Visitor::visit_str</code>.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+serde_api_misuse">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/serde_api.rs#L7">View Source</a></div></div></div></article><article id="set_contains_or_insert"><input id="label-set_contains_or_insert" type="checkbox"><label for="label-set_contains_or_insert"><h2 class="lint-title"><div class="panel-title-name" id="lint-set_contains_or_insert">set_contains_or_insert
<a href="#set_contains_or_insert" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>contains</code> to see if a value is not present
in a set like <code>HashSet</code> or <code>BTreeSet</code>, followed by an <code>insert</code>.</p>
<h3>Why is this bad?</h3>
<p>Using just <code>insert</code> and checking the returned <code>bool</code> is more efficient.</p>
<h3>Known problems</h3>
<p>In case the value that wants to be inserted is borrowed and also expensive or impossible
to clone. In such a scenario, the developer might want to check with <code>contains</code> before inserting,
to avoid the clone. In this case, it will report a false positive.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::collections::HashSet;
let mut set = HashSet::new();
let value = 5;
if !set.contains(&amp;value) {
    set.insert(value);
    println!("inserted {value:?}");
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::collections::HashSet;
let mut set = HashSet::new();
let value = 5;
if set.insert(&amp;value) {
    println!("inserted {value:?}");
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.81.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+set_contains_or_insert">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/set_contains_or_insert.rs#L13">View Source</a></div></div></div></article><article id="shadow_reuse"><input id="label-shadow_reuse" type="checkbox"><label for="label-shadow_reuse"><h2 class="lint-title"><div class="panel-title-name" id="lint-shadow_reuse">shadow_reuse
<a href="#shadow_reuse" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for bindings that shadow other bindings already in
scope, while reusing the original value.</p>
<h3>Why restrict this?</h3>
<p>Some argue that name shadowing like this hurts readability,
because a value may be bound to different things depending on position in
the code.</p>
<p>See also <code>shadow_same</code> and <code>shadow_unrelated</code> for other restrictions on shadowing.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = 2;
let x = x + 1;
</code></pre>
<p>use different variable name:</p>
<pre><code class="language-rust">let x = 2;
let y = x + 1;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+shadow_reuse">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/shadow.rs#L45">View Source</a></div></div></div></article><article id="shadow_same"><input id="label-shadow_same" type="checkbox"><label for="label-shadow_same"><h2 class="lint-title"><div class="panel-title-name" id="lint-shadow_same">shadow_same
<a href="#shadow_same" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for bindings that shadow other bindings already in
scope, while just changing reference level or mutability.</p>
<h3>Why restrict this?</h3>
<p>To require that what are formally distinct variables be given distinct names.</p>
<p>See also <code>shadow_reuse</code> and <code>shadow_unrelated</code> for other restrictions on shadowing.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = &amp;x;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let y = &amp;x; // use different variable name
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+shadow_same">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/shadow.rs#L18">View Source</a></div></div></div></article><article id="shadow_unrelated"><input id="label-shadow_unrelated" type="checkbox"><label for="label-shadow_unrelated"><h2 class="lint-title"><div class="panel-title-name" id="lint-shadow_unrelated">shadow_unrelated
<a href="#shadow_unrelated" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for bindings that shadow other bindings already in
scope, either without an initialization or with one that does not even use
the original value.</p>
<h3>Why restrict this?</h3>
<p>Shadowing a binding with a closely related one is part of idiomatic Rust,
but shadowing a binding by accident with an unrelated one may indicate a mistake.</p>
<p>Additionally, name shadowing in general can hurt readability, especially in
large code bases, because it is easy to lose track of the active binding at
any place in the code. If linting against all shadowing is desired, you may wish
to use the <code>shadow_same</code> and <code>shadow_reuse</code> lints as well.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = y;
let x = z; // shadows the earlier binding
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = y;
let w = z; // use different variable name
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+shadow_unrelated">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/shadow.rs#L73">View Source</a></div></div></div></article><article id="short_circuit_statement"><input id="label-short_circuit_statement" type="checkbox"><label for="label-short_circuit_statement"><h2 class="lint-title"><div class="panel-title-name" id="lint-short_circuit_statement">short_circuit_statement
<a href="#short_circuit_statement" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the use of short circuit boolean conditions as
a
statement.</p>
<h3>Why is this bad?</h3>
<p>Using a short circuit boolean condition as a statement
may hide the fact that the second part is executed or not depending on the
outcome of the first part.</p>
<h3>Example</h3>
<pre><code class="language-rust">f() &amp;&amp; g(); // We should write `if f() { g(); }`.
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+short_circuit_statement">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/misc.rs#L75">View Source</a></div></div></div></article><article id="should_assert_eq"><input id="label-should_assert_eq" type="checkbox"><label for="label-should_assert_eq"><h2 class="lint-title"><div class="panel-title-name" id="lint-should_assert_eq">should_assert_eq
<a href="#should_assert_eq" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p><code>assert!(a == b)</code> can now print the values the same way `assert_eq!(a, b) can.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+should_assert_eq">Related Issues</a></div></div></div></article><article id="should_implement_trait"><input id="label-should_implement_trait" type="checkbox"><label for="label-should_implement_trait"><h2 class="lint-title"><div class="panel-title-name" id="lint-should_implement_trait">should_implement_trait
<a href="#should_implement_trait" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for methods that should live in a trait
implementation of a <code>std</code> trait (see <a href="http://llogiq.github.io/2015/07/30/traits.html">llogiq’s blog
post</a> for further
information) instead of an inherent implementation.</p>
<h3>Why is this bad?</h3>
<p>Implementing the traits improve ergonomics for users of
the code, often with very little cost. Also people seeing a <code>mul(...)</code>
method
may expect <code>*</code> to work equally, so you should have good reason to disappoint
them.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct X;
impl X {
    fn add(&amp;self, other: &amp;X) -&gt; X {
        // ..
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+should_implement_trait">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L386">View Source</a></div></div></div></article><article id="should_panic_without_expect"><input id="label-should_panic_without_expect" type="checkbox"><label for="label-should_panic_without_expect"><h2 class="lint-title"><div class="panel-title-name" id="lint-should_panic_without_expect">should_panic_without_expect
<a href="#should_panic_without_expect" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>#[should_panic]</code> attributes without specifying the expected panic message.</p>
<h3>Why is this bad?</h3>
<p>The expected panic message should be specified to ensure that the test is actually
panicking with the expected message, and not another unrelated panic.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn random() -&gt; i32 { 0 }

#[should_panic]
#[test]
fn my_test() {
    let _ = 1 / random();
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn random() -&gt; i32 { 0 }

#[should_panic = "attempt to divide by zero"]
#[test]
fn my_test() {
    let _ = 1 / random();
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.74.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+should_panic_without_expect">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/attrs/mod.rs#L242">View Source</a></div></div></div></article><article id="significant_drop_in_scrutinee"><input id="label-significant_drop_in_scrutinee" type="checkbox"><label for="label-significant_drop_in_scrutinee"><h2 class="lint-title"><div class="panel-title-name" id="lint-significant_drop_in_scrutinee">significant_drop_in_scrutinee
<a href="#significant_drop_in_scrutinee" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for temporaries returned from function calls in a match scrutinee that have the
<code>clippy::has_significant_drop</code> attribute.</p>
<h3>Why is this bad?</h3>
<p>The <code>clippy::has_significant_drop</code> attribute can be added to types whose Drop impls have
an important side-effect, such as unlocking a mutex, making it important for users to be
able to accurately understand their lifetimes. When a temporary is returned in a function
call in a match scrutinee, its lifetime lasts until the end of the match block, which may
be surprising.</p>
<p>For <code>Mutex</code>es this can lead to a deadlock. This happens when the match scrutinee uses a
function call that returns a <code>MutexGuard</code> and then tries to lock again in one of the match
arms. In that case the <code>MutexGuard</code> in the scrutinee will not be dropped until the end of
the match block and thus will not unlock.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mutex = Mutex::new(State {});

match mutex.lock().unwrap().foo() {
    true =&gt; {
        mutex.lock().unwrap().bar(); // Deadlock!
    }
    false =&gt; {}
};

println!("All done!");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mutex = Mutex::new(State {});

let is_foo = mutex.lock().unwrap().foo();
match is_foo {
    true =&gt; {
        mutex.lock().unwrap().bar();
    }
    false =&gt; {}
};

println!("All done!");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.60.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+significant_drop_in_scrutinee">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L792">View Source</a></div></div></div></article><article id="significant_drop_tightening"><input id="label-significant_drop_tightening" type="checkbox"><label for="label-significant_drop_tightening"><h2 class="lint-title"><div class="panel-title-name" id="lint-significant_drop_tightening">significant_drop_tightening
<a href="#significant_drop_tightening" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Searches for elements marked with <code>#[clippy::has_significant_drop]</code> that could be early
dropped but are in fact dropped at the end of their scopes. In other words, enforces the
“tightening” of their possible lifetimes.</p>
<h3>Why is this bad?</h3>
<p>Elements marked with <code>#[clippy::has_significant_drop]</code> are generally synchronizing
primitives that manage shared resources, as such, it is desired to release them as soon as
possible to avoid unnecessary resource contention.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn main() {
  let lock = some_sync_resource.lock();
  let owned_rslt = lock.do_stuff_with_resource();
  // Only `owned_rslt` is needed but `lock` is still held.
  do_heavy_computation_that_takes_time(owned_rslt);
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn main() {
    let owned_rslt = some_sync_resource.lock().do_stuff_with_resource();
    do_heavy_computation_that_takes_time(owned_rslt);
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.69.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+significant_drop_tightening">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/significant_drop_tightening.rs#L18">View Source</a></div></div></div></article><article id="similar_names"><input id="label-similar_names" type="checkbox"><label for="label-similar_names"><h2 class="lint-title"><div class="panel-title-name" id="lint-similar_names">similar_names
<a href="#similar_names" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for names that are very similar and thus confusing.</p>
<p>Note: this lint looks for similar names throughout each
scope. To allow it, you need to allow it on the scope
level, not on the name that is reported.</p>
<h3>Why is this bad?</h3>
<p>It’s hard to distinguish between names that differ only
by a single character.</p>
<h3>Example</h3>
<pre><code class="language-rust">let checked_exp = something;
let checked_expr = something_else;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+similar_names">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/non_expressive_names.rs#L13">View Source</a></div></div></div></article><article id="single_call_fn"><input id="label-single_call_fn" type="checkbox"><label for="label-single_call_fn"><h2 class="lint-title"><div class="panel-title-name" id="lint-single_call_fn">single_call_fn
<a href="#single_call_fn" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for functions that are only used once. Does not lint tests.</p>
<h3>Why restrict this?</h3>
<p>If a function is only used once (perhaps because it used to be used more widely),
then the code could be simplified by moving that function’s code into its caller.</p>
<p>However, there are reasons not to do this everywhere:</p>
<ul>
<li>Splitting a large function into multiple parts often improves readability
by giving names to its parts.</li>
<li>A function’s signature might serve a necessary purpose, such as constraining
the type of a closure passed to it.</li>
<li>Generic functions might call non-generic functions to reduce duplication
in the produced machine code.</li>
</ul>
<p>If this lint is used, prepare to <code>#[allow]</code> it a lot.</p>
<h3>Example</h3>
<pre><code class="language-rust">pub fn a&lt;T&gt;(t: &amp;T)
where
    T: AsRef&lt;str&gt;,
{
    a_inner(t.as_ref())
}

fn a_inner(t: &amp;str) {
    /* snip */
}

</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">pub fn a&lt;T&gt;(t: &amp;T)
where
    T: AsRef&lt;str&gt;,
{
    let t = t.as_ref();
    /* snip */
}

</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+single_call_fn">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/single_call_fn.rs#L12">View Source</a></div></div></div></article><article id="single_char_add_str"><input id="label-single_char_add_str" type="checkbox"><label for="label-single_char_add_str"><h2 class="lint-title"><div class="panel-title-name" id="lint-single_char_add_str">single_char_add_str
<a href="#single_char_add_str" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns when using <code>push_str</code>/<code>insert_str</code> with a single-character string literal
where <code>push</code>/<code>insert</code> with a <code>char</code> would work fine.</p>
<h3>Why is this bad?</h3>
<p>It’s less clear that we are pushing a single character.</p>
<h3>Example</h3>
<pre><code class="language-rust">string.insert_str(0, "R");
string.push_str("R");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">string.insert(0, 'R');
string.push('R');
</code></pre>
<h3>Past names</h3>
<ul>
<li>single_char_push_str</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+single_char_add_str">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1898">View Source</a></div></div></div></article><article id="single_char_lifetime_names"><input id="label-single_char_lifetime_names" type="checkbox"><label for="label-single_char_lifetime_names"><h2 class="lint-title"><div class="panel-title-name" id="lint-single_char_lifetime_names">single_char_lifetime_names
<a href="#single_char_lifetime_names" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for lifetimes with names which are one character
long.</p>
<h3>Why restrict this?</h3>
<p>A single character is likely not enough to express the
purpose of a lifetime. Using a longer name can make code
easier to understand.</p>
<h3>Known problems</h3>
<p>Rust programmers and learning resources tend to use single
character lifetimes, so this lint is at odds with the
ecosystem at large. In addition, the lifetime’s purpose may
be obvious or, rarely, expressible in one character.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct DiagnosticCtx&lt;'a&gt; {
    source: &amp;'a str,
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct DiagnosticCtx&lt;'src&gt; {
    source: &amp;'src str,
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.60.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+single_char_lifetime_names">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/single_char_lifetime_names.rs#L6">View Source</a></div></div></div></article><article id="single_char_pattern"><input id="label-single_char_pattern" type="checkbox"><label for="label-single_char_pattern"><h2 class="lint-title"><div class="panel-title-name" id="lint-single_char_pattern">single_char_pattern
<a href="#single_char_pattern" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for string methods that receive a single-character
<code>str</code> as an argument, e.g., <code>_.split("x")</code>.</p>
<h3>Why is this bad?</h3>
<p>While this can make a perf difference on some systems,
benchmarks have proven inconclusive. But at least using a
char literal makes it clear that we are looking at a single
character.</p>
<h3>Known problems</h3>
<p>Does not catch multi-byte unicode characters. This is by
design, on many machines, splitting by a non-ascii char is
actually slower. Please do your own measurements instead of
relying solely on the results of this lint.</p>
<h3>Example</h3>
<pre><code class="language-rust">_.split("x");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">_.split('x');
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+single_char_pattern">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/string_patterns.rs#L43">View Source</a></div></div></div></article><article id="single_component_path_imports"><input id="label-single_component_path_imports" type="checkbox"><label for="label-single_component_path_imports"><h2 class="lint-title"><div class="panel-title-name" id="lint-single_component_path_imports">single_component_path_imports
<a href="#single_component_path_imports" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checking for imports with single component use path.</p>
<h3>Why is this bad?</h3>
<p>Import with single component use path such as <code>use cratename;</code>
is not necessary, and thus should be removed.</p>
<h3>Example</h3>
<pre><code class="language-rust">use regex;

fn main() {
    regex::Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
}
</code></pre>
<p>Better as</p>
<pre><code class="language-rust">fn main() {
    regex::Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.43.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+single_component_path_imports">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/single_component_path_imports.rs#L12">View Source</a></div></div></div></article><article id="single_element_loop"><input id="label-single_element_loop" type="checkbox"><label for="label-single_element_loop"><h2 class="lint-title"><div class="panel-title-name" id="lint-single_element_loop">single_element_loop
<a href="#single_element_loop" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks whether a for loop has a single element.</p>
<h3>Why is this bad?</h3>
<p>There is no reason to have a loop of a
single element.</p>
<h3>Example</h3>
<pre><code class="language-rust">let item1 = 2;
for item in &amp;[item1] {
    println!("{}", item);
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let item1 = 2;
let item = &amp;item1;
println!("{}", item);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+single_element_loop">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L494">View Source</a></div></div></div></article><article id="single_match"><input id="label-single_match" type="checkbox"><label for="label-single_match"><h2 class="lint-title"><div class="panel-title-name" id="lint-single_match">single_match
<a href="#single_match" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for matches with a single arm where an <code>if let</code>
will usually suffice.</p>
<p>This intentionally does not lint if there are comments
inside of the other arm, so as to allow the user to document
why having another explicit pattern with an empty body is necessary,
or because the comments need to be preserved for other reasons.</p>
<h3>Why is this bad?</h3>
<p>Just readability – <code>if let</code> nests less than a <code>match</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">match x {
    Some(ref foo) =&gt; bar(foo),
    _ =&gt; (),
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if let Some(ref foo) = x {
    bar(foo);
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+single_match">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L38">View Source</a></div></div></div></article><article id="single_match_else"><input id="label-single_match_else" type="checkbox"><label for="label-single_match_else"><h2 class="lint-title"><div class="panel-title-name" id="lint-single_match_else">single_match_else
<a href="#single_match_else" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for matches with two arms where an <code>if let else</code> will
usually suffice.</p>
<h3>Why is this bad?</h3>
<p>Just readability – <code>if let</code> nests less than a <code>match</code>.</p>
<h3>Known problems</h3>
<p>Personal style preferences may differ.</p>
<h3>Example</h3>
<p>Using <code>match</code>:</p>
<pre><code class="language-rust">match x {
    Some(ref foo) =&gt; bar(foo),
    _ =&gt; bar(&amp;other_ref),
}
</code></pre>
<p>Using <code>if let</code> with <code>else</code>:</p>
<pre><code class="language-rust">if let Some(ref foo) = x {
    bar(foo);
} else {
    bar(&amp;other_ref);
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+single_match_else">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L75">View Source</a></div></div></div></article><article id="single_option_map"><input id="label-single_option_map" type="checkbox"><label for="label-single_option_map"><h2 class="lint-title"><div class="panel-title-name" id="lint-single_option_map">single_option_map
<a href="#single_option_map" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for functions with method calls to <code>.map(_)</code> on an arg
of type <code>Option</code> as the outermost expression.</p>
<h3>Why is this bad?</h3>
<p>Taking and returning an <code>Option&lt;T&gt;</code> may require additional
<code>Some(_)</code> and <code>unwrap</code> if all you have is a <code>T</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn double(param: Option&lt;u32&gt;) -&gt; Option&lt;u32&gt; {
    param.map(|x| x * 2)
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn double(param: u32) -&gt; u32 {
    param * 2
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.87.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+single_option_map">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/single_option_map.rs#L12">View Source</a></div></div></div></article><article id="single_range_in_vec_init"><input id="label-single_range_in_vec_init" type="checkbox"><label for="label-single_range_in_vec_init"><h2 class="lint-title"><div class="panel-title-name" id="lint-single_range_in_vec_init">single_range_in_vec_init
<a href="#single_range_in_vec_init" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>Vec</code> or array initializations that contain only one range.</p>
<h3>Why is this bad?</h3>
<p>This is almost always incorrect, as it will result in a <code>Vec</code> that has only one element.
Almost always, the programmer intended for it to include all elements in the range or for
the end of the range to be the length instead.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = [0..200];
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// If it was intended to include every element in the range...
let x = (0..200).collect::&lt;Vec&lt;i32&gt;&gt;();
// ...Or if 200 was meant to be the len
let x = [0; 200];
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+single_range_in_vec_init">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/single_range_in_vec_init.rs#L15">View Source</a></div></div></div></article><article id="size_of_in_element_count"><input id="label-size_of_in_element_count" type="checkbox"><label for="label-size_of_in_element_count"><h2 class="lint-title"><div class="panel-title-name" id="lint-size_of_in_element_count">size_of_in_element_count
<a href="#size_of_in_element_count" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects expressions where
<code>size_of::&lt;T&gt;</code> or <code>size_of_val::&lt;T&gt;</code> is used as a
count of elements of type <code>T</code></p>
<h3>Why is this bad?</h3>
<p>These functions expect a count
of <code>T</code> and not a number of bytes</p>
<h3>Example</h3>
<pre><code class="language-rust">const SIZE: usize = 128;
let x = [2u8; SIZE];
let mut y = [2u8; SIZE];
unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::&lt;u8&gt;() * SIZE) };
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.50.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+size_of_in_element_count">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/size_of_in_element_count.rs#L9">View Source</a></div></div></div></article><article id="size_of_ref"><input id="label-size_of_ref" type="checkbox"><label for="label-size_of_ref"><h2 class="lint-title"><div class="panel-title-name" id="lint-size_of_ref">size_of_ref
<a href="#size_of_ref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>size_of_val()</code> where the argument is
a reference to a reference.</p>
<h3>Why is this bad?</h3>
<p>Calling <code>size_of_val()</code> with a reference to a reference as the argument
yields the size of the reference-type, not the size of the value behind
the reference.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Foo {
    buffer: [u8],
}

impl Foo {
    fn size(&amp;self) -&gt; usize {
        // Note that `&amp;self` as an argument is a `&amp;&amp;Foo`: Because `self`
        // is already a reference, `&amp;self` is a double-reference.
        // The return value of `size_of_val()` therefore is the
        // size of the reference-type, not the size of `self`.
        size_of_val(&amp;self)
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct Foo {
    buffer: [u8],
}

impl Foo {
    fn size(&amp;self) -&gt; usize {
        // Correct
        size_of_val(self)
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.68.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+size_of_ref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/size_of_ref.rs#L9">View Source</a></div></div></div></article><article id="skip_while_next"><input id="label-skip_while_next" type="checkbox"><label for="label-skip_while_next"><h2 class="lint-title"><div class="panel-title-name" id="lint-skip_while_next">skip_while_next
<a href="#skip_while_next" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>_.skip_while(condition).next()</code>.</p>
<h3>Why is this bad?</h3>
<p>Readability, this can be written more concisely as
<code>_.find(!condition)</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">vec.iter().skip_while(|x| **x == 0).next();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">vec.iter().find(|x| **x != 0);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.42.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+skip_while_next">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L712">View Source</a></div></div></div></article><article id="sliced_string_as_bytes"><input id="label-sliced_string_as_bytes" type="checkbox"><label for="label-sliced_string_as_bytes"><h2 class="lint-title"><div class="panel-title-name" id="lint-sliced_string_as_bytes">sliced_string_as_bytes
<a href="#sliced_string_as_bytes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for string slices immediately followed by <code>as_bytes</code>.</p>
<h3>Why is this bad?</h3>
<p>It involves doing an unnecessary UTF-8 alignment check which is less efficient, and can cause a panic.</p>
<h3>Known problems</h3>
<p>In some cases, the UTF-8 validation and potential panic from string slicing may be required for
the code’s correctness. If you need to ensure the slice boundaries fall on valid UTF-8 character
boundaries, the original form (<code>s[1..5].as_bytes()</code>) should be preferred.</p>
<h3>Example</h3>
<pre><code class="language-rust">let s = "Lorem ipsum";
s[1..5].as_bytes();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let s = "Lorem ipsum";
&amp;s.as_bytes()[1..5];
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.86.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+sliced_string_as_bytes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4430">View Source</a></div></div></div></article><article id="slow_vector_initialization"><input id="label-slow_vector_initialization" type="checkbox"><label for="label-slow_vector_initialization"><h2 class="lint-title"><div class="panel-title-name" id="lint-slow_vector_initialization">slow_vector_initialization
<a href="#slow_vector_initialization" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks slow zero-filled vector initialization</p>
<h3>Why is this bad?</h3>
<p>These structures are non-idiomatic and less efficient than simply using
<code>vec![0; len]</code>.</p>
<p>Specifically, for <code>vec![0; len]</code>, the compiler can use a specialized type of allocation
that also zero-initializes the allocated memory in the same call
(see: <a href="https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html#method.alloc_zeroed">alloc_zeroed</a>).</p>
<p>Writing <code>Vec::new()</code> followed by <code>vec.resize(len, 0)</code> is suboptimal because,
while it does do the same number of allocations,
it involves two operations for allocating and initializing.
The <code>resize</code> call first allocates memory (since <code>Vec::new()</code> did not), and only <em>then</em> zero-initializes it.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut vec1 = Vec::new();
vec1.resize(len, 0);

let mut vec2 = Vec::with_capacity(len);
vec2.resize(len, 0);

let mut vec3 = Vec::with_capacity(len);
vec3.extend(repeat(0).take(len));
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut vec1 = vec![0; len];
let mut vec2 = vec![0; len];
let mut vec3 = vec![0; len];
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.32.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+slow_vector_initialization">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/slow_vector_initialization.rs#L12">View Source</a></div></div></div></article><article id="stable_sort_primitive"><input id="label-stable_sort_primitive" type="checkbox"><label for="label-stable_sort_primitive"><h2 class="lint-title"><div class="panel-title-name" id="lint-stable_sort_primitive">stable_sort_primitive
<a href="#stable_sort_primitive" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>When sorting primitive values (integers, bools, chars, as well
as arrays, slices, and tuples of such items), it is typically better to
use an unstable sort than a stable sort.</p>
<h3>Why is this bad?</h3>
<p>Typically, using a stable sort consumes more memory and cpu cycles.
Because values which compare equal are identical, preserving their
relative order (the guarantee that a stable sort provides) means
nothing, while the extra costs still apply.</p>
<h3>Known problems</h3>
<p>As pointed out in
<a href="https://github.com/rust-lang/rust-clippy/issues/8241">issue #8241</a>,
a stable sort can instead be significantly faster for certain scenarios
(eg. when a sorted vector is extended with new data and resorted).</p>
<p>For more information and benchmarking results, please refer to the
issue linked above.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut vec = vec![2, 1, 3];
vec.sort();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut vec = vec![2, 1, 3];
vec.sort_unstable();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.47.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+stable_sort_primitive">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3039">View Source</a></div></div></div></article><article id="std_instead_of_alloc"><input id="label-std_instead_of_alloc" type="checkbox"><label for="label-std_instead_of_alloc"><h2 class="lint-title"><div class="panel-title-name" id="lint-std_instead_of_alloc">std_instead_of_alloc
<a href="#std_instead_of_alloc" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Finds items imported through <code>std</code> when available through <code>alloc</code>.</p>
<h3>Why restrict this?</h3>
<p>Crates which have <code>no_std</code> compatibility and require alloc may wish to ensure types are imported from
alloc to ensure disabling <code>std</code> does not cause the crate to fail to compile. This lint is also useful
for crates migrating to become <code>no_std</code> compatible.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::vec::Vec;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use alloc::vec::Vec;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.64.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+std_instead_of_alloc">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/std_instead_of_core.rs#L37">View Source</a></div></div></div></article><article id="std_instead_of_core"><input id="label-std_instead_of_core" type="checkbox"><label for="label-std_instead_of_core"><h2 class="lint-title"><div class="panel-title-name" id="lint-std_instead_of_core">std_instead_of_core
<a href="#std_instead_of_core" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Finds items imported through <code>std</code> when available through <code>core</code>.</p>
<h3>Why restrict this?</h3>
<p>Crates which have <code>no_std</code> compatibility may wish to ensure types are imported from core to ensure
disabling <code>std</code> does not cause the crate to fail to compile. This lint is also useful for crates
migrating to become <code>no_std</code> compatible.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::hash::Hasher;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use core::hash::Hasher;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.64.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+std_instead_of_core">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/std_instead_of_core.rs#L14">View Source</a></div></div></div></article><article id="str_split_at_newline"><input id="label-str_split_at_newline" type="checkbox"><label for="label-str_split_at_newline"><h2 class="lint-title"><div class="panel-title-name" id="lint-str_split_at_newline">str_split_at_newline
<a href="#str_split_at_newline" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usages of <code>str.trim().split("\n")</code> and <code>str.trim().split("\r\n")</code>.</p>
<h3>Why is this bad?</h3>
<p>Hard-coding the line endings makes the code less compatible. <code>str.lines</code> should be used instead.</p>
<h3>Example</h3>
<pre><code class="language-rust">"some\ntext\nwith\nnewlines\n".trim().split('\n');
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">"some\ntext\nwith\nnewlines\n".lines();
</code></pre>
<h3>Known Problems</h3>
<p>This lint cannot detect if the split is intentionally restricted to a single type of newline (<code>"\n"</code> or
<code>"\r\n"</code>), for example during the parsing of a specific file format in which precisely one newline type is
valid.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.77.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+str_split_at_newline">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3972">View Source</a></div></div></div></article><article id="str_to_string"><input id="label-str_to_string" type="checkbox"><label for="label-str_to_string"><h2 class="lint-title"><div class="panel-title-name" id="lint-str_to_string">str_to_string
<a href="#str_to_string" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint checks for <code>.to_string()</code> method calls on values of type <code>&amp;str</code>.</p>
<h3>Why restrict this?</h3>
<p>The <code>to_string</code> method is also used on other types to convert them to a string.
When called on a <code>&amp;str</code> it turns the <code>&amp;str</code> into the owned variant <code>String</code>, which can be
more specifically expressed with <code>.to_owned()</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = "str".to_string();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = "str".to_owned();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+str_to_string">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/strings.rs#L364">View Source</a></div></div></div></article><article id="string_add"><input id="label-string_add" type="checkbox"><label for="label-string_add"><h2 class="lint-title"><div class="panel-title-name" id="lint-string_add">string_add
<a href="#string_add" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for all instances of <code>x + _</code> where <code>x</code> is of type
<code>String</code>, but only if <a href="#string_add_assign"><code>string_add_assign</code></a> does <em>not</em>
match.</p>
<h3>Why restrict this?</h3>
<p>This particular
<code>Add</code> implementation is asymmetric (the other operand need not be <code>String</code>,
but <code>x</code> does), while addition as mathematically defined is symmetric, and
the <code>String::push_str(_)</code> function is a perfectly good replacement.
Therefore, some dislike it and wish not to have it in their code.</p>
<p>That said, other people think that string addition, having a long tradition
in other languages is actually fine, which is why we decided to make this
particular lint <code>allow</code> by default.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = "Hello".to_owned();
x + ", World";
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut x = "Hello".to_owned();
x.push_str(", World");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+string_add">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/strings.rs#L39">View Source</a></div></div></div></article><article id="string_add_assign"><input id="label-string_add_assign" type="checkbox"><label for="label-string_add_assign"><h2 class="lint-title"><div class="panel-title-name" id="lint-string_add_assign">string_add_assign
<a href="#string_add_assign" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for string appends of the form <code>x = x + y</code> (without
<code>let</code>!).</p>
<h3>Why is this bad?</h3>
<p>It’s not really bad, but some people think that the
<code>.push_str(_)</code> method is more readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut x = "Hello".to_owned();
x = x + ", World";

// More readable
x += ", World";
x.push_str(", World");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+string_add_assign">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/strings.rs#L15">View Source</a></div></div></div></article><article id="string_extend_chars"><input id="label-string_extend_chars" type="checkbox"><label for="label-string_extend_chars"><h2 class="lint-title"><div class="panel-title-name" id="lint-string_extend_chars">string_extend_chars
<a href="#string_extend_chars" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the use of <code>.extend(s.chars())</code> where s is a
<code>&amp;str</code> or <code>String</code>.</p>
<h3>Why is this bad?</h3>
<p><code>.push_str(s)</code> is clearer</p>
<h3>Example</h3>
<pre><code class="language-rust">let abc = "abc";
let def = String::from("def");
let mut s = String::new();
s.extend(abc.chars());
s.extend(def.chars());
</code></pre>
<p>The correct use would be:</p>
<pre><code class="language-rust">let abc = "abc";
let def = String::from("def");
let mut s = String::new();
s.push_str(abc);
s.push_str(&amp;def);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+string_extend_chars">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1413">View Source</a></div></div></div></article><article id="string_from_utf8_as_bytes"><input id="label-string_from_utf8_as_bytes" type="checkbox"><label for="label-string_from_utf8_as_bytes"><h2 class="lint-title"><div class="panel-title-name" id="lint-string_from_utf8_as_bytes">string_from_utf8_as_bytes
<a href="#string_from_utf8_as_bytes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Check if the string is transformed to byte array and casted back to string.</p>
<h3>Why is this bad?</h3>
<p>It’s unnecessary, the string can be used directly.</p>
<h3>Example</h3>
<pre><code class="language-rust">std::str::from_utf8(&amp;"Hello World!".as_bytes()[6..11]).unwrap();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">&amp;"Hello World!"[6..11];
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.50.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+string_from_utf8_as_bytes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/strings.rs#L224">View Source</a></div></div></div></article><article id="string_lit_as_bytes"><input id="label-string_lit_as_bytes" type="checkbox"><label for="label-string_lit_as_bytes"><h2 class="lint-title"><div class="panel-title-name" id="lint-string_lit_as_bytes">string_lit_as_bytes
<a href="#string_lit_as_bytes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the <code>as_bytes</code> method called on string literals
that contain only ASCII characters.</p>
<h3>Why is this bad?</h3>
<p>Byte string literals (e.g., <code>b"foo"</code>) can be used
instead. They are shorter but less discoverable than <code>as_bytes()</code>.</p>
<h3>Known problems</h3>
<p><code>"str".as_bytes()</code> and the suggested replacement of <code>b"str"</code> are not
equivalent because they have different types. The former is <code>&amp;[u8]</code>
while the latter is <code>&amp;[u8; 3]</code>. That means in general they will have a
different set of methods and different trait implementations.</p>
<pre><code class="language-rust">fn f(v: Vec&lt;u8&gt;) {}

f("...".as_bytes().to_owned()); // works
f(b"...".to_owned()); // does not work, because arg is [u8; 3] not Vec&lt;u8&gt;

fn g(r: impl std::io::Read) {}

g("...".as_bytes()); // works
g(b"..."); // does not work
</code></pre>
<p>The actual equivalent of <code>"str".as_bytes()</code> with the same type is not
<code>b"str"</code> but <code>&amp;b"str"[..]</code>, which is a great deal of punctuation and not
more readable than a function call.</p>
<h3>Example</h3>
<pre><code class="language-rust">let bstr = "a byte string".as_bytes();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let bstr = b"a byte string";
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+string_lit_as_bytes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/strings.rs#L73">View Source</a></div></div></div></article><article id="string_lit_chars_any"><input id="label-string_lit_chars_any" type="checkbox"><label for="label-string_lit_chars_any"><h2 class="lint-title"><div class="panel-title-name" id="lint-string_lit_chars_any">string_lit_chars_any
<a href="#string_lit_chars_any" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>&lt;string_lit&gt;.chars().any(|i| i == c)</code>.</p>
<h3>Why is this bad?</h3>
<p>It’s significantly slower than using a pattern instead, like
<code>matches!(c, '\\' | '.' | '+')</code>.</p>
<p>Despite this being faster, this is not <code>perf</code> as this is pretty common, and is a rather nice
way to check if a <code>char</code> is any in a set. In any case, this <code>restriction</code> lint is available
for situations where that additional performance is absolutely necessary.</p>
<h3>Example</h3>
<pre><code class="language-rust">"\\.+*?()|[]{}^$#&amp;-~".chars().any(|x| x == c);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">matches!(c, '\\' | '.' | '+' | '*' | '(' | ')' | '|' | '[' | ']' | '{' | '}' | '^' | '$' | '#' | '&amp;' | '-' | '~');
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+string_lit_chars_any">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3539">View Source</a></div></div></div></article><article id="string_slice"><input id="label-string_slice" type="checkbox"><label for="label-string_slice"><h2 class="lint-title"><div class="panel-title-name" id="lint-string_slice">string_slice
<a href="#string_slice" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for slice operations on strings</p>
<h3>Why restrict this?</h3>
<p>UTF-8 characters span multiple bytes, and it is easy to inadvertently confuse character
counts and string indices. This may lead to panics, and should warrant some test cases
containing wide UTF-8 characters. This lint is most useful in code that should avoid
panics at all costs.</p>
<h3>Known problems</h3>
<p>Probably lots of false positives. If an index comes from a known valid position (e.g.
obtained via <code>char_indices</code> over the same string), it is totally OK.</p>
<h3>Example</h3>
<pre><code class="language-rust">&amp;"Ölkanne"[1..];
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.58.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+string_slice">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/strings.rs#L119">View Source</a></div></div></div></article><article id="string_to_string"><input id="label-string_to_string" type="checkbox"><label for="label-string_to_string"><h2 class="lint-title"><div class="panel-title-name" id="lint-string_to_string">string_to_string
<a href="#string_to_string" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p><code>clippy::implicit_clone</code> covers those cases.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">1.91.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+string_to_string">Related Issues</a></div></div></div></article><article id="strlen_on_c_strings"><input id="label-strlen_on_c_strings" type="checkbox"><label for="label-strlen_on_c_strings"><h2 class="lint-title"><div class="panel-title-name" id="lint-strlen_on_c_strings">strlen_on_c_strings
<a href="#strlen_on_c_strings" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>libc::strlen</code> on a <code>CString</code> or <code>CStr</code> value,
and suggest calling <code>as_bytes().len()</code> or <code>to_bytes().len()</code> respectively instead.</p>
<h3>Why is this bad?</h3>
<p>libc::strlen is an unsafe function, which we don’t need to call
if all we want to know is the length of the c-string.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::ffi::CString;
let cstring = CString::new("foo").expect("CString::new failed");
let len = unsafe { libc::strlen(cstring.as_ptr()) };
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::ffi::CString;
let cstring = CString::new("foo").expect("CString::new failed");
let len = cstring.as_bytes().len();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.55.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+strlen_on_c_strings">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/strlen_on_c_strings.rs#L11">View Source</a></div></div></div></article><article id="struct_excessive_bools"><input id="label-struct_excessive_bools" type="checkbox"><label for="label-struct_excessive_bools"><h2 class="lint-title"><div class="panel-title-name" id="lint-struct_excessive_bools">struct_excessive_bools
<a href="#struct_excessive_bools" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for excessive
use of bools in structs.</p>
<h3>Why is this bad?</h3>
<p>Excessive bools in a struct is often a sign that
the type is being used to represent a state
machine, which is much better implemented as an
enum.</p>
<p>The reason an enum is better for state machines
over structs is that enums more easily forbid
invalid states.</p>
<p>Structs with too many booleans may benefit from refactoring
into multi variant enums for better readability and API.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct S {
    is_pending: bool,
    is_processing: bool,
    is_finished: bool,
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">enum S {
    Pending,
    Processing,
    Finished,
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>max-struct-bools</code>:  The maximum number of bool fields a struct can have</p>
<p>(default: <code>3</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.43.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+struct_excessive_bools">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/excessive_bools.rs#L12">View Source</a></div></div></div></article><article id="struct_field_names"><input id="label-struct_field_names" type="checkbox"><label for="label-struct_field_names"><h2 class="lint-title"><div class="panel-title-name" id="lint-struct_field_names">struct_field_names
<a href="#struct_field_names" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects struct fields that are prefixed or suffixed
by the same characters or the name of the struct itself.</p>
<h3>Why is this bad?</h3>
<p>Information common to all struct fields is better represented in the struct name.</p>
<h3>Limitations</h3>
<p>Characters with no casing will be considered when comparing prefixes/suffixes
This applies to numbers and non-ascii characters without casing
e.g. <code>foo1</code> and <code>foo2</code> is considered to have different prefixes
(the prefixes are <code>foo1</code> and <code>foo2</code> respectively), as also <code>bar螃</code>, <code>bar蟹</code></p>
<h3>Example</h3>
<pre><code class="language-rust">struct Cake {
    cake_sugar: u8,
    cake_flour: u8,
    cake_eggs: u8
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct Cake {
    sugar: u8,
    flour: u8,
    eggs: u8
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>struct-field-name-threshold</code>:  The minimum number of struct fields for the lints about field names to trigger</p>
<p>(default: <code>3</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.75.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+struct_field_names">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/item_name_repetitions.rs#L122">View Source</a></div></div></div></article><article id="suboptimal_flops"><input id="label-suboptimal_flops" type="checkbox"><label for="label-suboptimal_flops"><h2 class="lint-title"><div class="panel-title-name" id="lint-suboptimal_flops">suboptimal_flops
<a href="#suboptimal_flops" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Looks for floating-point expressions that
can be expressed using built-in methods to improve both
accuracy and performance.</p>
<h3>Why is this bad?</h3>
<p>Negatively impacts accuracy and performance.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::f32::consts::E;

let a = 3f32;
let _ = (2f32).powf(a);
let _ = E.powf(a);
let _ = a.powf(1.0 / 2.0);
let _ = a.log(2.0);
let _ = a.log(10.0);
let _ = a.log(E);
let _ = a.powf(2.0);
let _ = a * 2.0 + 4.0;
let _ = if a &lt; 0.0 {
    -a
} else {
    a
};
let _ = if a &lt; 0.0 {
    a
} else {
    -a
};
</code></pre>
<p>is better expressed as</p>
<pre><code class="language-rust">use std::f32::consts::E;

let a = 3f32;
let _ = a.exp2();
let _ = a.exp();
let _ = a.sqrt();
let _ = a.log2();
let _ = a.log10();
let _ = a.ln();
let _ = a.powi(2);
let _ = a.mul_add(2.0, 4.0);
let _ = a.abs();
let _ = -a.abs();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.43.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+suboptimal_flops">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/floating_point_arithmetic/mod.rs#L49">View Source</a></div></div></div></article><article id="suspicious_arithmetic_impl"><input id="label-suspicious_arithmetic_impl" type="checkbox"><label for="label-suspicious_arithmetic_impl"><h2 class="lint-title"><div class="panel-title-name" id="lint-suspicious_arithmetic_impl">suspicious_arithmetic_impl
<a href="#suspicious_arithmetic_impl" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Lints for suspicious operations in impls of arithmetic operators, e.g.
subtracting elements in an Add impl.</p>
<h3>Why is this bad?</h3>
<p>This is probably a typo or copy-and-paste error and not intended.</p>
<h3>Example</h3>
<pre><code class="language-rust">impl Add for Foo {
    type Output = Foo;

    fn add(self, other: Foo) -&gt; Foo {
        Foo(self.0 - other.0)
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+suspicious_arithmetic_impl">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/suspicious_trait_impl.rs#L10">View Source</a></div></div></div></article><article id="suspicious_assignment_formatting"><input id="label-suspicious_assignment_formatting" type="checkbox"><label for="label-suspicious_assignment_formatting"><h2 class="lint-title"><div class="panel-title-name" id="lint-suspicious_assignment_formatting">suspicious_assignment_formatting
<a href="#suspicious_assignment_formatting" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of the non-existent <code>=*</code>, <code>=!</code> and <code>=-</code>
operators.</p>
<h3>Why is this bad?</h3>
<p>This is either a typo of <code>*=</code>, <code>!=</code> or <code>-=</code> or
confusing.</p>
<h3>Example</h3>
<pre><code class="language-rust">a =- 42; // confusing, should it be `a -= 42` or `a = -42`?
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+suspicious_assignment_formatting">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/formatting.rs#L9">View Source</a></div></div></div></article><article id="suspicious_command_arg_space"><input id="label-suspicious_command_arg_space" type="checkbox"><label for="label-suspicious_command_arg_space"><h2 class="lint-title"><div class="panel-title-name" id="lint-suspicious_command_arg_space">suspicious_command_arg_space
<a href="#suspicious_command_arg_space" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>Command::arg()</code> invocations that look like they
should be multiple arguments instead, such as <code>arg("-t ext2")</code>.</p>
<h3>Why is this bad?</h3>
<p><code>Command::arg()</code> does not split arguments by space. An argument like <code>arg("-t ext2")</code>
will be passed as a single argument to the command,
which is likely not what was intended.</p>
<h3>Example</h3>
<pre><code class="language-rust">std::process::Command::new("echo").arg("-n hello").spawn().unwrap();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">std::process::Command::new("echo").args(["-n", "hello"]).spawn().unwrap();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.69.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+suspicious_command_arg_space">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3369">View Source</a></div></div></div></article><article id="suspicious_doc_comments"><input id="label-suspicious_doc_comments" type="checkbox"><label for="label-suspicious_doc_comments"><h2 class="lint-title"><div class="panel-title-name" id="lint-suspicious_doc_comments">suspicious_doc_comments
<a href="#suspicious_doc_comments" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects the use of outer doc comments (<code>///</code>, <code>/**</code>) followed by a bang (<code>!</code>): <code>///!</code></p>
<h3>Why is this bad?</h3>
<p>Triple-slash comments (known as “outer doc comments”) apply to items that follow it.
An outer doc comment followed by a bang (i.e. <code>///!</code>) has no specific meaning.</p>
<p>The user most likely meant to write an inner doc comment (<code>//!</code>, <code>/*!</code>), which
applies to the parent item (i.e. the item that the comment is contained in,
usually a module or crate).</p>
<h3>Known problems</h3>
<p>Inner doc comments can only appear before items, so there are certain cases where the suggestion
made by this lint is not valid code. For example:</p>
<pre><code class="language-rust">fn foo() {}
///!
fn bar() {}
</code></pre>
<p>This lint detects the doc comment and suggests changing it to <code>//!</code>, but an inner doc comment
is not valid at that position.</p>
<h3>Example</h3>
<p>In this example, the doc comment is attached to the <em>function</em>, rather than the <em>module</em>.</p>
<pre><code class="language-rust">pub mod util {
    ///! This module contains utility functions.

    pub fn dummy() {}
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">pub mod util {
    //! This module contains utility functions.

    pub fn dummy() {}
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+suspicious_doc_comments">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L363">View Source</a></div></div></div></article><article id="suspicious_else_formatting"><input id="label-suspicious_else_formatting" type="checkbox"><label for="label-suspicious_else_formatting"><h2 class="lint-title"><div class="panel-title-name" id="lint-suspicious_else_formatting">suspicious_else_formatting
<a href="#suspicious_else_formatting" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for formatting of <code>else</code>. It lints if the <code>else</code>
is followed immediately by a newline or the <code>else</code> seems to be missing.</p>
<h3>Why is this bad?</h3>
<p>This is probably some refactoring remnant, even if the
code is correct, it might look confusing.</p>
<h3>Example</h3>
<pre><code class="language-rust">if foo {
} { // looks like an `else` is missing here
}

if foo {
} if bar { // looks like an `else` is missing here
}

if foo {
} else

{ // this is the `else` block of the previous `if`, but should it be?
}

if foo {
} else

if bar { // this is the `else` block of the previous `if`, but should it be?
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+suspicious_else_formatting">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/formatting.rs#L57">View Source</a></div></div></div></article><article id="suspicious_map"><input id="label-suspicious_map" type="checkbox"><label for="label-suspicious_map"><h2 class="lint-title"><div class="panel-title-name" id="lint-suspicious_map">suspicious_map
<a href="#suspicious_map" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>map</code> followed by a <code>count</code>.</p>
<h3>Why is this bad?</h3>
<p>It looks suspicious. Maybe <code>map</code> was confused with <code>filter</code>.
If the <code>map</code> call is intentional, this should be rewritten
using <code>inspect</code>. Or, if you intend to drive the iterator to
completion, you can just use <code>for_each</code> instead.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = (0..3).map(|x| x + 2).count();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.39.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+suspicious_map">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1630">View Source</a></div></div></div></article><article id="suspicious_op_assign_impl"><input id="label-suspicious_op_assign_impl" type="checkbox"><label for="label-suspicious_op_assign_impl"><h2 class="lint-title"><div class="panel-title-name" id="lint-suspicious_op_assign_impl">suspicious_op_assign_impl
<a href="#suspicious_op_assign_impl" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Lints for suspicious operations in impls of OpAssign, e.g.
subtracting elements in an AddAssign impl.</p>
<h3>Why is this bad?</h3>
<p>This is probably a typo or copy-and-paste error and not intended.</p>
<h3>Example</h3>
<pre><code class="language-rust">impl AddAssign for Foo {
    fn add_assign(&amp;mut self, other: Foo) {
        *self = *self - other;
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+suspicious_op_assign_impl">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/suspicious_trait_impl.rs#L34">View Source</a></div></div></div></article><article id="suspicious_open_options"><input id="label-suspicious_open_options" type="checkbox"><label for="label-suspicious_open_options"><h2 class="lint-title"><div class="panel-title-name" id="lint-suspicious_open_options">suspicious_open_options
<a href="#suspicious_open_options" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the suspicious use of <code>OpenOptions::create()</code>
without an explicit <code>OpenOptions::truncate()</code>.</p>
<h3>Why is this bad?</h3>
<p><code>create()</code> alone will either create a new file or open an
existing file. If the file already exists, it will be
overwritten when written to, but the file will not be
truncated by default.
If less data is written to the file
than it already contains, the remainder of the file will
remain unchanged, and the end of the file will contain old
data.
In most cases, one should either use <code>create_new</code> to ensure
the file is created from scratch, or ensure <code>truncate</code> is
called so that the truncation behaviour is explicit. <code>truncate(true)</code>
will ensure the file is entirely overwritten with new data, whereas
<code>truncate(false)</code> will explicitly keep the default behavior.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::fs::OpenOptions;

OpenOptions::new().create(true);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::fs::OpenOptions;

OpenOptions::new().create(true).truncate(true);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.77.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+suspicious_open_options">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2912">View Source</a></div></div></div></article><article id="suspicious_operation_groupings"><input id="label-suspicious_operation_groupings" type="checkbox"><label for="label-suspicious_operation_groupings"><h2 class="lint-title"><div class="panel-title-name" id="lint-suspicious_operation_groupings">suspicious_operation_groupings
<a href="#suspicious_operation_groupings" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for unlikely usages of binary operators that are almost
certainly typos and/or copy/paste errors, given the other usages
of binary operators nearby.</p>
<h3>Why is this bad?</h3>
<p>They are probably bugs and if they aren’t then they look like bugs
and you should add a comment explaining why you are doing such an
odd set of operations.</p>
<h3>Known problems</h3>
<p>There may be some false positives if you are trying to do something
unusual that happens to look like a typo.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Vec3 {
    x: f64,
    y: f64,
    z: f64,
}

impl Eq for Vec3 {}

impl PartialEq for Vec3 {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        // This should trigger the lint because `self.x` is compared to `other.y`
        self.x == other.y &amp;&amp; self.y == other.y &amp;&amp; self.z == other.z
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">// same as above except:
impl PartialEq for Vec3 {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        // Note we now compare other.x to self.x
        self.x == other.x &amp;&amp; self.y == other.y &amp;&amp; self.z == other.z
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.50.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+suspicious_operation_groupings">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/suspicious_operation_groupings.rs#L14">View Source</a></div></div></div></article><article id="suspicious_splitn"><input id="label-suspicious_splitn" type="checkbox"><label for="label-suspicious_splitn"><h2 class="lint-title"><div class="panel-title-name" id="lint-suspicious_splitn">suspicious_splitn
<a href="#suspicious_splitn" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to [<code>splitn</code>]
(https://doc.rust-lang.org/std/primitive.str.html#method.splitn) and
related functions with either zero or one splits.</p>
<h3>Why is this bad?</h3>
<p>These calls don’t actually split the value and are
likely to be intended as a different number.</p>
<h3>Example</h3>
<pre><code class="language-rust">for x in s.splitn(1, ":") {
    // ..
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">for x in s.splitn(2, ":") {
    // ..
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.54.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+suspicious_splitn">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2228">View Source</a></div></div></div></article><article id="suspicious_to_owned"><input id="label-suspicious_to_owned" type="checkbox"><label for="label-suspicious_to_owned"><h2 class="lint-title"><div class="panel-title-name" id="lint-suspicious_to_owned">suspicious_to_owned
<a href="#suspicious_to_owned" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the usage of <code>_.to_owned()</code>, on a <code>Cow&lt;'_, _&gt;</code>.</p>
<h3>Why is this bad?</h3>
<p>Calling <code>to_owned()</code> on a <code>Cow</code> creates a clone of the <code>Cow</code>
itself, without taking ownership of the <code>Cow</code> contents (i.e.
it’s equivalent to calling <code>Cow::clone</code>).
The similarly named <code>into_owned</code> method, on the other hand,
clones the <code>Cow</code> contents, effectively turning any <code>Cow::Borrowed</code>
into a <code>Cow::Owned</code>.</p>
<p>Given the potential ambiguity, consider replacing <code>to_owned</code>
with <code>clone</code> for better readability or, if getting a <code>Cow::Owned</code>
was the original intent, using <code>into_owned</code> instead.</p>
<h3>Example</h3>
<pre><code class="language-rust">let s = "Hello world!";
let cow = Cow::Borrowed(s);

let data = cow.to_owned();
assert!(matches!(data, Cow::Borrowed(_)))
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let s = "Hello world!";
let cow = Cow::Borrowed(s);

let data = cow.clone();
assert!(matches!(data, Cow::Borrowed(_)))
</code></pre>
<p>or</p>
<pre><code class="language-rust">let s = "Hello world!";
let cow = Cow::Borrowed(s);

let _data: String = cow.into_owned();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.65.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+suspicious_to_owned">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2180">View Source</a></div></div></div></article><article id="suspicious_unary_op_formatting"><input id="label-suspicious_unary_op_formatting" type="checkbox"><label for="label-suspicious_unary_op_formatting"><h2 class="lint-title"><div class="panel-title-name" id="lint-suspicious_unary_op_formatting">suspicious_unary_op_formatting
<a href="#suspicious_unary_op_formatting" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks the formatting of a unary operator on the right hand side
of a binary operator. It lints if there is no space between the binary and unary operators,
but there is a space between the unary and its operand.</p>
<h3>Why is this bad?</h3>
<p>This is either a typo in the binary operator or confusing.</p>
<h3>Example</h3>
<pre><code class="language-rust">// &amp;&amp;! looks like a different operator
if foo &amp;&amp;! bar {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if foo &amp;&amp; !bar {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.40.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+suspicious_unary_op_formatting">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/formatting.rs#L28">View Source</a></div></div></div></article><article id="suspicious_xor_used_as_pow"><input id="label-suspicious_xor_used_as_pow" type="checkbox"><label for="label-suspicious_xor_used_as_pow"><h2 class="lint-title"><div class="panel-title-name" id="lint-suspicious_xor_used_as_pow">suspicious_xor_used_as_pow
<a href="#suspicious_xor_used_as_pow" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns for a Bitwise XOR (<code>^</code>) operator being probably confused as a powering. It will not trigger if any of the numbers are not in decimal.</p>
<h3>Why restrict this?</h3>
<p>It’s most probably a typo and may lead to unexpected behaviours.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = 3_i32 ^ 4_i32;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = 3_i32.pow(4);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.67.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+suspicious_xor_used_as_pow">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/suspicious_xor_used_as_pow.rs#L10">View Source</a></div></div></div></article><article id="swap_ptr_to_ref"><input id="label-swap_ptr_to_ref" type="checkbox"><label for="label-swap_ptr_to_ref"><h2 class="lint-title"><div class="panel-title-name" id="lint-swap_ptr_to_ref">swap_ptr_to_ref
<a href="#swap_ptr_to_ref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>core::mem::swap</code> where either parameter is derived from a pointer</p>
<h3>Why is this bad?</h3>
<p>When at least one parameter to <code>swap</code> is derived from a pointer it may overlap with the
other. This would then lead to undefined behavior.</p>
<h3>Example</h3>
<pre><code class="language-rust">unsafe fn swap(x: &amp;[*mut u32], y: &amp;[*mut u32]) {
    for (&amp;x, &amp;y) in x.iter().zip(y) {
        core::mem::swap(&amp;mut *x, &amp;mut *y);
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">unsafe fn swap(x: &amp;[*mut u32], y: &amp;[*mut u32]) {
    for (&amp;x, &amp;y) in x.iter().zip(y) {
        core::ptr::swap(x, y);
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.63.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+swap_ptr_to_ref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/swap_ptr_to_ref.rs#L10">View Source</a></div></div></div></article><article id="swap_with_temporary"><input id="label-swap_with_temporary" type="checkbox"><label for="label-swap_with_temporary"><h2 class="lint-title"><div class="panel-title-name" id="lint-swap_with_temporary">swap_with_temporary
<a href="#swap_with_temporary" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>std::mem::swap</code> with temporary values.</p>
<h3>Why is this bad?</h3>
<p>Storing a new value in place of a temporary value which will
be dropped right after the <code>swap</code> is an inefficient way of performing
an assignment. The same result can be achieved by using a regular
assignment.</p>
<h3>Examples</h3>
<pre><code class="language-rust">fn replace_string(s: &amp;mut String) {
    std::mem::swap(s, &amp;mut String::from("replaced"));
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn replace_string(s: &amp;mut String) {
    *s = String::from("replaced");
}
</code></pre>
<p>Also, swapping two temporary values has no effect, as they will
both be dropped right after swapping them. This is likely an indication
of a bug. For example, the following code swaps the references to
the last element of the vectors, instead of swapping the elements
themselves:</p>
<pre><code class="language-rust">fn bug(v1: &amp;mut [i32], v2: &amp;mut [i32]) {
    // Incorrect: swapping temporary references (`&amp;mut &amp;mut` passed to swap)
    std::mem::swap(&amp;mut v1.last_mut().unwrap(), &amp;mut v2.last_mut().unwrap());
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn correct(v1: &amp;mut [i32], v2: &amp;mut [i32]) {
    std::mem::swap(v1.last_mut().unwrap(), v2.last_mut().unwrap());
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.88.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+swap_with_temporary">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4571">View Source</a></div></div></div></article><article id="tabs_in_doc_comments"><input id="label-tabs_in_doc_comments" type="checkbox"><label for="label-tabs_in_doc_comments"><h2 class="lint-title"><div class="panel-title-name" id="lint-tabs_in_doc_comments">tabs_in_doc_comments
<a href="#tabs_in_doc_comments" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks doc comments for usage of tab characters.</p>
<h3>Why is this bad?</h3>
<p>The rust style-guide promotes spaces instead of tabs for indentation.
To keep a consistent view on the source, also doc comments should not have tabs.
Also, explaining ascii-diagrams containing tabs can get displayed incorrectly when the
display settings of the author and reader differ.</p>
<h3>Example</h3>
<pre><code class="language-rust">///
/// Struct to hold two strings:
/// 	- first		one
/// 	- second	one
pub struct DoubleString {
   ///
   /// 	- First String:
   /// 		- needs to be inside here
   first_string: String,
   ///
   /// 	- Second String:
   /// 		- needs to be inside here
   second_string: String,
}
</code></pre>
<p>Will be converted to:</p>
<pre><code class="language-rust">///
/// Struct to hold two strings:
///     - first        one
///     - second    one
pub struct DoubleString {
   ///
   ///     - First String:
   ///         - needs to be inside here
   first_string: String,
   ///
   ///     - Second String:
   ///         - needs to be inside here
   second_string: String,
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.41.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+tabs_in_doc_comments">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/tabs_in_doc_comments.rs#L8">View Source</a></div></div></div></article><article id="temporary_assignment"><input id="label-temporary_assignment" type="checkbox"><label for="label-temporary_assignment"><h2 class="lint-title"><div class="panel-title-name" id="lint-temporary_assignment">temporary_assignment
<a href="#temporary_assignment" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for construction of a structure or tuple just to
assign a value in it.</p>
<h3>Why is this bad?</h3>
<p>Readability. If the structure is only created to be
updated, why not write the structure you want in the first place?</p>
<h3>Example</h3>
<pre><code class="language-rust">(0, 0).0 = 1
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+temporary_assignment">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/temporary_assignment.rs#L7">View Source</a></div></div></div></article><article id="test_attr_in_doctest"><input id="label-test_attr_in_doctest" type="checkbox"><label for="label-test_attr_in_doctest"><h2 class="lint-title"><div class="panel-title-name" id="lint-test_attr_in_doctest">test_attr_in_doctest
<a href="#test_attr_in_doctest" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>#[test]</code> in doctests unless they are marked with
either <code>ignore</code>, <code>no_run</code> or <code>compile_fail</code>.</p>
<h3>Why is this bad?</h3>
<p>Code in examples marked as <code>#[test]</code> will somewhat
surprisingly not be run by <code>cargo test</code>. If you really want
to show how to test stuff in an example, mark it <code>no_run</code> to
make the intent clear.</p>
<h3>Examples</h3>
<pre><code class="language-rust">/// An example of a doctest with a `main()` function
///
/// # Examples
///
/// ```
/// #[test]
/// fn equality_works() {
///     assert_eq!(1_u8, 1);
/// }
/// ```
fn test_attr_in_doctest() {
    unimplemented!();
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.76.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+test_attr_in_doctest">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L243">View Source</a></div></div></div></article><article id="tests_outside_test_module"><input id="label-tests_outside_test_module" type="checkbox"><label for="label-tests_outside_test_module"><h2 class="lint-title"><div class="panel-title-name" id="lint-tests_outside_test_module">tests_outside_test_module
<a href="#tests_outside_test_module" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Triggers when a testing function (marked with the <code>#[test]</code> attribute) isn’t inside a testing module
(marked with <code>#[cfg(test)]</code>).</p>
<h3>Why restrict this?</h3>
<p>The idiomatic (and more performant) way of writing tests is inside a testing module (flagged with <code>#[cfg(test)]</code>),
having test functions outside of this module is confusing and may lead to them being “hidden”.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[test]
fn my_cool_test() {
    // [...]
}

#[cfg(test)]
mod tests {
    // [...]
}

</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn my_cool_test() {
        // [...]
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+tests_outside_test_module">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/tests_outside_test_module.rs#L10">View Source</a></div></div></div></article><article id="to_digit_is_some"><input id="label-to_digit_is_some" type="checkbox"><label for="label-to_digit_is_some"><h2 class="lint-title"><div class="panel-title-name" id="lint-to_digit_is_some">to_digit_is_some
<a href="#to_digit_is_some" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>.to_digit(..).is_some()</code> on <code>char</code>s.</p>
<h3>Why is this bad?</h3>
<p>This is a convoluted way of checking if a <code>char</code> is a digit. It’s
more straight forward to use the dedicated <code>is_digit</code> method.</p>
<h3>Example</h3>
<pre><code class="language-rust">let is_digit = c.to_digit(radix).is_some();
</code></pre>
<p>can be written as:</p>
<pre><code class="language-rust">let is_digit = c.is_digit(radix);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.41.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+to_digit_is_some">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/to_digit_is_some.rs#L12">View Source</a></div></div></div></article><article id="to_string_in_format_args"><input id="label-to_string_in_format_args" type="checkbox"><label for="label-to_string_in_format_args"><h2 class="lint-title"><div class="panel-title-name" id="lint-to_string_in_format_args">to_string_in_format_args
<a href="#to_string_in_format_args" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <a href="https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string"><code>ToString::to_string</code></a>
applied to a type that implements <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a>
in a macro that does formatting.</p>
<h3>Why is this bad?</h3>
<p>Since the type implements <code>Display</code>, the use of <code>to_string</code> is
unnecessary.</p>
<h3>Example</h3>
<pre><code class="language-rust">println!("error: something failed at {}", Location::caller().to_string());
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">println!("error: something failed at {}", Location::caller());
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.58.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+to_string_in_format_args">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/format_args.rs#L90">View Source</a></div></div></div></article><article id="to_string_trait_impl"><input id="label-to_string_trait_impl" type="checkbox"><label for="label-to_string_trait_impl"><h2 class="lint-title"><div class="panel-title-name" id="lint-to_string_trait_impl">to_string_trait_impl
<a href="#to_string_trait_impl" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for direct implementations of <code>ToString</code>.</p>
<h3>Why is this bad?</h3>
<p>This trait is automatically implemented for any type which implements the <code>Display</code> trait.
As such, <code>ToString</code> shouldn’t be implemented directly: <code>Display</code> should be implemented instead,
and you get the <code>ToString</code> implementation for free.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Point {
  x: usize,
  y: usize,
}

impl ToString for Point {
  fn to_string(&amp;self) -&gt; String {
    format!("({}, {})", self.x, self.y)
  }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct Point {
  x: usize,
  y: usize,
}

impl std::fmt::Display for Point {
  fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
    write!(f, "({}, {})", self.x, self.y)
  }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.78.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+to_string_trait_impl">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/to_string_trait_impl.rs#L7">View Source</a></div></div></div></article><article id="todo"><input id="label-todo" type="checkbox"><label for="label-todo"><h2 class="lint-title"><div class="panel-title-name" id="lint-todo">todo
<a href="#todo" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>todo!</code>.</p>
<h3>Why restrict this?</h3>
<p>The <code>todo!</code> macro indicates the presence of unfinished code,
so it should not be present in production code.</p>
<h3>Example</h3>
<pre><code class="language-rust">todo!();
</code></pre>
<p>Finish the implementation, or consider marking it as explicitly unimplemented.</p>
<pre><code class="language-rust">unimplemented!();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.40.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+todo">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/panic_unimplemented.rs#L57">View Source</a></div></div></div></article><article id="too_long_first_doc_paragraph"><input id="label-too_long_first_doc_paragraph" type="checkbox"><label for="label-too_long_first_doc_paragraph"><h2 class="lint-title"><div class="panel-title-name" id="lint-too_long_first_doc_paragraph">too_long_first_doc_paragraph
<a href="#too_long_first_doc_paragraph" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks if the first paragraph in the documentation of items listed in the module page is too long.</p>
<h3>Why is this bad?</h3>
<p>Documentation will show the first paragraph of the docstring in the summary page of a
module. Having a nice, short summary in the first paragraph is part of writing good docs.</p>
<h3>Example</h3>
<pre><code class="language-rust">/// A very short summary.
/// A much longer explanation that goes into a lot more detail about
/// how the thing works, possibly with doclinks and so one,
/// and probably spanning a many rows.
struct Foo {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">/// A very short summary.
///
/// A much longer explanation that goes into a lot more detail about
/// how the thing works, possibly with doclinks and so one,
/// and probably spanning a many rows.
struct Foo {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.82.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+too_long_first_doc_paragraph">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L524">View Source</a></div></div></div></article><article id="too_many_arguments"><input id="label-too_many_arguments" type="checkbox"><label for="label-too_many_arguments"><h2 class="lint-title"><div class="panel-title-name" id="lint-too_many_arguments">too_many_arguments
<a href="#too_many_arguments" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for functions with too many parameters.</p>
<h3>Why is this bad?</h3>
<p>Functions with lots of parameters are considered bad
style and reduce readability (“what does the 5th parameter mean?”). Consider
grouping some parameters into a new type.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(x: u32, y: u32, name: &amp;str, c: Color, w: f32, h: f32, a: f32, b: f32) {
    // ..
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>too-many-arguments-threshold</code>:  The maximum number of argument a function or method can have</p>
<p>(default: <code>7</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+too_many_arguments">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/functions/mod.rs#L47">View Source</a></div></div></div></article><article id="too_many_lines"><input id="label-too_many_lines" type="checkbox"><label for="label-too_many_lines"><h2 class="lint-title"><div class="panel-title-name" id="lint-too_many_lines">too_many_lines
<a href="#too_many_lines" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for functions with a large amount of lines.</p>
<h3>Why is this bad?</h3>
<p>Functions with a lot of lines are harder to understand
due to having to look at a larger amount of code to understand what the
function is doing. Consider splitting the body of the function into
multiple functions.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn im_too_long() {
    println!("");
    // ... 100 more LoC
    println!("");
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>too-many-lines-threshold</code>:  The maximum number of lines a function or method can have</p>
<p>(default: <code>100</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.34.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+too_many_lines">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/functions/mod.rs#L69">View Source</a></div></div></div></article><article id="toplevel_ref_arg"><input id="label-toplevel_ref_arg" type="checkbox"><label for="label-toplevel_ref_arg"><h2 class="lint-title"><div class="panel-title-name" id="lint-toplevel_ref_arg">toplevel_ref_arg
<a href="#toplevel_ref_arg" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for function arguments and let bindings denoted as
<code>ref</code>.</p>
<h3>Why is this bad?</h3>
<p>The <code>ref</code> declaration makes the function take an owned
value, but turns the argument into a reference (which means that the value
is destroyed when exiting the function). This adds not much value: either
take a reference type, or take an owned value and create references in the
body.</p>
<p>For let bindings, <code>let x = &amp;foo;</code> is preferred over <code>let ref x = foo</code>. The
type of <code>x</code> is more obvious with the former.</p>
<h3>Known problems</h3>
<p>If the argument is dereferenced within the function,
removing the <code>ref</code> will lead to errors. This can be fixed by removing the
dereferences, e.g., changing <code>*x</code> to <code>x</code> within the function.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(ref _x: u8) {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo(_x: &amp;u8) {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+toplevel_ref_arg">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/toplevel_ref_arg.rs#L15">View Source</a></div></div></div></article><article id="trailing_empty_array"><input id="label-trailing_empty_array" type="checkbox"><label for="label-trailing_empty_array"><h2 class="lint-title"><div class="panel-title-name" id="lint-trailing_empty_array">trailing_empty_array
<a href="#trailing_empty_array" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Displays a warning when a struct with a trailing zero-sized array is declared without a <code>repr</code> attribute.</p>
<h3>Why is this bad?</h3>
<p>Zero-sized arrays aren’t very useful in Rust itself, so such a struct is likely being created to pass to C code or in some other situation where control over memory layout matters (for example, in conjunction with manual allocation to make it easy to compute the offset of the array). Either way, <code>#[repr(C)]</code> (or another <code>repr</code> attribute) is needed.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct RarelyUseful {
    some_field: u32,
    last: [u32; 0],
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[repr(C)]
struct MoreOftenUseful {
    some_field: usize,
    last: [u32; 0],
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.58.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+trailing_empty_array">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/trailing_empty_array.rs#L8">View Source</a></div></div></div></article><article id="trait_duplication_in_bounds"><input id="label-trait_duplication_in_bounds" type="checkbox"><label for="label-trait_duplication_in_bounds"><h2 class="lint-title"><div class="panel-title-name" id="lint-trait_duplication_in_bounds">trait_duplication_in_bounds
<a href="#trait_duplication_in_bounds" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for cases where generics or trait objects are being used and multiple
syntax specifications for trait bounds are used simultaneously.</p>
<h3>Why is this bad?</h3>
<p>Duplicate bounds makes the code
less readable than specifying them only once.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn func&lt;T: Clone + Default&gt;(arg: T) where T: Clone + Default {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn func&lt;T: Clone + Default&gt;(arg: T) {}

// or

fn func&lt;T&gt;(arg: T) where T: Clone + Default {}
</code></pre>
<pre><code class="language-rust">fn foo&lt;T: Default + Default&gt;(bar: T) {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo&lt;T: Default&gt;(bar: T) {}
</code></pre>
<pre><code class="language-rust">fn foo&lt;T&gt;(bar: T) where T: Default + Default {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo&lt;T&gt;(bar: T) where T: Default {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.47.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+trait_duplication_in_bounds">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/trait_bounds.rs#L43">View Source</a></div></div></div></article><article id="transmute_bytes_to_str"><input id="label-transmute_bytes_to_str" type="checkbox"><label for="label-transmute_bytes_to_str"><h2 class="lint-title"><div class="panel-title-name" id="lint-transmute_bytes_to_str">transmute_bytes_to_str
<a href="#transmute_bytes_to_str" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for transmutes from a <code>&amp;[u8]</code> to a <code>&amp;str</code>.</p>
<h3>Why is this bad?</h3>
<p>Not every byte slice is a valid UTF-8 string.</p>
<h3>Known problems</h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/str/fn.from_utf8.html"><code>from_utf8</code></a> which this lint suggests using is slower than <code>transmute</code>
as it needs to validate the input.
If you are certain that the input is always a valid UTF-8,
use <a href="https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked.html"><code>from_utf8_unchecked</code></a> which is as fast as <code>transmute</code>
but has a semantically meaningful name.</li>
<li>You might want to handle errors returned from <a href="https://doc.rust-lang.org/std/str/fn.from_utf8.html"><code>from_utf8</code></a> instead of calling <code>unwrap</code>.</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">let b: &amp;[u8] = &amp;[1_u8, 2_u8];
unsafe {
    let _: &amp;str = std::mem::transmute(b); // where b: &amp;[u8]
}

// should be:
let _ = std::str::from_utf8(b).unwrap();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+transmute_bytes_to_str">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/transmute/mod.rs#L143">View Source</a></div></div></div></article><article id="transmute_int_to_bool"><input id="label-transmute_int_to_bool" type="checkbox"><label for="label-transmute_int_to_bool"><h2 class="lint-title"><div class="panel-title-name" id="lint-transmute_int_to_bool">transmute_int_to_bool
<a href="#transmute_int_to_bool" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for transmutes from an integer to a <code>bool</code>.</p>
<h3>Why is this bad?</h3>
<p>This might result in an invalid in-memory representation of a <code>bool</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = 1_u8;
unsafe {
    let _: bool = std::mem::transmute(x); // where x: u8
}

// should be:
let _: bool = x != 0;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+transmute_int_to_bool">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/transmute/mod.rs#L177">View Source</a></div></div></div></article><article id="transmute_int_to_non_zero"><input id="label-transmute_int_to_non_zero" type="checkbox"><label for="label-transmute_int_to_non_zero"><h2 class="lint-title"><div class="panel-title-name" id="lint-transmute_int_to_non_zero">transmute_int_to_non_zero
<a href="#transmute_int_to_non_zero" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for transmutes from <code>T</code> to <code>NonZero&lt;T&gt;</code>, and suggests the <code>new_unchecked</code>
method instead.</p>
<h3>Why is this bad?</h3>
<p>Transmutes work on any types and thus might cause unsoundness when those types change
elsewhere. <code>new_unchecked</code> only works for the appropriate types instead.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _: NonZero&lt;u32&gt; = unsafe { std::mem::transmute(123) };
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _: NonZero&lt;u32&gt; = unsafe { NonZero::new_unchecked(123) };
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.69.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+transmute_int_to_non_zero">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/transmute/mod.rs#L200">View Source</a></div></div></div></article><article id="transmute_null_to_fn"><input id="label-transmute_null_to_fn" type="checkbox"><label for="label-transmute_null_to_fn"><h2 class="lint-title"><div class="panel-title-name" id="lint-transmute_null_to_fn">transmute_null_to_fn
<a href="#transmute_null_to_fn" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for null function pointer creation through transmute.</p>
<h3>Why is this bad?</h3>
<p>Creating a null function pointer is undefined behavior.</p>
<p>More info: https://doc.rust-lang.org/nomicon/ffi.html#the-nullable-pointer-optimization</p>
<h3>Known problems</h3>
<p>Not all cases can be detected at the moment of this writing.
For example, variables which hold a null pointer and are then fed to a <code>transmute</code>
call, aren’t detectable yet.</p>
<h3>Example</h3>
<pre><code class="language-rust">let null_fn: fn() = unsafe { std::mem::transmute( std::ptr::null::&lt;()&gt;() ) };
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let null_fn: Option&lt;fn()&gt; = None;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.68.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+transmute_null_to_fn">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/transmute/mod.rs#L336">View Source</a></div></div></div></article><article id="transmute_ptr_to_ptr"><input id="label-transmute_ptr_to_ptr" type="checkbox"><label for="label-transmute_ptr_to_ptr"><h2 class="lint-title"><div class="panel-title-name" id="lint-transmute_ptr_to_ptr">transmute_ptr_to_ptr
<a href="#transmute_ptr_to_ptr" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for transmutes from a pointer to a pointer, or
from a reference to a reference.</p>
<h3>Why is this bad?</h3>
<p>Transmutes are dangerous, and these can instead be
written as casts.</p>
<h3>Example</h3>
<pre><code class="language-rust">let ptr = &amp;1u32 as *const u32;
unsafe {
    // pointer-to-pointer transmute
    let _: *const f32 = std::mem::transmute(ptr);
    // ref-ref transmute
    let _: &amp;f32 = std::mem::transmute(&amp;1u32);
}
// These can be respectively written:
let _ = ptr as *const f32;
let _ = unsafe{ &amp;*(&amp;1u32 as *const u32 as *const f32) };
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+transmute_ptr_to_ptr">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/transmute/mod.rs#L225">View Source</a></div></div></div></article><article id="transmute_ptr_to_ref"><input id="label-transmute_ptr_to_ref" type="checkbox"><label for="label-transmute_ptr_to_ref"><h2 class="lint-title"><div class="panel-title-name" id="lint-transmute_ptr_to_ref">transmute_ptr_to_ref
<a href="#transmute_ptr_to_ref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for transmutes from a pointer to a reference.</p>
<h3>Why is this bad?</h3>
<p>This can always be rewritten with <code>&amp;</code> and <code>*</code>.</p>
<h3>Known problems</h3>
<ul>
<li><code>mem::transmute</code> in statics and constants is stable from Rust 1.46.0,
while dereferencing raw pointer is not stable yet.
If you need to do this in those places,
you would have to use <code>transmute</code> instead.</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">unsafe {
    let _: &amp;T = std::mem::transmute(p); // where p: *const T
}

// can be written:
let _: &amp;T = &amp;*p;
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+transmute_ptr_to_ref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/transmute/mod.rs#L115">View Source</a></div></div></div></article><article id="transmute_undefined_repr"><input id="label-transmute_undefined_repr" type="checkbox"><label for="label-transmute_undefined_repr"><h2 class="lint-title"><div class="panel-title-name" id="lint-transmute_undefined_repr">transmute_undefined_repr
<a href="#transmute_undefined_repr" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for transmutes between types which do not have a representation defined relative to
each other.</p>
<h3>Why is this bad?</h3>
<p>The results of such a transmute are not defined.</p>
<h3>Known problems</h3>
<p>This lint has had multiple problems in the past and was moved to <code>nursery</code>. See issue
<a href="https://github.com/rust-lang/rust-clippy/issues/8496">#8496</a> for more details.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct Foo&lt;T&gt;(u32, T);
let _ = unsafe { core::mem::transmute::&lt;Foo&lt;u32&gt;, Foo&lt;i32&gt;&gt;(Foo(0u32, 0u32)) };
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[repr(C)]
struct Foo&lt;T&gt;(u32, T);
let _ = unsafe { core::mem::transmute::&lt;Foo&lt;u32&gt;, Foo&lt;i32&gt;&gt;(Foo(0u32, 0u32)) };
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.60.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+transmute_undefined_repr">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/transmute/mod.rs#L285">View Source</a></div></div></div></article><article id="transmutes_expressible_as_ptr_casts"><input id="label-transmutes_expressible_as_ptr_casts" type="checkbox"><label for="label-transmutes_expressible_as_ptr_casts"><h2 class="lint-title"><div class="panel-title-name" id="lint-transmutes_expressible_as_ptr_casts">transmutes_expressible_as_ptr_casts
<a href="#transmutes_expressible_as_ptr_casts" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for transmutes that could be a pointer cast.</p>
<h3>Why is this bad?</h3>
<p>Readability. The code tricks people into thinking that
something complex is going on.</p>
<h3>Example</h3>
<pre><code class="language-rust">unsafe { std::mem::transmute::&lt;*const [i32], *const [u16]&gt;(p) };
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">p as *const [u16];
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.47.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+transmutes_expressible_as_ptr_casts">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/transmute/mod.rs#L71">View Source</a></div></div></div></article><article id="transmuting_null"><input id="label-transmuting_null" type="checkbox"><label for="label-transmuting_null"><h2 class="lint-title"><div class="panel-title-name" id="lint-transmuting_null">transmuting_null
<a href="#transmuting_null" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for transmute calls which would receive a null pointer.</p>
<h3>Why is this bad?</h3>
<p>Transmuting a null pointer is undefined behavior.</p>
<h3>Known problems</h3>
<p>Not all cases can be detected at the moment of this writing.
For example, variables which hold a null pointer and are then fed to a <code>transmute</code>
call, aren’t detectable yet.</p>
<h3>Example</h3>
<pre><code class="language-rust">let null_ref: &amp;u64 = unsafe { std::mem::transmute(0 as *const u64) };
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.35.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+transmuting_null">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/transmute/mod.rs#L314">View Source</a></div></div></div></article><article id="trim_split_whitespace"><input id="label-trim_split_whitespace" type="checkbox"><label for="label-trim_split_whitespace"><h2 class="lint-title"><div class="panel-title-name" id="lint-trim_split_whitespace">trim_split_whitespace
<a href="#trim_split_whitespace" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns about calling <code>str::trim</code> (or variants) before <code>str::split_whitespace</code>.</p>
<h3>Why is this bad?</h3>
<p><code>split_whitespace</code> already ignores leading and trailing whitespace.</p>
<h3>Example</h3>
<pre><code class="language-rust">" A B C ".trim().split_whitespace();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">" A B C ".split_whitespace();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+trim_split_whitespace">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/strings.rs#L417">View Source</a></div></div></div></article><article id="trivial_regex"><input id="label-trivial_regex" type="checkbox"><label for="label-trivial_regex"><h2 class="lint-title"><div class="panel-title-name" id="lint-trivial_regex">trivial_regex
<a href="#trivial_regex" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for trivial <a href="https://crates.io/crates/regex">regex</a>
creation (with <code>Regex::new</code>, <code>RegexBuilder::new</code>, or <code>RegexSet::new</code>).</p>
<h3>Why is this bad?</h3>
<p>Matching the regex can likely be replaced by <code>==</code> or
<code>str::starts_with</code>, <code>str::ends_with</code> or <code>std::contains</code> or other <code>str</code>
methods.</p>
<h3>Known problems</h3>
<p>If the same regex is going to be applied to multiple
inputs, the precomputations done by <code>Regex</code> construction can give
significantly better performance than any of the <code>str</code>-based methods.</p>
<h3>Example</h3>
<pre><code class="language-rust">Regex::new("^foobar")
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">str::starts_with("foobar")
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+trivial_regex">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/regex.rs#L40">View Source</a></div></div></div></article><article id="trivially_copy_pass_by_ref"><input id="label-trivially_copy_pass_by_ref" type="checkbox"><label for="label-trivially_copy_pass_by_ref"><h2 class="lint-title"><div class="panel-title-name" id="lint-trivially_copy_pass_by_ref">trivially_copy_pass_by_ref
<a href="#trivially_copy_pass_by_ref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for functions taking arguments by reference, where
the argument type is <code>Copy</code> and small enough to be more efficient to always
pass by value.</p>
<h3>Why is this bad?</h3>
<p>In many calling conventions instances of structs will
be passed through registers if they fit into two or less general purpose
registers.</p>
<h3>Known problems</h3>
<p>This lint is target dependent, some cases will lint on 64-bit targets but
not 32-bit or lower targets.</p>
<p>The configuration option <code>trivial_copy_size_limit</code> can be set to override
this limit for a project.</p>
<p>This lint attempts to allow passing arguments by reference if a reference
to that argument is returned. This is implemented by comparing the lifetime
of the argument and return value for equality. However, this can cause
false positives in cases involving multiple lifetimes that are bounded by
each other.</p>
<p>Also, it does not take account of other similar cases where getting memory addresses
matters; namely, returning the pointer to the argument in question,
and passing the argument, as both references and pointers,
to a function that needs the memory address. For further details, refer to
<a href="https://github.com/rust-lang/rust-clippy/issues/5953">this issue</a>
that explains a real case in which this false positive
led to an <strong>undefined behavior</strong> introduced with unsafe code.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(v: &amp;u32) {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo(v: u32) {}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
<li>
<p><code>trivial-copy-size-limit</code>:  The maximum size (in bytes) to consider a <code>Copy</code> type for passing by value instead of by
reference.</p>
<p>(default: <code>target_pointer_width</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+trivially_copy_pass_by_ref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/pass_by_ref_or_value.rs#L23">View Source</a></div></div></div></article><article id="try_err"><input id="label-try_err" type="checkbox"><label for="label-try_err"><h2 class="lint-title"><div class="panel-title-name" id="lint-try_err">try_err
<a href="#try_err" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>Err(x)?</code>.</p>
<h3>Why restrict this?</h3>
<p>The <code>?</code> operator is designed to allow calls that
can fail to be easily chained. For example, <code>foo()?.bar()</code> or
<code>foo(bar()?)</code>. Because <code>Err(x)?</code> can’t be used that way (it will
always return), it is more clear to write <code>return Err(x)</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(fail: bool) -&gt; Result&lt;i32, String&gt; {
    if fail {
      Err("failed")?;
    }
    Ok(0)
}
</code></pre>
<p>Could be written:</p>
<pre><code class="language-rust">fn foo(fail: bool) -&gt; Result&lt;i32, String&gt; {
    if fail {
      return Err("failed".into());
    }
    Ok(0)
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.38.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+try_err">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L858">View Source</a></div></div></div></article><article id="tuple_array_conversions"><input id="label-tuple_array_conversions" type="checkbox"><label for="label-tuple_array_conversions"><h2 class="lint-title"><div class="panel-title-name" id="lint-tuple_array_conversions">tuple_array_conversions
<a href="#tuple_array_conversions" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for tuple&lt;=&gt;array conversions that are not done with <code>.into()</code>.</p>
<h3>Why is this bad?</h3>
<p>It may be unnecessary complexity. <code>.into()</code> works for converting tuples&lt;=&gt; arrays of up to
12 elements and conveys the intent more clearly, while also leaving less room for hard to
spot bugs!</p>
<h3>Known issues</h3>
<p>The suggested code may hide potential asymmetry in some cases. See
<a href="https://github.com/rust-lang/rust-clippy/issues/11085">#11085</a> for more info.</p>
<h3>Example</h3>
<pre><code class="language-rust">let t1 = &amp;[(1, 2), (3, 4)];
let v1: Vec&lt;[u32; 2]&gt; = t1.iter().map(|&amp;(a, b)| [a, b]).collect();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let t1 = &amp;[(1, 2), (3, 4)];
let v1: Vec&lt;[u32; 2]&gt; = t1.iter().map(|&amp;t| t.into()).collect();
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+tuple_array_conversions">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/tuple_array_conversions.rs#L15">View Source</a></div></div></div></article><article id="type_complexity"><input id="label-type_complexity" type="checkbox"><label for="label-type_complexity"><h2 class="lint-title"><div class="panel-title-name" id="lint-type_complexity">type_complexity
<a href="#type_complexity" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for types used in structs, parameters and <code>let</code>
declarations above a certain complexity threshold.</p>
<h3>Why is this bad?</h3>
<p>Too complex types make the code less readable. Consider
using a <code>type</code> definition to simplify them.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct PointMatrixContainer {
    matrix: Rc&lt;Vec&lt;Vec&lt;Box&lt;(u32, u32, u32, u32)&gt;&gt;&gt;&gt;,
}

fn main() {
    let point_matrix: Vec&lt;Vec&lt;Box&lt;(u32, u32, u32, u32)&gt;&gt;&gt; = vec![
        vec![
            Box::new((1, 2, 3, 4)),
            Box::new((5, 6, 7, 8)),
        ],
        vec![
            Box::new((9, 10, 11, 12)),
        ],
    ];

    let shared_point_matrix: Rc&lt;Vec&lt;Vec&lt;Box&lt;(u32, u32, u32, u32)&gt;&gt;&gt;&gt; = Rc::new(point_matrix);

    let container = PointMatrixContainer {
        matrix: shared_point_matrix,
    };

    // ...
}
</code></pre>
<p>Use instead:</p>
<h3>Example</h3>
<pre><code class="language-rust">type PointMatrix = Vec&lt;Vec&lt;Box&lt;(u32, u32, u32, u32)&gt;&gt;&gt;;
type SharedPointMatrix = Rc&lt;PointMatrix&gt;;

struct PointMatrixContainer {
    matrix: SharedPointMatrix,
}

fn main() {
    let point_matrix: PointMatrix = vec![
        vec![
            Box::new((1, 2, 3, 4)),
            Box::new((5, 6, 7, 8)),
        ],
        vec![
            Box::new((9, 10, 11, 12)),
        ],
    ];

    let shared_point_matrix: SharedPointMatrix = Rc::new(point_matrix);

    let container = PointMatrixContainer {
        matrix: shared_point_matrix,
    };

    // ...
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>type-complexity-threshold</code>:  The maximum complexity a type can have</p>
<p>(default: <code>250</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+type_complexity">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/types/mod.rs#L249">View Source</a></div></div></div></article><article id="type_id_on_box"><input id="label-type_id_on_box" type="checkbox"><label for="label-type_id_on_box"><h2 class="lint-title"><div class="panel-title-name" id="lint-type_id_on_box">type_id_on_box
<a href="#type_id_on_box" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Looks for calls to <code>.type_id()</code> on a <code>Box&lt;dyn _&gt;</code>.</p>
<h3>Why is this bad?</h3>
<p>This almost certainly does not do what the user expects and can lead to subtle bugs.
Calling <code>.type_id()</code> on a <code>Box&lt;dyn Trait&gt;</code> returns a fixed <code>TypeId</code> of the <code>Box</code> itself,
rather than returning the <code>TypeId</code> of the underlying type behind the trait object.</p>
<p>For <code>Box&lt;dyn Any&gt;</code> specifically (and trait objects that have <code>Any</code> as its supertrait),
this lint will provide a suggestion, which is to dereference the receiver explicitly
to go from <code>Box&lt;dyn Any&gt;</code> to <code>dyn Any</code>.
This makes sure that <code>.type_id()</code> resolves to a dynamic call on the trait object
and not on the box.</p>
<p>If the fixed <code>TypeId</code> of the <code>Box</code> is the intended behavior, it’s better to be explicit about it
and write <code>TypeId::of::&lt;Box&lt;dyn Trait&gt;&gt;()</code>:
this makes it clear that a fixed <code>TypeId</code> is returned and not the <code>TypeId</code> of the implementor.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::any::{Any, TypeId};

let any_box: Box&lt;dyn Any&gt; = Box::new(42_i32);
assert_eq!(any_box.type_id(), TypeId::of::&lt;i32&gt;()); // ⚠️ this fails!
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::any::{Any, TypeId};

let any_box: Box&lt;dyn Any&gt; = Box::new(42_i32);
assert_eq!((*any_box).type_id(), TypeId::of::&lt;i32&gt;());
//          ^ dereference first, to call `type_id` on `dyn Any`
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.73.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+type_id_on_box">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3077">View Source</a></div></div></div></article><article id="type_repetition_in_bounds"><input id="label-type_repetition_in_bounds" type="checkbox"><label for="label-type_repetition_in_bounds"><h2 class="lint-title"><div class="panel-title-name" id="lint-type_repetition_in_bounds">type_repetition_in_bounds
<a href="#type_repetition_in_bounds" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint warns about unnecessary type repetitions in trait bounds</p>
<h3>Why is this bad?</h3>
<p>Repeating the type for every bound makes the code
less readable than combining the bounds</p>
<h3>Example</h3>
<pre><code class="language-rust">pub fn foo&lt;T&gt;(t: T) where T: Copy, T: Clone {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">pub fn foo&lt;T&gt;(t: T) where T: Copy + Clone {}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>max-trait-bounds</code>:  The maximum number of bounds a trait can have to be linted</p>
<p>(default: <code>3</code>)</p>
</li>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.38.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+type_repetition_in_bounds">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/trait_bounds.rs#L20">View Source</a></div></div></div></article><article id="unbuffered_bytes"><input id="label-unbuffered_bytes" type="checkbox"><label for="label-unbuffered_bytes"><h2 class="lint-title"><div class="panel-title-name" id="lint-unbuffered_bytes">unbuffered_bytes
<a href="#unbuffered_bytes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>Read::bytes</code> on types which don’t implement <code>BufRead</code>.</p>
<h3>Why is this bad?</h3>
<p>The default implementation calls <code>read</code> for each byte, which can be very inefficient for data that’s not in memory, such as <code>File</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::io::Read;
use std::fs::File;
let file = File::open("./bytes.txt").unwrap();
file.bytes();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::io::{BufReader, Read};
use std::fs::File;
let file = BufReader::new(File::open("./bytes.txt").unwrap());
file.bytes();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.87.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unbuffered_bytes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4497">View Source</a></div></div></div></article><article id="unchecked_time_subtraction"><input id="label-unchecked_time_subtraction" type="checkbox"><label for="label-unchecked_time_subtraction"><h2 class="lint-title"><div class="panel-title-name" id="lint-unchecked_time_subtraction">unchecked_time_subtraction
<a href="#unchecked_time_subtraction" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Lints subtraction between an <code>Instant</code> and a <code>Duration</code>, or between two <code>Duration</code> values.</p>
<h3>Why is this bad?</h3>
<p>Unchecked subtraction could cause underflow on certain platforms, leading to
unintentional panics.</p>
<h3>Example</h3>
<pre><code class="language-rust">let time_passed = Instant::now() - Duration::from_secs(5);
let dur1 = Duration::from_secs(3);
let dur2 = Duration::from_secs(5);
let diff = dur1 - dur2;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let time_passed = Instant::now().checked_sub(Duration::from_secs(5));
let dur1 = Duration::from_secs(3);
let dur2 = Duration::from_secs(5);
let diff = dur1.checked_sub(dur2);
</code></pre>
<h3>Past names</h3>
<ul>
<li>unchecked_duration_subtraction</li>
</ul>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.67.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unchecked_time_subtraction">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/time_subtraction.rs#L41">View Source</a></div></div></div></article><article id="unconditional_recursion"><input id="label-unconditional_recursion" type="checkbox"><label for="label-unconditional_recursion"><h2 class="lint-title"><div class="panel-title-name" id="lint-unconditional_recursion">unconditional_recursion
<a href="#unconditional_recursion" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks that there isn’t an infinite recursion in trait
implementations.</p>
<h3>Why is this bad?</h3>
<p>Infinite recursion in trait implementation will either cause crashes
or result in an infinite loop, and it is hard to detect.</p>
<h3>Example</h3>
<pre><code class="language-rust">enum Foo {
    A,
    B,
}

impl PartialEq for Foo {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self == other // bad!
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[derive(PartialEq)]
enum Foo {
    A,
    B,
}
</code></pre>
<p>As an alternative, rewrite the logic without recursion:</p>
<pre><code class="language-rust">enum Foo {
    A,
    B,
}

impl PartialEq for Foo {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        matches!((self, other), (Foo::A, Foo::A) | (Foo::B, Foo::B))
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.77.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unconditional_recursion">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unconditional_recursion.rs#L21">View Source</a></div></div></div></article><article id="undocumented_unsafe_blocks"><input id="label-undocumented_unsafe_blocks" type="checkbox"><label for="label-undocumented_unsafe_blocks"><h2 class="lint-title"><div class="panel-title-name" id="lint-undocumented_unsafe_blocks">undocumented_unsafe_blocks
<a href="#undocumented_unsafe_blocks" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>unsafe</code> blocks and impls without a <code>// SAFETY: </code> comment
explaining why the unsafe operations performed inside
the block are safe.</p>
<p>Note the comment must appear on the line(s) preceding the unsafe block
with nothing appearing in between. The following is ok:</p>
<pre><code class="language-rust">foo(
    // SAFETY:
    // This is a valid safety comment
    unsafe { *x }
)
</code></pre>
<p>But neither of these are:</p>
<pre><code class="language-rust">// SAFETY:
// This is not a valid safety comment
foo(
    /* SAFETY: Neither is this */ unsafe { *x },
);
</code></pre>
<h3>Why restrict this?</h3>
<p>Undocumented unsafe blocks and impls can make it difficult to read and maintain code.
Writing out the safety justification may help in discovering unsoundness or bugs.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::ptr::NonNull;
let a = &amp;mut 42;

let ptr = unsafe { NonNull::new_unchecked(a) };
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::ptr::NonNull;
let a = &amp;mut 42;

// SAFETY: references are guaranteed to be non-null.
let ptr = unsafe { NonNull::new_unchecked(a) };
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>accept-comment-above-attributes</code>:  Whether to accept a safety comment to be placed above the attributes for the <code>unsafe</code> block</p>
<p>(default: <code>true</code>)</p>
</li>
<li>
<p><code>accept-comment-above-statement</code>:  Whether to accept a safety comment to be placed above the statement containing the <code>unsafe</code> block</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.58.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+undocumented_unsafe_blocks">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/undocumented_unsafe_blocks.rs#L18">View Source</a></div></div></div></article><article id="unicode_not_nfc"><input id="label-unicode_not_nfc" type="checkbox"><label for="label-unicode_not_nfc"><h2 class="lint-title"><div class="panel-title-name" id="lint-unicode_not_nfc">unicode_not_nfc
<a href="#unicode_not_nfc" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for string literals that contain Unicode in a form
that is not equal to its
<a href="http://www.unicode.org/reports/tr15/#Norm_Forms">NFC-recomposition</a>.</p>
<h3>Why is this bad?</h3>
<p>If such a string is compared to another, the results
may be surprising.</p>
<h3>Example</h3>
<p>You may not see it, but “à”“ and “à”“ aren’t the same string. The
former when escaped is actually <code>"a\u{300}"</code> while the latter is <code>"\u{e0}"</code>.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unicode_not_nfc">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unicode.rs#L56">View Source</a></div></div></div></article><article id="unimplemented"><input id="label-unimplemented" type="checkbox"><label for="label-unimplemented"><h2 class="lint-title"><div class="panel-title-name" id="lint-unimplemented">unimplemented
<a href="#unimplemented" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>unimplemented!</code>.</p>
<h3>Why restrict this?</h3>
<p>This macro, or panics in general, may be unwanted in production code.</p>
<h3>Example</h3>
<pre><code class="language-rust">unimplemented!();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unimplemented">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/panic_unimplemented.rs#L40">View Source</a></div></div></div></article><article id="uninhabited_references"><input id="label-uninhabited_references" type="checkbox"><label for="label-uninhabited_references"><h2 class="lint-title"><div class="panel-title-name" id="lint-uninhabited_references">uninhabited_references
<a href="#uninhabited_references" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>It detects references to uninhabited types, such as <code>!</code> and
warns when those are either dereferenced or returned from a function.</p>
<h3>Why is this bad?</h3>
<p>Dereferencing a reference to an uninhabited type would create
an instance of such a type, which cannot exist. This constitutes
undefined behaviour. Such a reference could have been created
by <code>unsafe</code> code.</p>
<h3>Example</h3>
<p>The following function can return a reference to an uninhabited type
(<code>Infallible</code>) because it uses <code>unsafe</code> code to create it. However,
the user of such a function could dereference the return value and
trigger an undefined behavior from safe code.</p>
<pre><code class="language-rust">fn create_ref() -&gt; &amp;'static std::convert::Infallible {
    unsafe { std::mem::transmute(&amp;()) }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.76.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+uninhabited_references">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/uninhabited_references.rs#L10">View Source</a></div></div></div></article><article id="uninit_assumed_init"><input id="label-uninit_assumed_init" type="checkbox"><label for="label-uninit_assumed_init"><h2 class="lint-title"><div class="panel-title-name" id="lint-uninit_assumed_init">uninit_assumed_init
<a href="#uninit_assumed_init" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>MaybeUninit::uninit().assume_init()</code>.</p>
<h3>Why is this bad?</h3>
<p>For most types, this is undefined behavior.</p>
<h3>Known problems</h3>
<p>For now, we accept empty tuples and tuples / arrays
of <code>MaybeUninit</code>. There may be other types that allow uninitialized
data, but those are not yet rigorously defined.</p>
<h3>Example</h3>
<pre><code class="language-rust">// Beware the UB
use std::mem::MaybeUninit;

let _: usize = unsafe { MaybeUninit::uninit().assume_init() };
</code></pre>
<p>Note that the following is OK:</p>
<pre><code class="language-rust">use std::mem::MaybeUninit;

let _: [MaybeUninit&lt;bool&gt;; 5] = unsafe {
    MaybeUninit::uninit().assume_init()
};
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.39.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+uninit_assumed_init">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1650">View Source</a></div></div></div></article><article id="uninit_vec"><input id="label-uninit_vec" type="checkbox"><label for="label-uninit_vec"><h2 class="lint-title"><div class="panel-title-name" id="lint-uninit_vec">uninit_vec
<a href="#uninit_vec" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>set_len()</code> call that creates <code>Vec</code> with uninitialized elements.
This is commonly caused by calling <code>set_len()</code> right after allocating or
reserving a buffer with <code>new()</code>, <code>default()</code>, <code>with_capacity()</code>, or <code>reserve()</code>.</p>
<h3>Why is this bad?</h3>
<p>It creates a <code>Vec</code> with uninitialized data, which leads to
undefined behavior with most safe operations. Notably, uninitialized
<code>Vec&lt;u8&gt;</code> must not be used with generic <code>Read</code>.</p>
<p>Moreover, calling <code>set_len()</code> on a <code>Vec</code> created with <code>new()</code> or <code>default()</code>
creates out-of-bound values that lead to heap memory corruption when used.</p>
<h3>Known Problems</h3>
<p>This lint only checks directly adjacent statements.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut vec: Vec&lt;u8&gt; = Vec::with_capacity(1000);
unsafe { vec.set_len(1000); }
reader.read(&amp;mut vec); // undefined behavior!
</code></pre>
<h3>How to fix?</h3>
<ol>
<li>Use an initialized buffer:
<pre><code class="language-rust,ignore">let mut vec: Vec&lt;u8&gt; = vec![0; 1000];
reader.read(&amp;mut vec);
</code></pre>
</li>
<li>Wrap the content in <code>MaybeUninit</code>:
<pre><code class="language-rust,ignore">let mut vec: Vec&lt;MaybeUninit&lt;T&gt;&gt; = Vec::with_capacity(1000);
vec.set_len(1000);  // `MaybeUninit` can be uninitialized
</code></pre>
</li>
<li>If you are on 1.60.0 or later, <code>Vec::spare_capacity_mut()</code> is available:
<pre><code class="language-rust,ignore">let mut vec: Vec&lt;u8&gt; = Vec::with_capacity(1000);
let remaining = vec.spare_capacity_mut();  // `&amp;mut [MaybeUninit&lt;u8&gt;]`
// perform initialization with `remaining`
vec.set_len(...);  // Safe to call `set_len()` on initialized part
</code></pre>
</li>
</ol>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.58.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+uninit_vec">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/uninit_vec.rs#L13">View Source</a></div></div></div></article><article id="uninlined_format_args"><input id="label-uninlined_format_args" type="checkbox"><label for="label-uninlined_format_args"><h2 class="lint-title"><div class="panel-title-name" id="lint-uninlined_format_args">uninlined_format_args
<a href="#uninlined_format_args" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detect when a variable is not inlined in a format string,
and suggests to inline it.</p>
<h3>Why is this bad?</h3>
<p>Non-inlined code is slightly more difficult to read and understand,
as it requires arguments to be matched against the format string.
The inlined syntax, where allowed, is simpler.</p>
<h3>Example</h3>
<pre><code class="language-rust">format!("{}", var);
format!("{:?}", var);
format!("{v:?}", v = var);
format!("{0} {0}", var);
format!("{0:1$}", var, width);
format!("{:.*}", prec, var);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">format!("{var}");
format!("{var:?}");
format!("{var:?}");
format!("{var} {var}");
format!("{var:width$}");
format!("{var:.prec$}");
</code></pre>
<p>If <code>allow-mixed-uninlined-format-args</code> is set to <code>false</code> in clippy.toml,
the following code will also trigger the lint:</p>
<pre><code class="language-rust">format!("{} {}", var, 1+2);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">format!("{var} {}", 1+2);
</code></pre>
<h3>Known Problems</h3>
<p>If a format string contains a numbered argument that cannot be inlined
nothing will be suggested, e.g. <code>println!("{0}={1}", var, 1+2)</code>.</p>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allow-mixed-uninlined-format-args</code>:  Whether to allow mixed uninlined format args, e.g. <code>format!("{} {}", a, foo.bar)</code></p>
<p>(default: <code>true</code>)</p>
</li>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.66.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+uninlined_format_args">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/format_args.rs#L116">View Source</a></div></div></div></article><article id="unit_arg"><input id="label-unit_arg" type="checkbox"><label for="label-unit_arg"><h2 class="lint-title"><div class="panel-title-name" id="lint-unit_arg">unit_arg
<a href="#unit_arg" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for passing a unit value as an argument to a function without using a
unit literal (<code>()</code>).</p>
<h3>Why is this bad?</h3>
<p>This is likely the result of an accidental semicolon.</p>
<h3>Example</h3>
<pre><code class="language-rust">foo({
    let a = bar();
    baz(a);
})
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unit_arg">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unit_types/mod.rs#L79">View Source</a></div></div></div></article><article id="unit_cmp"><input id="label-unit_cmp" type="checkbox"><label for="label-unit_cmp"><h2 class="lint-title"><div class="panel-title-name" id="lint-unit_cmp">unit_cmp
<a href="#unit_cmp" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for comparisons to unit. This includes all binary
comparisons (like <code>==</code> and <code>&lt;</code>) and asserts.</p>
<h3>Why is this bad?</h3>
<p>Unit is always equal to itself, and thus is just a
clumsily written constant. Mostly this happens when someone accidentally
adds semicolons at the end of the operands.</p>
<h3>Example</h3>
<pre><code class="language-rust">if {
    foo();
} == {
    bar();
} {
    baz();
}
</code></pre>
<p>is equal to</p>
<pre><code class="language-rust">{
    foo();
    bar();
    baz();
}
</code></pre>
<p>For asserts:</p>
<pre><code class="language-rust">assert_eq!({ foo(); }, { bar(); });
</code></pre>
<p>will always succeed</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unit_cmp">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unit_types/mod.rs#L31">View Source</a></div></div></div></article><article id="unit_hash"><input id="label-unit_hash" type="checkbox"><label for="label-unit_hash"><h2 class="lint-title"><div class="panel-title-name" id="lint-unit_hash">unit_hash
<a href="#unit_hash" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects <code>().hash(_)</code>.</p>
<h3>Why is this bad?</h3>
<p>Hashing a unit value doesn’t do anything as the implementation of <code>Hash</code> for <code>()</code> is a no-op.</p>
<h3>Example</h3>
<pre><code class="language-rust">match my_enum {
	Empty =&gt; ().hash(&amp;mut state),
	WithValue(x) =&gt; x.hash(&amp;mut state),
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">match my_enum {
	Empty =&gt; 0_u8.hash(&amp;mut state),
	WithValue(x) =&gt; x.hash(&amp;mut state),
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.58.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unit_hash">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3117">View Source</a></div></div></div></article><article id="unit_return_expecting_ord"><input id="label-unit_return_expecting_ord" type="checkbox"><label for="label-unit_return_expecting_ord"><h2 class="lint-title"><div class="panel-title-name" id="lint-unit_return_expecting_ord">unit_return_expecting_ord
<a href="#unit_return_expecting_ord" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for functions that expect closures of type
Fn(…) -&gt; Ord where the implemented closure returns the unit type.
The lint also suggests to remove the semi-colon at the end of the statement if present.</p>
<h3>Why is this bad?</h3>
<p>Likely, returning the unit type is unintentional, and
could simply be caused by an extra semi-colon. Since () implements Ord
it doesn’t cause a compilation error.
This is the same reasoning behind the unit_cmp lint.</p>
<h3>Known problems</h3>
<p>If returning unit is intentional, then there is no
way of specifying this without triggering needless_return lint</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut twins = vec![(1, 1), (2, 2)];
twins.sort_by_key(|x| { x.1; });
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.47.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unit_return_expecting_ord">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unit_return_expecting_ord.rs#L10">View Source</a></div></div></div></article><article id="unnecessary_box_returns"><input id="label-unnecessary_box_returns" type="checkbox"><label for="label-unnecessary_box_returns"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_box_returns">unnecessary_box_returns
<a href="#unnecessary_box_returns" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for a return type containing a <code>Box&lt;T&gt;</code> where <code>T</code> implements <code>Sized</code></p>
<p>The lint ignores <code>Box&lt;T&gt;</code> where <code>T</code> is larger than <code>unnecessary_box_size</code>,
as returning a large <code>T</code> directly may be detrimental to performance.</p>
<h3>Why is this bad?</h3>
<p>It’s better to just return <code>T</code> in these cases. The caller may not need
the value to be boxed, and it’s expensive to free the memory once the
<code>Box&lt;T&gt;</code> been dropped.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo() -&gt; Box&lt;String&gt; {
    Box::new(String::from("Hello, world!"))
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo() -&gt; String {
    String::from("Hello, world!")
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
<li>
<p><code>unnecessary-box-size</code>:  The byte size a <code>T</code> in <code>Box&lt;T&gt;</code> can have, below which it triggers the <code>clippy::unnecessary_box</code> lint</p>
<p>(default: <code>128</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_box_returns">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unnecessary_box_returns.rs#L11">View Source</a></div></div></div></article><article id="unnecessary_cast"><input id="label-unnecessary_cast" type="checkbox"><label for="label-unnecessary_cast"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_cast">unnecessary_cast
<a href="#unnecessary_cast" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for casts to the same type, casts of int literals to integer
types, casts of float literals to float types, and casts between raw
pointers that don’t change type or constness.</p>
<h3>Why is this bad?</h3>
<p>It’s just unnecessary.</p>
<h3>Known problems</h3>
<p>When the expression on the left is a function call, the lint considers
the return type to be a type alias if it’s aliased through a <code>use</code>
statement (like <code>use std::io::Result as IoResult</code>). It will not lint
such cases.</p>
<p>This check will only work on primitive types without any intermediate
references: raw pointers and trait objects may or may not work.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = 2i32 as i32;
let _ = 0.5 as f32;
</code></pre>
<p>Better:</p>
<pre><code class="language-rust">let _ = 2_i32;
let _ = 0.5_f32;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_cast">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L187">View Source</a></div></div></div></article><article id="unnecessary_clippy_cfg"><input id="label-unnecessary_clippy_cfg" type="checkbox"><label for="label-unnecessary_clippy_cfg"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_clippy_cfg">unnecessary_clippy_cfg
<a href="#unnecessary_clippy_cfg" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>#[cfg_attr(clippy, allow(clippy::lint))]</code>
and suggests to replace it with <code>#[allow(clippy::lint)]</code>.</p>
<h3>Why is this bad?</h3>
<p>There is no reason to put clippy attributes behind a clippy <code>cfg</code> as they are not
run by anything else than clippy.</p>
<h3>Example</h3>
<pre><code class="language-rust">#![cfg_attr(clippy, allow(clippy::deprecated_cfg_attr))]
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#![allow(clippy::deprecated_cfg_attr)]
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.78.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_clippy_cfg">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/attrs/mod.rs#L365">View Source</a></div></div></div></article><article id="unnecessary_debug_formatting"><input id="label-unnecessary_debug_formatting" type="checkbox"><label for="label-unnecessary_debug_formatting"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_debug_formatting">unnecessary_debug_formatting
<a href="#unnecessary_debug_formatting" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>Debug</code> formatting (<code>{:?}</code>) applied to an <code>OsStr</code> or <code>Path</code>.</p>
<h3>Why is this bad?</h3>
<p>Rust doesn’t guarantee what <code>Debug</code> formatting looks like, and it could
change in the future. <code>OsStr</code>s and <code>Path</code>s can be <code>Display</code> formatted
using their <code>display</code> methods.</p>
<p>Furthermore, with <code>Debug</code> formatting, certain characters are escaped.
Thus, a <code>Debug</code> formatted <code>Path</code> is less likely to be clickable.</p>
<h3>Example</h3>
<pre><code class="language-rust">let path = Path::new("...");
println!("The path is {:?}", path);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let path = Path::new("…");
println!("The path is {}", path.display());
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.87.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_debug_formatting">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/format_args.rs#L60">View Source</a></div></div></div></article><article id="unnecessary_fallible_conversions"><input id="label-unnecessary_fallible_conversions" type="checkbox"><label for="label-unnecessary_fallible_conversions"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_fallible_conversions">unnecessary_fallible_conversions
<a href="#unnecessary_fallible_conversions" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>TryInto::try_into</code> and <code>TryFrom::try_from</code> when their infallible counterparts
could be used.</p>
<h3>Why is this bad?</h3>
<p>In those cases, the <code>TryInto</code> and <code>TryFrom</code> trait implementation is a blanket impl that forwards
to <code>Into</code> or <code>From</code>, which always succeeds.
The returned <code>Result&lt;_, Infallible&gt;</code> requires error handling to get the contained value
even though the conversion can never fail.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _: Result&lt;i64, _&gt; = 1i32.try_into();
let _: Result&lt;i64, _&gt; = &lt;_&gt;::try_from(1i32);
</code></pre>
<p>Use <code>from</code>/<code>into</code> instead:</p>
<pre><code class="language-rust">let _: i64 = 1i32.into();
let _: i64 = &lt;_&gt;::from(1i32);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.75.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_fallible_conversions">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3796">View Source</a></div></div></div></article><article id="unnecessary_filter_map"><input id="label-unnecessary_filter_map" type="checkbox"><label for="label-unnecessary_filter_map"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_filter_map">unnecessary_filter_map
<a href="#unnecessary_filter_map" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>filter_map</code> calls that could be replaced by <code>filter</code> or <code>map</code>.
More specifically it checks if the closure provided is only performing one of the
filter or map operations and suggests the appropriate option.</p>
<h3>Why is this bad?</h3>
<p>Complexity. The intent is also clearer if only a single
operation is being performed.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = (0..3).filter_map(|x| if x &gt; 2 { Some(x) } else { None });

// As there is no transformation of the argument this could be written as:
let _ = (0..3).filter(|&amp;x| x &gt; 2);
</code></pre>
<pre><code class="language-rust">let _ = (0..4).filter_map(|x| Some(x + 1));

// As there is no conditional check on the argument this could be written as:
let _ = (0..4).map(|x| x + 1);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.31.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_filter_map">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1543">View Source</a></div></div></div></article><article id="unnecessary_find_map"><input id="label-unnecessary_find_map" type="checkbox"><label for="label-unnecessary_find_map"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_find_map">unnecessary_find_map
<a href="#unnecessary_find_map" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>find_map</code> calls that could be replaced by <code>find</code> or <code>map</code>. More
specifically it checks if the closure provided is only performing one of the
find or map operations and suggests the appropriate option.</p>
<h3>Why is this bad?</h3>
<p>Complexity. The intent is also clearer if only a single
operation is being performed.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = (0..3).find_map(|x| if x &gt; 2 { Some(x) } else { None });

// As there is no transformation of the argument this could be written as:
let _ = (0..3).find(|&amp;x| x &gt; 2);
</code></pre>
<pre><code class="language-rust">let _ = (0..4).find_map(|x| Some(x + 1));

// As there is no conditional check on the argument this could be written as:
let _ = (0..4).map(|x| x + 1).next();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.61.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_find_map">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1573">View Source</a></div></div></div></article><article id="unnecessary_first_then_check"><input id="label-unnecessary_first_then_check" type="checkbox"><label for="label-unnecessary_first_then_check"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_first_then_check">unnecessary_first_then_check
<a href="#unnecessary_first_then_check" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks the usage of <code>.first().is_some()</code> or <code>.first().is_none()</code> to check if a slice is
empty.</p>
<h3>Why is this bad?</h3>
<p>Using <code>.is_empty()</code> is shorter and better communicates the intention.</p>
<h3>Example</h3>
<pre><code class="language-rust">let v = vec![1, 2, 3];
if v.first().is_none() {
    // The vector is empty...
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let v = vec![1, 2, 3];
if v.is_empty() {
    // The vector is empty...
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.83.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_first_then_check">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4242">View Source</a></div></div></div></article><article id="unnecessary_fold"><input id="label-unnecessary_fold" type="checkbox"><label for="label-unnecessary_fold"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_fold">unnecessary_fold
<a href="#unnecessary_fold" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>fold</code> when a more succinct alternative exists.
Specifically, this checks for <code>fold</code>s which could be replaced by <code>any</code>, <code>all</code>,
<code>sum</code> or <code>product</code>.</p>
<h3>Why is this bad?</h3>
<p>Readability.</p>
<h3>Example</h3>
<pre><code class="language-rust">(0..3).fold(false, |acc, x| acc || x &gt; 2);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">(0..3).any(|x| x &gt; 2);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_fold">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1519">View Source</a></div></div></div></article><article id="unnecessary_get_then_check"><input id="label-unnecessary_get_then_check" type="checkbox"><label for="label-unnecessary_get_then_check"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_get_then_check">unnecessary_get_then_check
<a href="#unnecessary_get_then_check" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks the usage of <code>.get().is_some()</code> or <code>.get().is_none()</code> on std map types.</p>
<h3>Why is this bad?</h3>
<p>It can be done in one call with <code>.contains()</code>/<code>.contains_key()</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let s: HashSet&lt;String&gt; = HashSet::new();
if s.get("a").is_some() {
    // code
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let s: HashSet&lt;String&gt; = HashSet::new();
if s.contains("a") {
    // code
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.78.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_get_then_check">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4110">View Source</a></div></div></div></article><article id="unnecessary_join"><input id="label-unnecessary_join" type="checkbox"><label for="label-unnecessary_join"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_join">unnecessary_join
<a href="#unnecessary_join" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.collect::&lt;Vec&lt;String&gt;&gt;().join("")</code> on iterators.</p>
<h3>Why is this bad?</h3>
<p><code>.collect::&lt;String&gt;()</code> is more concise and might be more performant</p>
<h3>Example</h3>
<pre><code class="language-rust">let vector = vec!["hello",  "world"];
let output = vector.iter().map(|item| item.to_uppercase()).collect::&lt;Vec&lt;String&gt;&gt;().join("");
println!("{}", output);
</code></pre>
<p>The correct use would be:</p>
<pre><code class="language-rust">let vector = vec!["hello",  "world"];
let output = vector.iter().map(|item| item.to_uppercase()).collect::&lt;String&gt;();
println!("{}", output);
</code></pre>
<h3>Known problems</h3>
<p>While <code>.collect::&lt;String&gt;()</code> is sometimes more performant, there are cases where
using <code>.collect::&lt;String&gt;()</code> over <code>.collect::&lt;Vec&lt;String&gt;&gt;().join("")</code>
will prevent loop unrolling and will result in a negative performance impact.</p>
<p>Additionally, differences have been observed between aarch64 and x86_64 assembly output,
with aarch64 tending to producing faster assembly in more cases when using <code>.collect::&lt;String&gt;()</code></p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.61.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_join">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2371">View Source</a></div></div></div></article><article id="unnecessary_lazy_evaluations"><input id="label-unnecessary_lazy_evaluations" type="checkbox"><label for="label-unnecessary_lazy_evaluations"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_lazy_evaluations">unnecessary_lazy_evaluations
<a href="#unnecessary_lazy_evaluations" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>As the counterpart to <code>or_fun_call</code>, this lint looks for unnecessary
lazily evaluated closures on <code>Option</code> and <code>Result</code>.</p>
<p>This lint suggests changing the following functions, when eager evaluation results in
simpler code:</p>
<ul>
<li><code>unwrap_or_else</code> to <code>unwrap_or</code></li>
<li><code>and_then</code> to <code>and</code></li>
<li><code>or_else</code> to <code>or</code></li>
<li><code>get_or_insert_with</code> to <code>get_or_insert</code></li>
<li><code>ok_or_else</code> to <code>ok_or</code></li>
<li><code>then</code> to <code>then_some</code> (for msrv &gt;= 1.62.0)</li>
</ul>
<h3>Why is this bad?</h3>
<p>Using eager evaluation is shorter and simpler in some cases.</p>
<h3>Known problems</h3>
<p>It is possible, but not recommended for <code>Deref</code> and <code>Index</code> to have
side effects. Eagerly evaluating them can change the semantics of the program.</p>
<h3>Example</h3>
<pre><code class="language-rust">let opt: Option&lt;u32&gt; = None;

opt.unwrap_or_else(|| 42);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let opt: Option&lt;u32&gt; = None;

opt.unwrap_or(42);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.48.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_lazy_evaluations">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1925">View Source</a></div></div></div></article><article id="unnecessary_literal_bound"><input id="label-unnecessary_literal_bound" type="checkbox"><label for="label-unnecessary_literal_bound"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_literal_bound">unnecessary_literal_bound
<a href="#unnecessary_literal_bound" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects functions that are written to return <code>&amp;str</code> that could return <code>&amp;'static str</code> but instead return a <code>&amp;'a str</code>.</p>
<h3>Why is this bad?</h3>
<p>This leaves the caller unable to use the <code>&amp;str</code> as <code>&amp;'static str</code>, causing unnecessary allocations or confusion.
This is also most likely what you meant to write.</p>
<h3>Example</h3>
<pre><code class="language-rust">impl MyType {
    fn returns_literal(&amp;self) -&gt; &amp;str {
        "Literal"
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">impl MyType {
    fn returns_literal(&amp;self) -&gt; &amp;'static str {
        "Literal"
    }
}
</code></pre>
<p>Or, in case you may return a non-literal <code>str</code> in future:</p>
<pre><code class="language-rust">impl MyType {
    fn returns_literal&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str {
        "Literal"
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.84.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_literal_bound">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unnecessary_literal_bound.rs#L13">View Source</a></div></div></div></article><article id="unnecessary_literal_unwrap"><input id="label-unnecessary_literal_unwrap" type="checkbox"><label for="label-unnecessary_literal_unwrap"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_literal_unwrap">unnecessary_literal_unwrap
<a href="#unnecessary_literal_unwrap" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>.unwrap()</code> related calls on <code>Result</code>s and <code>Option</code>s that are constructed.</p>
<h3>Why is this bad?</h3>
<p>It is better to write the value directly without the indirection.</p>
<h3>Examples</h3>
<pre><code class="language-rust">let val1 = Some(1).unwrap();
let val2 = Ok::&lt;_, ()&gt;(1).unwrap();
let val3 = Err::&lt;(), _&gt;(1).unwrap_err();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let val1 = 1;
let val2 = 1;
let val3 = 1;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.72.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_literal_unwrap">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L323">View Source</a></div></div></div></article><article id="unnecessary_map_on_constructor"><input id="label-unnecessary_map_on_constructor" type="checkbox"><label for="label-unnecessary_map_on_constructor"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_map_on_constructor">unnecessary_map_on_constructor
<a href="#unnecessary_map_on_constructor" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Suggests removing the use of a <code>map()</code> (or <code>map_err()</code>) method when an <code>Option</code> or <code>Result</code>
is being constructed.</p>
<h3>Why is this bad?</h3>
<p>It introduces unnecessary complexity. Instead, the function can be called before
constructing the <code>Option</code> or <code>Result</code> from its return value.</p>
<h3>Example</h3>
<pre><code class="language-rust">Some(4).map(i32::swap_bytes)
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">Some(i32::swap_bytes(4))
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.74.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_map_on_constructor">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unnecessary_map_on_constructor.rs#L10">View Source</a></div></div></div></article><article id="unnecessary_map_or"><input id="label-unnecessary_map_or" type="checkbox"><label for="label-unnecessary_map_or"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_map_or">unnecessary_map_or
<a href="#unnecessary_map_or" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Converts some constructs mapping an Enum value for equality comparison.</p>
<h3>Why is this bad?</h3>
<p>Calls such as <code>opt.map_or(false, |val| val == 5)</code> are needlessly long and cumbersome,
and can be reduced to, for example, <code>opt == Some(5)</code> assuming <code>opt</code> implements <code>PartialEq</code>.
Also, calls such as <code>opt.map_or(true, |val| val == 5)</code> can be reduced to
<code>opt.is_none_or(|val| val == 5)</code>.
This lint offers readability and conciseness improvements.</p>
<h3>Example</h3>
<pre><code class="language-rust">pub fn a(x: Option&lt;i32&gt;) -&gt; (bool, bool) {
    (
        x.map_or(false, |n| n == 5),
        x.map_or(true, |n| n &gt; 5),
    )
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">pub fn a(x: Option&lt;i32&gt;) -&gt; (bool, bool) {
    (
        x == Some(5),
        x.is_none_or(|n| n &gt; 5),
    )
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.84.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_map_or">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4165">View Source</a></div></div></div></article><article id="unnecessary_min_or_max"><input id="label-unnecessary_min_or_max" type="checkbox"><label for="label-unnecessary_min_or_max"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_min_or_max">unnecessary_min_or_max
<a href="#unnecessary_min_or_max" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for unnecessary calls to <code>min()</code> or <code>max()</code> in the following cases</p>
<ul>
<li>Either both side is constant</li>
<li>One side is clearly larger than the other, like i32::MIN and an i32 variable</li>
</ul>
<h3>Why is this bad?</h3>
<p>In the aforementioned cases it is not necessary to call <code>min()</code> or <code>max()</code>
to compare values, it may even cause confusion.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _ = 0.min(7_u32);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = 0;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.81.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_min_or_max">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4026">View Source</a></div></div></div></article><article id="unnecessary_mut_passed"><input id="label-unnecessary_mut_passed" type="checkbox"><label for="label-unnecessary_mut_passed"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_mut_passed">unnecessary_mut_passed
<a href="#unnecessary_mut_passed" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects passing a mutable reference to a function that only
requires an immutable reference.</p>
<h3>Why is this bad?</h3>
<p>The mutable reference rules out all other references to
the value. Also the code misleads about the intent of the call site.</p>
<h3>Example</h3>
<pre><code class="language-rust">vec.push(&amp;mut value);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">vec.push(&amp;value);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_mut_passed">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unnecessary_mut_passed.rs#L10">View Source</a></div></div></div></article><article id="unnecessary_operation"><input id="label-unnecessary_operation" type="checkbox"><label for="label-unnecessary_operation"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_operation">unnecessary_operation
<a href="#unnecessary_operation" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for expression statements that can be reduced to a
sub-expression.</p>
<h3>Why is this bad?</h3>
<p>Expressions by themselves often have no side-effects.
Having such expressions reduces readability.</p>
<h3>Example</h3>
<pre><code class="language-rust">compute_array()[0];
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_operation">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/no_effect.rs#L57">View Source</a></div></div></div></article><article id="unnecessary_option_map_or_else"><input id="label-unnecessary_option_map_or_else" type="checkbox"><label for="label-unnecessary_option_map_or_else"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_option_map_or_else">unnecessary_option_map_or_else
<a href="#unnecessary_option_map_or_else" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><p>Checks for usage of <code>.map_or_else()</code> “map closure” for <code>Option</code> type.</p>
<h3>Why is this bad?</h3>
<p>This can be written more concisely by using <code>unwrap_or_else()</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let k = 10;
let x: Option&lt;u32&gt; = Some(4);
let y = x.map_or_else(|| 2 * k, |n| n);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let k = 10;
let x: Option&lt;u32&gt; = Some(4);
let y = x.unwrap_or_else(|| 2 * k);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.92.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_option_map_or_else">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4679">View Source</a></div></div></div></article><article id="unnecessary_owned_empty_strings"><input id="label-unnecessary_owned_empty_strings" type="checkbox"><label for="label-unnecessary_owned_empty_strings"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_owned_empty_strings">unnecessary_owned_empty_strings
<a href="#unnecessary_owned_empty_strings" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects cases of owned empty strings being passed as an argument to a function expecting <code>&amp;str</code></p>
<h3>Why is this bad?</h3>
<p>This results in longer and less readable code</p>
<h3>Example</h3>
<pre><code class="language-rust">vec!["1", "2", "3"].join(&amp;String::new());
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">vec!["1", "2", "3"].join("");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.62.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_owned_empty_strings">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unnecessary_owned_empty_strings.rs#L11">View Source</a></div></div></div></article><article id="unnecessary_result_map_or_else"><input id="label-unnecessary_result_map_or_else" type="checkbox"><label for="label-unnecessary_result_map_or_else"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_result_map_or_else">unnecessary_result_map_or_else
<a href="#unnecessary_result_map_or_else" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.map_or_else()</code> “map closure” for <code>Result</code> type.</p>
<h3>Why is this bad?</h3>
<p>This can be written more concisely by using <code>unwrap_or_else()</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: Result&lt;u32, ()&gt; = Ok(0);
let y = x.map_or_else(|err| handle_error(err), |n| n);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x: Result&lt;u32, ()&gt; = Ok(0);
let y = x.unwrap_or_else(|err| handle_error(err));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.78.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_result_map_or_else">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4051">View Source</a></div></div></div></article><article id="unnecessary_safety_comment"><input id="label-unnecessary_safety_comment" type="checkbox"><label for="label-unnecessary_safety_comment"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_safety_comment">unnecessary_safety_comment
<a href="#unnecessary_safety_comment" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>// SAFETY: </code> comments on safe code.</p>
<h3>Why restrict this?</h3>
<p>Safe code has no safety requirements, so there is no need to
describe safety invariants.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::ptr::NonNull;
let a = &amp;mut 42;

// SAFETY: references are guaranteed to be non-null.
let ptr = NonNull::new(a).unwrap();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::ptr::NonNull;
let a = &amp;mut 42;

let ptr = NonNull::new(a).unwrap();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.67.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_safety_comment">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/undocumented_unsafe_blocks.rs#L66">View Source</a></div></div></div></article><article id="unnecessary_safety_doc"><input id="label-unnecessary_safety_doc" type="checkbox"><label for="label-unnecessary_safety_doc"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_safety_doc">unnecessary_safety_doc
<a href="#unnecessary_safety_doc" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the doc comments of publicly visible
safe functions and traits and warns if there is a <code># Safety</code> section.</p>
<h3>Why restrict this?</h3>
<p>Safe functions and traits are safe to implement and therefore do not
need to describe safety preconditions that users are required to uphold.</p>
<h3>Examples</h3>
<pre><code class="language-rust">/// # Safety
///
/// This function should not be called before the horsemen are ready.
pub fn start_apocalypse_but_safely(u: &amp;mut Universe) {
    unimplemented!();
}
</code></pre>
<p>The function is safe, so there shouldn’t be any preconditions
that have to be explained for safety reasons.</p>
<pre><code class="language-rust">/// This function should really be documented
pub fn start_apocalypse(u: &amp;mut Universe) {
    unimplemented!();
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>check-private-items</code>:  Whether to also run the listed lints on private items.</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.67.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_safety_doc">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/doc/mod.rs#L327">View Source</a></div></div></div></article><article id="unnecessary_self_imports"><input id="label-unnecessary_self_imports" type="checkbox"><label for="label-unnecessary_self_imports"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_self_imports">unnecessary_self_imports
<a href="#unnecessary_self_imports" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for imports ending in <code>::{self}</code>.</p>
<h3>Why restrict this?</h3>
<p>In most cases, this can be written much more cleanly by omitting <code>::{self}</code>.</p>
<h3>Known problems</h3>
<p>Removing <code>::{self}</code> will cause any non-module items at the same path to also be imported.
This might cause a naming conflict (https://github.com/rust-lang/rustfmt/issues/3568). This lint makes no attempt
to detect this scenario and that is why it is a restriction lint.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::io::{self};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::io;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.53.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_self_imports">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unnecessary_self_imports.rs#L8">View Source</a></div></div></div></article><article id="unnecessary_semicolon"><input id="label-unnecessary_semicolon" type="checkbox"><label for="label-unnecessary_semicolon"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_semicolon">unnecessary_semicolon
<a href="#unnecessary_semicolon" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the presence of a semicolon at the end of
a <code>match</code> or <code>if</code> statement evaluating to <code>()</code>.</p>
<h3>Why is this bad?</h3>
<p>The semicolon is not needed, and may be removed to
avoid confusion and visual clutter.</p>
<h3>Example</h3>
<pre><code class="language-rust">if a &gt; 10 {
    println!("a is greater than 10");
};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if a &gt; 10 {
    println!("a is greater than 10");
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.86.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_semicolon">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unnecessary_semicolon.rs#L9">View Source</a></div></div></div></article><article id="unnecessary_sort_by"><input id="label-unnecessary_sort_by" type="checkbox"><label for="label-unnecessary_sort_by"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_sort_by">unnecessary_sort_by
<a href="#unnecessary_sort_by" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>Vec::sort_by</code> passing in a closure
which compares the two arguments, either directly or indirectly.</p>
<h3>Why is this bad?</h3>
<p>It is more clear to use <code>Vec::sort_by_key</code> (or <code>Vec::sort</code> if
possible) than to use <code>Vec::sort_by</code> and a more complicated
closure.</p>
<h3>Known problems</h3>
<p>If the suggested <code>Vec::sort_by_key</code> uses Reverse and it isn’t already
imported by a use statement, then it will need to be added manually.</p>
<h3>Example</h3>
<pre><code class="language-rust">vec.sort_by(|a, b| a.foo().cmp(&amp;b.foo()));
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">vec.sort_by_key(|a| a.foo());
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.46.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_sort_by">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3156">View Source</a></div></div></div></article><article id="unnecessary_struct_initialization"><input id="label-unnecessary_struct_initialization" type="checkbox"><label for="label-unnecessary_struct_initialization"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_struct_initialization">unnecessary_struct_initialization
<a href="#unnecessary_struct_initialization" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for initialization of an identical <code>struct</code> from another instance
of the type, either by copying a base without setting any field or by
moving all fields individually.</p>
<h3>Why is this bad?</h3>
<p>Readability suffers from unnecessary struct building.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct S { s: String }

let a = S { s: String::from("Hello, world!") };
let b = S { ..a };
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct S { s: String }

let a = S { s: String::from("Hello, world!") };
let b = a;
</code></pre>
<p>The struct literal <code>S { ..a }</code> in the assignment to <code>b</code> could be replaced
with just <code>a</code>.</p>
<h3>Known Problems</h3>
<p>Has false positives when the base is a place expression that cannot be
moved out of, see <a href="https://github.com/rust-lang/rust-clippy/issues/10547">#10547</a>.</p>
<p>Empty structs are ignored by the lint.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.70.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_struct_initialization">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unnecessary_struct_initialization.rs#L11">View Source</a></div></div></div></article><article id="unnecessary_to_owned"><input id="label-unnecessary_to_owned" type="checkbox"><label for="label-unnecessary_to_owned"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_to_owned">unnecessary_to_owned
<a href="#unnecessary_to_owned" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for unnecessary calls to <a href="https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned"><code>ToOwned::to_owned</code></a>
and other <code>to_owned</code>-like functions.</p>
<h3>Why is this bad?</h3>
<p>The unnecessary calls result in useless allocations.</p>
<h3>Known problems</h3>
<p><code>unnecessary_to_owned</code> can falsely trigger if <code>IntoIterator::into_iter</code> is applied to an
owned copy of a resource and the resource is later used mutably. See
<a href="https://github.com/rust-lang/rust-clippy/issues/8148">#8148</a>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let path = std::path::Path::new("x");
foo(&amp;path.to_string_lossy().to_string());
fn foo(s: &amp;str) {}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let path = std::path::Path::new("x");
foo(&amp;path.to_string_lossy());
fn foo(s: &amp;str) {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.59.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_to_owned">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L2340">View Source</a></div></div></div></article><article id="unnecessary_unwrap"><input id="label-unnecessary_unwrap" type="checkbox"><label for="label-unnecessary_unwrap"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_unwrap">unnecessary_unwrap
<a href="#unnecessary_unwrap" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls of <code>unwrap[_err]()</code> that cannot fail.</p>
<h3>Why is this bad?</h3>
<p>Using <code>if let</code> or <code>match</code> is more idiomatic.</p>
<h3>Example</h3>
<pre><code class="language-rust">if option.is_some() {
    do_something_with(option.unwrap())
}
</code></pre>
<p>Could be written:</p>
<pre><code class="language-rust">if let Some(value) = option {
    do_something_with(value)
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_unwrap">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unwrap.rs#L25">View Source</a></div></div></div></article><article id="unnecessary_wraps"><input id="label-unnecessary_wraps" type="checkbox"><label for="label-unnecessary_wraps"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnecessary_wraps">unnecessary_wraps
<a href="#unnecessary_wraps" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for private functions that only return <code>Ok</code> or <code>Some</code>.</p>
<h3>Why is this bad?</h3>
<p>It is not meaningful to wrap values when no <code>None</code> or <code>Err</code> is returned.</p>
<h3>Known problems</h3>
<p>There can be false positives if the function signature is designed to
fit some external requirement.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn get_cool_number(a: bool, b: bool) -&gt; Option&lt;i32&gt; {
    if a &amp;&amp; b {
        return Some(50);
    }
    if a {
        Some(0)
    } else {
        Some(10)
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn get_cool_number(a: bool, b: bool) -&gt; i32 {
    if a &amp;&amp; b {
        return 50;
    }
    if a {
        0
    } else {
        10
    }
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.50.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnecessary_wraps">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unnecessary_wraps.rs#L20">View Source</a></div></div></div></article><article id="unneeded_field_pattern"><input id="label-unneeded_field_pattern" type="checkbox"><label for="label-unneeded_field_pattern"><h2 class="lint-title"><div class="panel-title-name" id="lint-unneeded_field_pattern">unneeded_field_pattern
<a href="#unneeded_field_pattern" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for structure field patterns bound to wildcards.</p>
<h3>Why restrict this?</h3>
<p>Using <code>..</code> instead is shorter and leaves the focus on
the fields that are actually bound.</p>
<h3>Example</h3>
<pre><code class="language-rust">let f = Foo { a: 0, b: 0, c: 0 };

match f {
    Foo { a: _, b: 0, .. } =&gt; {},
    Foo { a: _, b: _, c: _ } =&gt; {},
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let f = Foo { a: 0, b: 0, c: 0 };

match f {
    Foo { b: 0, .. } =&gt; {},
    Foo { .. } =&gt; {},
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unneeded_field_pattern">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/misc_early/mod.rs#L17">View Source</a></div></div></div></article><article id="unneeded_struct_pattern"><input id="label-unneeded_struct_pattern" type="checkbox"><label for="label-unneeded_struct_pattern"><h2 class="lint-title"><div class="panel-title-name" id="lint-unneeded_struct_pattern">unneeded_struct_pattern
<a href="#unneeded_struct_pattern" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for struct patterns that match against unit variant.</p>
<h3>Why is this bad?</h3>
<p>Struct pattern <code>{ }</code> or <code>{ .. }</code> is not needed for unit variant.</p>
<h3>Example</h3>
<pre><code class="language-rust">match Some(42) {
    Some(v) =&gt; v,
    None { .. } =&gt; 0,
};
// Or
match Some(42) {
    Some(v) =&gt; v,
    None { } =&gt; 0,
};
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">match Some(42) {
    Some(v) =&gt; v,
    None =&gt; 0,
};
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.86.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unneeded_struct_pattern">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unneeded_struct_pattern.rs#L9">View Source</a></div></div></div></article><article id="unneeded_wildcard_pattern"><input id="label-unneeded_wildcard_pattern" type="checkbox"><label for="label-unneeded_wildcard_pattern"><h2 class="lint-title"><div class="panel-title-name" id="lint-unneeded_wildcard_pattern">unneeded_wildcard_pattern
<a href="#unneeded_wildcard_pattern" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for tuple patterns with a wildcard
pattern (<code>_</code>) is next to a rest pattern (<code>..</code>).</p>
<p><em>NOTE</em>: While <code>_, ..</code> means there is at least one element left, <code>..</code>
means there are 0 or more elements left. This can make a difference
when refactoring, but shouldn’t result in errors in the refactored code,
since the wildcard pattern isn’t used anyway.</p>
<h3>Why is this bad?</h3>
<p>The wildcard pattern is unneeded as the rest pattern
can match that element as well.</p>
<h3>Example</h3>
<pre><code class="language-rust">match t {
    TupleStruct(0, .., _) =&gt; (),
    _ =&gt; (),
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">match t {
    TupleStruct(0, ..) =&gt; (),
    _ =&gt; (),
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.40.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unneeded_wildcard_pattern">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/misc_early/mod.rs#L236">View Source</a></div></div></div></article><article id="unnested_or_patterns"><input id="label-unnested_or_patterns" type="checkbox"><label for="label-unnested_or_patterns"><h2 class="lint-title"><div class="panel-title-name" id="lint-unnested_or_patterns">unnested_or_patterns
<a href="#unnested_or_patterns" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for unnested or-patterns, e.g., <code>Some(0) | Some(2)</code> and
suggests replacing the pattern with a nested one, <code>Some(0 | 2)</code>.</p>
<p>Another way to think of this is that it rewrites patterns in
<em>disjunctive normal form (DNF)</em> into <em>conjunctive normal form (CNF)</em>.</p>
<h3>Why is this bad?</h3>
<p>In the example above, <code>Some</code> is repeated, which unnecessarily complicates the pattern.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn main() {
    if let Some(0) | Some(2) = Some(0) {}
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn main() {
    if let Some(0 | 2) = Some(0) {}
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.46.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unnested_or_patterns">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unnested_or_patterns.rs#L23">View Source</a></div></div></div></article><article id="unreachable"><input id="label-unreachable" type="checkbox"><label for="label-unreachable"><h2 class="lint-title"><div class="panel-title-name" id="lint-unreachable">unreachable
<a href="#unreachable" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>unreachable!</code>.</p>
<h3>Why restrict this?</h3>
<p>This macro, or panics in general, may be unwanted in production code.</p>
<h3>Example</h3>
<pre><code class="language-rust">unreachable!();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.40.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unreachable">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/panic_unimplemented.rs#L79">View Source</a></div></div></div></article><article id="unreadable_literal"><input id="label-unreadable_literal" type="checkbox"><label for="label-unreadable_literal"><h2 class="lint-title"><div class="panel-title-name" id="lint-unreadable_literal">unreadable_literal
<a href="#unreadable_literal" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns if a long integral or floating-point constant does
not contain underscores.</p>
<h3>Why is this bad?</h3>
<p>Reading long numbers is difficult without separators.</p>
<h3>Example</h3>
<pre><code class="language-rust">61864918973511
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">61_864_918_973_511
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>unreadable-literal-lint-fractions</code>:  Should the fraction of a decimal be linted to include separators.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unreadable_literal">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/literal_representation.rs#L13">View Source</a></div></div></div></article><article id="unsafe_derive_deserialize"><input id="label-unsafe_derive_deserialize" type="checkbox"><label for="label-unsafe_derive_deserialize"><h2 class="lint-title"><div class="panel-title-name" id="lint-unsafe_derive_deserialize">unsafe_derive_deserialize
<a href="#unsafe_derive_deserialize" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for deriving <code>serde::Deserialize</code> on a type that
has methods using <code>unsafe</code>.</p>
<h3>Why is this bad?</h3>
<p>Deriving <code>serde::Deserialize</code> will create a constructor
that may violate invariants held by another constructor.</p>
<h3>Example</h3>
<pre><code class="language-rust">use serde::Deserialize;

#[derive(Deserialize)]
pub struct Foo {
    // ..
}

impl Foo {
    pub fn new() -&gt; Self {
        // setup here ..
    }

    pub unsafe fn parts() -&gt; (&amp;str, &amp;str) {
        // assumes invariants hold
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.45.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unsafe_derive_deserialize">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/derive/mod.rs#L121">View Source</a></div></div></div></article><article id="unsafe_removed_from_name"><input id="label-unsafe_removed_from_name" type="checkbox"><label for="label-unsafe_removed_from_name"><h2 class="lint-title"><div class="panel-title-name" id="lint-unsafe_removed_from_name">unsafe_removed_from_name
<a href="#unsafe_removed_from_name" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for imports that remove “unsafe” from an item’s
name.</p>
<h3>Why is this bad?</h3>
<p>Renaming makes it less clear which traits and
structures are unsafe.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::cell::{UnsafeCell as TotallySafeCell};

extern crate crossbeam;
use crossbeam::{spawn_unsafe as spawn};
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unsafe_removed_from_name">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unsafe_removed_from_name.rs#L8">View Source</a></div></div></div></article><article id="unsafe_vector_initialization"><input id="label-unsafe_vector_initialization" type="checkbox"><label for="label-unsafe_vector_initialization"><h2 class="lint-title"><div class="panel-title-name" id="lint-unsafe_vector_initialization">unsafe_vector_initialization
<a href="#unsafe_vector_initialization" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p>The suggested alternative could be substantially slower.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unsafe_vector_initialization">Related Issues</a></div></div></div></article><article id="unseparated_literal_suffix"><input id="label-unseparated_literal_suffix" type="checkbox"><label for="label-unseparated_literal_suffix"><h2 class="lint-title"><div class="panel-title-name" id="lint-unseparated_literal_suffix">unseparated_literal_suffix
<a href="#unseparated_literal_suffix" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns if literal suffixes are not separated by an
underscore.
To enforce unseparated literal suffix style,
see the <code>separated_literal_suffix</code> lint.</p>
<h3>Why restrict this?</h3>
<p>Suffix style should be consistent.</p>
<h3>Example</h3>
<pre><code class="language-rust">123832i32
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">123832_i32
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unseparated_literal_suffix">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/misc_early/mod.rs#L87">View Source</a></div></div></div></article><article id="unsound_collection_transmute"><input id="label-unsound_collection_transmute" type="checkbox"><label for="label-unsound_collection_transmute"><h2 class="lint-title"><div class="panel-title-name" id="lint-unsound_collection_transmute">unsound_collection_transmute
<a href="#unsound_collection_transmute" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for transmutes between collections whose
types have different ABI, size or alignment.</p>
<h3>Why is this bad?</h3>
<p>This is undefined behavior.</p>
<h3>Known problems</h3>
<p>Currently, we cannot know whether a type is a
collection, so we just lint the ones that come with <code>std</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">// different size, therefore likely out-of-bounds memory access
// You absolutely do not want this in your code!
unsafe {
    std::mem::transmute::&lt;_, Vec&lt;u32&gt;&gt;(vec![2_u16])
};
</code></pre>
<p>You must always iterate, map and collect the values:</p>
<pre><code class="language-rust">vec![2_u16].into_iter().map(u32::from).collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.40.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unsound_collection_transmute">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/transmute/mod.rs#L253">View Source</a></div></div></div></article><article id="unstable_as_mut_slice"><input id="label-unstable_as_mut_slice" type="checkbox"><label for="label-unstable_as_mut_slice"><h2 class="lint-title"><div class="panel-title-name" id="lint-unstable_as_mut_slice">unstable_as_mut_slice
<a href="#unstable_as_mut_slice" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p><code>Vec::as_mut_slice</code> is now stable.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unstable_as_mut_slice">Related Issues</a></div></div></div></article><article id="unstable_as_slice"><input id="label-unstable_as_slice" type="checkbox"><label for="label-unstable_as_slice"><h2 class="lint-title"><div class="panel-title-name" id="lint-unstable_as_slice">unstable_as_slice
<a href="#unstable_as_slice" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p><code>Vec::as_slice</code> is now stable.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unstable_as_slice">Related Issues</a></div></div></div></article><article id="unused_async"><input id="label-unused_async" type="checkbox"><label for="label-unused_async"><h2 class="lint-title"><div class="panel-title-name" id="lint-unused_async">unused_async
<a href="#unused_async" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for functions that are declared <code>async</code> but have no <code>.await</code>s inside of them.</p>
<h3>Why is this bad?</h3>
<p>Async functions with no async code create overhead, both mentally and computationally.
Callers of async methods either need to be calling from an async function themselves or run it on an executor, both of which
causes runtime overhead and hassle for the caller.</p>
<h3>Example</h3>
<pre><code class="language-rust">async fn get_random_number() -&gt; i64 {
    4 // Chosen by fair dice roll. Guaranteed to be random.
}
let number_future = get_random_number();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn get_random_number_improved() -&gt; i64 {
    4 // Chosen by fair dice roll. Guaranteed to be random.
}
let number_future = async { get_random_number_improved() };
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.54.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unused_async">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unused_async.rs#L16">View Source</a></div></div></div></article><article id="unused_collect"><input id="label-unused_collect" type="checkbox"><label for="label-unused_collect"><h2 class="lint-title"><div class="panel-title-name" id="lint-unused_collect">unused_collect
<a href="#unused_collect" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p><code>Iterator::collect</code> is now marked as <code>#[must_use]</code>.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">1.39.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unused_collect">Related Issues</a></div></div></div></article><article id="unused_enumerate_index"><input id="label-unused_enumerate_index" type="checkbox"><label for="label-unused_enumerate_index"><h2 class="lint-title"><div class="panel-title-name" id="lint-unused_enumerate_index">unused_enumerate_index
<a href="#unused_enumerate_index" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for uses of the <code>enumerate</code> method where the index is unused (<code>_</code>)</p>
<h3>Why is this bad?</h3>
<p>The index from <code>.enumerate()</code> is immediately dropped.</p>
<h3>Example</h3>
<pre><code class="language-rust">let v = vec![1, 2, 3, 4];
for (_, x) in v.iter().enumerate() {
    println!("{x}");
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let v = vec![1, 2, 3, 4];
for x in v.iter() {
    println!("{x}");
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.75.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unused_enumerate_index">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L621">View Source</a></div></div></div></article><article id="unused_format_specs"><input id="label-unused_format_specs" type="checkbox"><label for="label-unused_format_specs"><h2 class="lint-title"><div class="panel-title-name" id="lint-unused_format_specs">unused_format_specs
<a href="#unused_format_specs" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects <a href="https://doc.rust-lang.org/std/fmt/index.html#formatting-parameters">formatting parameters</a> that have no effect on the output of
<code>format!()</code>, <code>println!()</code> or similar macros.</p>
<h3>Why is this bad?</h3>
<p>Shorter format specifiers are easier to read, it may also indicate that
an expected formatting operation such as adding padding isn’t happening.</p>
<h3>Example</h3>
<pre><code class="language-rust">println!("{:.}", 1.0);

println!("not padded: {:5}", format_args!("..."));
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">println!("{}", 1.0);

println!("not padded: {}", format_args!("..."));
// OR
println!("padded: {:5}", format!("..."));
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.66.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unused_format_specs">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/format_args.rs#L173">View Source</a></div></div></div></article><article id="unused_io_amount"><input id="label-unused_io_amount" type="checkbox"><label for="label-unused_io_amount"><h2 class="lint-title"><div class="panel-title-name" id="lint-unused_io_amount">unused_io_amount
<a href="#unused_io_amount" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for unused written/read amount.</p>
<h3>Why is this bad?</h3>
<p><code>io::Write::write(_vectored)</code> and
<code>io::Read::read(_vectored)</code> are not guaranteed to
process the entire buffer. They return how many bytes were processed, which
might be smaller
than a given buffer’s length. If you don’t need to deal with
partial-write/read, use
<code>write_all</code>/<code>read_exact</code> instead.</p>
<p>When working with asynchronous code (either with the <code>futures</code>
crate or with <code>tokio</code>), a similar issue exists for
<code>AsyncWriteExt::write()</code> and <code>AsyncReadExt::read()</code> : these
functions are also not guaranteed to process the entire
buffer.  Your code should either handle partial-writes/reads, or
call the <code>write_all</code>/<code>read_exact</code> methods on those traits instead.</p>
<h3>Known problems</h3>
<p>Detects only common patterns.</p>
<h3>Examples</h3>
<pre><code class="language-rust">use std::io;
fn foo&lt;W: io::Write&gt;(w: &amp;mut W) -&gt; io::Result&lt;()&gt; {
    w.write(b"foo")?;
    Ok(())
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::io;
fn foo&lt;W: io::Write&gt;(w: &amp;mut W) -&gt; io::Result&lt;()&gt; {
    w.write_all(b"foo")?;
    Ok(())
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unused_io_amount">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unused_io_amount.rs#L11">View Source</a></div></div></div></article><article id="unused_peekable"><input id="label-unused_peekable" type="checkbox"><label for="label-unused_peekable"><h2 class="lint-title"><div class="panel-title-name" id="lint-unused_peekable">unused_peekable
<a href="#unused_peekable" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the creation of a <code>peekable</code> iterator that is never <code>.peek()</code>ed</p>
<h3>Why is this bad?</h3>
<p>Creating a peekable iterator without using any of its methods is likely a mistake,
or just a leftover after a refactor.</p>
<h3>Example</h3>
<pre><code class="language-rust">let collection = vec![1, 2, 3];
let iter = collection.iter().peekable();

for item in iter {
    // ...
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let collection = vec![1, 2, 3];
let iter = collection.iter();

for item in iter {
    // ...
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.65.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unused_peekable">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unused_peekable.rs#L13">View Source</a></div></div></div></article><article id="unused_result_ok"><input id="label-unused_result_ok" type="checkbox"><label for="label-unused_result_ok"><h2 class="lint-title"><div class="panel-title-name" id="lint-unused_result_ok">unused_result_ok
<a href="#unused_result_ok" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>Result::ok()</code> without using the returned <code>Option</code>.</p>
<h3>Why is this bad?</h3>
<p>Using <code>Result::ok()</code> may look like the result is checked like <code>unwrap</code> or <code>expect</code> would do
but it only silences the warning caused by <code>#[must_use]</code> on the <code>Result</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">some_function().ok();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let _ = some_function();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.82.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unused_result_ok">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unused_result_ok.rs#L10">View Source</a></div></div></div></article><article id="unused_rounding"><input id="label-unused_rounding" type="checkbox"><label for="label-unused_rounding"><h2 class="lint-title"><div class="panel-title-name" id="lint-unused_rounding">unused_rounding
<a href="#unused_rounding" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects cases where a whole-number literal float is being rounded, using
the <code>floor</code>, <code>ceil</code>, or <code>round</code> methods.</p>
<h3>Why is this bad?</h3>
<p>This is unnecessary and confusing to the reader. Doing this is probably a mistake.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = 1f32.ceil();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = 1f32;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.63.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unused_rounding">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unused_rounding.rs#L10">View Source</a></div></div></div></article><article id="unused_self"><input id="label-unused_self" type="checkbox"><label for="label-unused_self"><h2 class="lint-title"><div class="panel-title-name" id="lint-unused_self">unused_self
<a href="#unused_self" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks methods that contain a <code>self</code> argument but don’t use it</p>
<h3>Why is this bad?</h3>
<p>It may be clearer to define the method as an associated function instead
of an instance method if it doesn’t require <code>self</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct A;
impl A {
    fn method(&amp;self) {}
}
</code></pre>
<p>Could be written:</p>
<pre><code class="language-rust">struct A;
impl A {
    fn method() {}
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.40.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unused_self">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unused_self.rs#L9">View Source</a></div></div></div></article><article id="unused_trait_names"><input id="label-unused_trait_names" type="checkbox"><label for="label-unused_trait_names"><h2 class="lint-title"><div class="panel-title-name" id="lint-unused_trait_names">unused_trait_names
<a href="#unused_trait_names" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>use Trait</code> where the Trait is only used for its methods and not referenced by a path directly.</p>
<h3>Why is this bad?</h3>
<p>Traits imported that aren’t used directly can be imported anonymously with <code>use Trait as _</code>.
It is more explicit, avoids polluting the current scope with unused names and can be useful to show which imports are required for traits.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::fmt::Write;

fn main() {
    let mut s = String::new();
    let _ = write!(s, "hello, world!");
    println!("{s}");
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::fmt::Write as _;

fn main() {
    let mut s = String::new();
    let _ = write!(s, "hello, world!");
    println!("{s}");
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.83.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unused_trait_names">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unused_trait_names.rs#L14">View Source</a></div></div></div></article><article id="unused_unit"><input id="label-unused_unit" type="checkbox"><label for="label-unused_unit"><h2 class="lint-title"><div class="panel-title-name" id="lint-unused_unit">unused_unit
<a href="#unused_unit" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for unit (<code>()</code>) expressions that can be removed.</p>
<h3>Why is this bad?</h3>
<p>Such expressions add no value, but can make the code
less readable. Depending on formatting they can make a <code>break</code> or <code>return</code>
statement look like a function call.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn return_unit() -&gt; () {
    ()
}
</code></pre>
<p>is equivalent to</p>
<pre><code class="language-rust">fn return_unit() {}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.31.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unused_unit">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unused_unit.rs#L17">View Source</a></div></div></div></article><article id="unusual_byte_groupings"><input id="label-unusual_byte_groupings" type="checkbox"><label for="label-unusual_byte_groupings"><h2 class="lint-title"><div class="panel-title-name" id="lint-unusual_byte_groupings">unusual_byte_groupings
<a href="#unusual_byte_groupings" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns if hexadecimal or binary literals are not grouped
by nibble or byte.</p>
<h3>Why is this bad?</h3>
<p>Negatively impacts readability.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: u32 = 0xFFF_FFF;
let y: u8 = 0b01_011_101;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.49.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unusual_byte_groupings">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/literal_representation.rs#L90">View Source</a></div></div></div></article><article id="unwrap_in_result"><input id="label-unwrap_in_result" type="checkbox"><label for="label-unwrap_in_result"><h2 class="lint-title"><div class="panel-title-name" id="lint-unwrap_in_result">unwrap_in_result
<a href="#unwrap_in_result" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for functions of type <code>Result</code> that contain <code>expect()</code> or <code>unwrap()</code></p>
<h3>Why restrict this?</h3>
<p>These functions promote recoverable errors to non-recoverable errors,
which may be undesirable in code bases which wish to avoid panics,
or be a bug in the specific function.</p>
<h3>Known problems</h3>
<p>This can cause false positives in functions that handle both recoverable and non recoverable errors.</p>
<h3>Example</h3>
<p>Before:</p>
<pre><code class="language-rust">fn divisible_by_3(i_str: String) -&gt; Result&lt;(), String&gt; {
    let i = i_str
        .parse::&lt;i32&gt;()
        .expect("cannot divide the input by three");

    if i % 3 != 0 {
        Err("Number is not divisible by 3")?
    }

    Ok(())
}
</code></pre>
<p>After:</p>
<pre><code class="language-rust">fn divisible_by_3(i_str: String) -&gt; Result&lt;(), String&gt; {
    let i = i_str
        .parse::&lt;i32&gt;()
        .map_err(|e| format!("cannot divide the input by three: {}", e))?;

    if i % 3 != 0 {
        Err("Number is not divisible by 3")?
    }

    Ok(())
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.48.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unwrap_in_result">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/unwrap_in_result.rs#L11">View Source</a></div></div></div></article><article id="unwrap_or_default"><input id="label-unwrap_or_default" type="checkbox"><label for="label-unwrap_or_default"><h2 class="lint-title"><div class="panel-title-name" id="lint-unwrap_or_default">unwrap_or_default
<a href="#unwrap_or_default" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usages of the following functions with an argument that constructs a default value
(e.g., <code>Default::default</code> or <code>String::new</code>):</p>
<ul>
<li><code>unwrap_or</code></li>
<li><code>unwrap_or_else</code></li>
<li><code>or_insert</code></li>
<li><code>or_insert_with</code></li>
</ul>
<h3>Why is this bad?</h3>
<p>Readability. Using <code>unwrap_or_default</code> in place of <code>unwrap_or</code>/<code>unwrap_or_else</code>, or <code>or_default</code>
in place of <code>or_insert</code>/<code>or_insert_with</code>, is simpler and more concise.</p>
<h3>Known problems</h3>
<p>In some cases, the argument of <code>unwrap_or</code>, etc. is needed for type inference. The lint uses a
heuristic to try to identify such cases. However, the heuristic can produce false negatives.</p>
<h3>Examples</h3>
<pre><code class="language-rust">x.unwrap_or(Default::default());
map.entry(42).or_insert_with(String::new);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">x.unwrap_or_default();
map.entry(42).or_default();
</code></pre>
<h3>Past names</h3>
<ul>
<li>unwrap_or_else_default</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.56.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unwrap_or_default">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L527">View Source</a></div></div></div></article><article id="unwrap_used"><input id="label-unwrap_used" type="checkbox"><label for="label-unwrap_used"><h2 class="lint-title"><div class="panel-title-name" id="lint-unwrap_used">unwrap_used
<a href="#unwrap_used" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>.unwrap()</code> or <code>.unwrap_err()</code> calls on <code>Result</code>s and <code>.unwrap()</code> call on <code>Option</code>s.</p>
<h3>Why restrict this?</h3>
<p>It is better to handle the <code>None</code> or <code>Err</code> case,
or at least call <code>.expect(_)</code> with a more helpful message. Still, for a lot of
quick-and-dirty code, <code>unwrap</code> is a good choice, which is why this lint is
<code>Allow</code> by default.</p>
<p><code>result.unwrap()</code> will let the thread panic on <code>Err</code> values.
Normally, you want to implement more sophisticated error handling,
and propagate errors upwards with <code>?</code> operator.</p>
<p>Even if you want to panic on errors, not all <code>Error</code>s implement good
messages on display. Therefore, it may be beneficial to look at the places
where they may get displayed. Activate this lint to do just that.</p>
<h3>Examples</h3>
<pre><code class="language-rust">option.unwrap();
result.unwrap();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">option.expect("more helpful message");
result.expect("more helpful message");
</code></pre>
<p>If <a href="#expect_used">expect_used</a> is enabled, instead:</p>
<pre><code class="language-rust">option?;

// or

result?;
</code></pre>
<h3>Past names</h3>
<ul>
<li>option_unwrap_used</li>
<li>result_unwrap_used</li>
</ul>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allow-unwrap-in-consts</code>:  Whether <code>unwrap</code> should be allowed in code always evaluated at compile time</p>
<p>(default: <code>true</code>)</p>
</li>
<li>
<p><code>allow-unwrap-in-tests</code>:  Whether <code>unwrap</code> should be allowed in test functions or <code>#[cfg(test)]</code></p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.45.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+unwrap_used">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L273">View Source</a></div></div></div></article><article id="upper_case_acronyms"><input id="label-upper_case_acronyms" type="checkbox"><label for="label-upper_case_acronyms"><h2 class="lint-title"><div class="panel-title-name" id="lint-upper_case_acronyms">upper_case_acronyms
<a href="#upper_case_acronyms" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for fully capitalized names and optionally names containing a capitalized acronym.</p>
<h3>Why is this bad?</h3>
<p>In CamelCase, acronyms count as one word.
See <a href="https://rust-lang.github.io/api-guidelines/naming.html#casing-conforms-to-rfc-430-c-case">naming conventions</a>
for more.</p>
<p>By default, the lint only triggers on fully-capitalized names.
You can use the <code>upper-case-acronyms-aggressive: true</code> config option to enable linting
on all camel case names</p>
<h3>Known problems</h3>
<p>When two acronyms are contiguous, the lint can’t tell where
the first acronym ends and the second starts, so it suggests to lowercase all of
the letters in the second acronym.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct HTTPResponse;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">struct HttpResponse;
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
<li>
<p><code>upper-case-acronyms-aggressive</code>:  Enables verbose mode. Triggers if there is more than one uppercase char next to each other</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.51.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+upper_case_acronyms">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/upper_case_acronyms.rs#L10">View Source</a></div></div></div></article><article id="use_debug"><input id="label-use_debug" type="checkbox"><label for="label-use_debug"><h2 class="lint-title"><div class="panel-title-name" id="lint-use_debug">use_debug
<a href="#use_debug" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>Debug</code> formatting. The purpose of this
lint is to catch debugging remnants.</p>
<h3>Why restrict this?</h3>
<p>The purpose of the <code>Debug</code> trait is to facilitate debugging Rust code,
and <a href="https://doc.rust-lang.org/stable/std/fmt/trait.Debug.html#stability">no guarantees are made about its output</a>.
It should not be used in user-facing output.</p>
<h3>Example</h3>
<pre><code class="language-rust">println!("{:?}", foo);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+use_debug">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/write/mod.rs#L106">View Source</a></div></div></div></article><article id="use_self"><input id="label-use_self" type="checkbox"><label for="label-use_self"><h2 class="lint-title"><div class="panel-title-name" id="lint-use_self">use_self
<a href="#use_self" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for unnecessary repetition of structure name when a
replacement with <code>Self</code> is applicable.</p>
<h3>Why is this bad?</h3>
<p>Unnecessary repetition. Mixed use of <code>Self</code> and struct
name
feels inconsistent.</p>
<h3>Known problems</h3>
<ul>
<li>Unaddressed false negative in fn bodies of trait implementations</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">struct Foo;
impl Foo {
    fn new() -&gt; Foo {
        Foo {}
    }
}
</code></pre>
<p>could be</p>
<pre><code class="language-rust">struct Foo;
impl Foo {
    fn new() -&gt; Self {
        Self {}
    }
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
<li>
<p><code>recursive-self-in-type-definitions</code>:  Whether the type itself in a struct or enum should be replaced with <code>Self</code> when encountering recursive types.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+use_self">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/use_self.rs#L22">View Source</a></div></div></div></article><article id="used_underscore_binding"><input id="label-used_underscore_binding" type="checkbox"><label for="label-used_underscore_binding"><h2 class="lint-title"><div class="panel-title-name" id="lint-used_underscore_binding">used_underscore_binding
<a href="#used_underscore_binding" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the use of bindings with a single leading
underscore.</p>
<h3>Why is this bad?</h3>
<p>A single leading underscore is usually used to indicate
that a binding will not be used. Using such a binding breaks this
expectation.</p>
<h3>Known problems</h3>
<p>The lint does not work properly with desugaring and
macro, it has been allowed in the meantime.</p>
<h3>Example</h3>
<pre><code class="language-rust">let _x = 0;
let y = _x + 1; // Here we are using `_x`, even though it has a leading
                // underscore. We should rename `_x` to `x`
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+used_underscore_binding">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/misc.rs#L10">View Source</a></div></div></div></article><article id="used_underscore_items"><input id="label-used_underscore_items" type="checkbox"><label for="label-used_underscore_items"><h2 class="lint-title"><div class="panel-title-name" id="lint-used_underscore_items">used_underscore_items
<a href="#used_underscore_items" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the use of item with a single leading
underscore.</p>
<h3>Why is this bad?</h3>
<p>A single leading underscore is usually used to indicate
that a item will not be used. Using such a item breaks this
expectation.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn _foo() {}

struct _FooStruct {}

fn main() {
    _foo();
    let _ = _FooStruct{};
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn foo() {}

struct FooStruct {}

fn main() {
    foo();
    let _ = FooStruct{};
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.83.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+used_underscore_items">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/misc.rs#L36">View Source</a></div></div></div></article><article id="useless_asref"><input id="label-useless_asref" type="checkbox"><label for="label-useless_asref"><h2 class="lint-title"><div class="panel-title-name" id="lint-useless_asref">useless_asref
<a href="#useless_asref" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>.as_ref()</code> or <code>.as_mut()</code> where the
types before and after the call are the same.</p>
<h3>Why is this bad?</h3>
<p>The call is unnecessary.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x: &amp;[i32] = &amp;[1, 2, 3, 4, 5];
do_stuff(x.as_ref());
</code></pre>
<p>The correct use would be:</p>
<pre><code class="language-rust">let x: &amp;[i32] = &amp;[1, 2, 3, 4, 5];
do_stuff(x);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+useless_asref">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1493">View Source</a></div></div></div></article><article id="useless_attribute"><input id="label-useless_attribute" type="checkbox"><label for="label-useless_attribute"><h2 class="lint-title"><div class="panel-title-name" id="lint-useless_attribute">useless_attribute
<a href="#useless_attribute" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>extern crate</code> and <code>use</code> items annotated with
lint attributes.</p>
<p>This lint permits lint attributes for lints emitted on the items themself.
For <code>use</code> items these lints are:</p>
<ul>
<li>ambiguous_glob_reexports</li>
<li>dead_code</li>
<li>deprecated</li>
<li>hidden_glob_reexports</li>
<li>unreachable_pub</li>
<li>unused</li>
<li>unused_braces</li>
<li>unused_import_braces</li>
<li>clippy::disallowed_types</li>
<li>clippy::enum_glob_use</li>
<li>clippy::macro_use_imports</li>
<li>clippy::module_name_repetitions</li>
<li>clippy::redundant_pub_crate</li>
<li>clippy::single_component_path_imports</li>
<li>clippy::unsafe_removed_from_name</li>
<li>clippy::wildcard_imports</li>
</ul>
<p>For <code>extern crate</code> items these lints are:</p>
<ul>
<li><code>unused_imports</code> on items with <code>#[macro_use]</code></li>
</ul>
<h3>Why is this bad?</h3>
<p>Lint attributes have no effect on crate imports. Most
likely a <code>!</code> was forgotten.</p>
<h3>Example</h3>
<pre><code class="language-rust">#[deny(dead_code)]
extern crate foo;
#[forbid(dead_code)]
use foo::bar;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">#[allow(unused_imports)]
use foo::baz;
#[allow(unused_imports)]
#[macro_use]
extern crate baz;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+useless_attribute">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/attrs/mod.rs#L56">View Source</a></div></div></div></article><article id="useless_concat"><input id="label-useless_concat" type="checkbox"><label for="label-useless_concat"><h2 class="lint-title"><div class="panel-title-name" id="lint-useless_concat">useless_concat
<a href="#useless_concat" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks that the <code>concat!</code> macro has at least two arguments.</p>
<h3>Why is this bad?</h3>
<p>If there are less than 2 arguments, then calling the macro is doing nothing.</p>
<h3>Example</h3>
<pre><code class="language-rust">let x = concat!("a");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let x = "a";
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.89.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+useless_concat">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/useless_concat.rs#L12">View Source</a></div></div></div></article><article id="useless_conversion"><input id="label-useless_conversion" type="checkbox"><label for="label-useless_conversion"><h2 class="lint-title"><div class="panel-title-name" id="lint-useless_conversion">useless_conversion
<a href="#useless_conversion" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>Into</code>, <code>TryInto</code>, <code>From</code>, <code>TryFrom</code>, or <code>IntoIter</code> calls
which uselessly convert to the same type.</p>
<h3>Why is this bad?</h3>
<p>Redundant code.</p>
<h3>Example</h3>
<pre><code class="language-rust">// format!() returns a `String`
let s: String = format!("hello").into();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let s: String = format!("hello");
</code></pre>
<h3>Past names</h3>
<ul>
<li>identity_conversion</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.45.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+useless_conversion">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/useless_conversion.rs#L20">View Source</a></div></div></div></article><article id="useless_format"><input id="label-useless_format" type="checkbox"><label for="label-useless_format"><h2 class="lint-title"><div class="panel-title-name" id="lint-useless_format">useless_format
<a href="#useless_format" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for the use of <code>format!("string literal with no argument")</code> and <code>format!("{}", foo)</code> where <code>foo</code> is a string.</p>
<h3>Why is this bad?</h3>
<p>There is no point of doing that. <code>format!("foo")</code> can
be replaced by <code>"foo".to_owned()</code> if you really need a <code>String</code>. The even
worse <code>&amp;format!("foo")</code> is often encountered in the wild. <code>format!("{}", foo)</code> can be replaced by <code>foo.clone()</code> if <code>foo: String</code> or <code>foo.to_owned()</code>
if <code>foo: &amp;str</code>.</p>
<h3>Examples</h3>
<pre><code class="language-rust">let foo = "foo";
format!("{}", foo);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let foo = "foo";
foo.to_owned();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+useless_format">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/format.rs#L13">View Source</a></div></div></div></article><article id="useless_let_if_seq"><input id="label-useless_let_if_seq" type="checkbox"><label for="label-useless_let_if_seq"><h2 class="lint-title"><div class="panel-title-name" id="lint-useless_let_if_seq">useless_let_if_seq
<a href="#useless_let_if_seq" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for variable declarations immediately followed by a
conditional affectation.</p>
<h3>Why is this bad?</h3>
<p>This is not idiomatic Rust.</p>
<h3>Example</h3>
<pre><code class="language-rust">let foo;

if bar() {
    foo = 42;
} else {
    foo = 0;
}

let mut baz = None;

if bar() {
    baz = Some(42);
}
</code></pre>
<p>should be written</p>
<pre><code class="language-rust">let foo = if bar() {
    42
} else {
    0
};

let baz = if bar() {
    Some(42)
} else {
    None
};
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+useless_let_if_seq">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/let_if_seq.rs#L11">View Source</a></div></div></div></article><article id="useless_nonzero_new_unchecked"><input id="label-useless_nonzero_new_unchecked" type="checkbox"><label for="label-useless_nonzero_new_unchecked"><h2 class="lint-title"><div class="panel-title-name" id="lint-useless_nonzero_new_unchecked">useless_nonzero_new_unchecked
<a href="#useless_nonzero_new_unchecked" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>NonZero*::new_unchecked()</code> being used in a <code>const</code> context.</p>
<h3>Why is this bad?</h3>
<p>Using <code>NonZero*::new_unchecked()</code> is an <code>unsafe</code> function and requires an <code>unsafe</code> context. When used in a
context evaluated at compilation time, <code>NonZero*::new().unwrap()</code> will provide the same result with identical
runtime performances while not requiring <code>unsafe</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::num::NonZeroUsize;
const PLAYERS: NonZeroUsize = unsafe { NonZeroUsize::new_unchecked(3) };
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::num::NonZeroUsize;
const PLAYERS: NonZeroUsize = NonZeroUsize::new(3).unwrap();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.86.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+useless_nonzero_new_unchecked">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L4380">View Source</a></div></div></div></article><article id="useless_transmute"><input id="label-useless_transmute" type="checkbox"><label for="label-useless_transmute"><h2 class="lint-title"><div class="panel-title-name" id="lint-useless_transmute">useless_transmute
<a href="#useless_transmute" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for transmutes to the original type of the object
and transmutes that could be a cast.</p>
<h3>Why is this bad?</h3>
<p>Readability. The code tricks people into thinking that
something complex is going on.</p>
<h3>Example</h3>
<pre><code class="language-rust">core::intrinsics::transmute(t); // where the result type is the same as `t`'s
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+useless_transmute">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/transmute/mod.rs#L51">View Source</a></div></div></div></article><article id="useless_vec"><input id="label-useless_vec" type="checkbox"><label for="label-useless_vec"><h2 class="lint-title"><div class="panel-title-name" id="lint-useless_vec">useless_vec
<a href="#useless_vec" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>vec![..]</code> when using <code>[..]</code> would
be possible.</p>
<h3>Why is this bad?</h3>
<p>This is less efficient.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn foo(_x: &amp;[u8]) {}

foo(&amp;vec![1, 2]);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">foo(&amp;[1, 2]);
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>allow-useless-vec-in-tests</code>:  Whether <code>useless_vec</code> should ignore test functions or <code>#[cfg(test)]</code></p>
<p>(default: <code>false</code>)</p>
</li>
<li>
<p><code>too-large-for-stack</code>:  The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap</p>
<p>(default: <code>200</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+useless_vec">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/useless_vec.rs#L60">View Source</a></div></div></div></article><article id="vec_box"><input id="label-vec_box" type="checkbox"><label for="label-vec_box"><h2 class="lint-title"><div class="panel-title-name" id="lint-vec_box">vec_box
<a href="#vec_box" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>Vec&lt;Box&lt;T&gt;&gt;</code> where T: Sized anywhere in the code.
Check the <a href="https://doc.rust-lang.org/std/boxed/index.html">Box documentation</a> for more information.</p>
<h3>Why is this bad?</h3>
<p><code>Vec</code> already keeps its contents in a separate area on
the heap. So if you <code>Box</code> its contents, you just add another level of indirection.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct X {
    values: Vec&lt;Box&lt;i32&gt;&gt;,
}
</code></pre>
<p>Better:</p>
<pre><code class="language-rust">struct X {
    values: Vec&lt;i32&gt;,
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
<li>
<p><code>vec-box-size-threshold</code>:  The size of the boxed type in bytes, where boxing in a <code>Vec</code> is allowed</p>
<p>(default: <code>4096</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.33.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+vec_box">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/types/mod.rs#L55">View Source</a></div></div></div></article><article id="vec_init_then_push"><input id="label-vec_init_then_push" type="checkbox"><label for="label-vec_init_then_push"><h2 class="lint-title"><div class="panel-title-name" id="lint-vec_init_then_push">vec_init_then_push
<a href="#vec_init_then_push" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for calls to <code>push</code> immediately after creating a new <code>Vec</code>.</p>
<p>If the <code>Vec</code> is created using <code>with_capacity</code> this will only lint if the capacity is a
constant and the number of pushes is greater than or equal to the initial capacity.</p>
<p>If the <code>Vec</code> is extended after the initial sequence of pushes and it was default initialized
then this will only lint after there were at least four pushes. This number may change in
the future.</p>
<h3>Why is this bad?</h3>
<p>The <code>vec![]</code> macro is both more performant and easier to read than
multiple <code>push</code> calls.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut v = Vec::new();
v.push(0);
v.push(1);
v.push(2);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let v = vec![0, 1, 2];
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.51.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+vec_init_then_push">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/vec_init_then_push.rs#L15">View Source</a></div></div></div></article><article id="vec_resize_to_zero"><input id="label-vec_resize_to_zero" type="checkbox"><label for="label-vec_resize_to_zero"><h2 class="lint-title"><div class="panel-title-name" id="lint-vec_resize_to_zero">vec_resize_to_zero
<a href="#vec_resize_to_zero" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Finds occurrences of <code>Vec::resize(0, an_int)</code></p>
<h3>Why is this bad?</h3>
<p>This is probably an argument inversion mistake.</p>
<h3>Example</h3>
<pre><code class="language-rust">vec![1, 2, 3, 4, 5].resize(0, 5)
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">vec![1, 2, 3, 4, 5].clear()
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.46.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+vec_resize_to_zero">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3190">View Source</a></div></div></div></article><article id="verbose_bit_mask"><input id="label-verbose_bit_mask" type="checkbox"><label for="label-verbose_bit_mask"><h2 class="lint-title"><div class="panel-title-name" id="lint-verbose_bit_mask">verbose_bit_mask
<a href="#verbose_bit_mask" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for bit masks that can be replaced by a call
to <code>trailing_zeros</code></p>
<h3>Why is this bad?</h3>
<p><code>x.trailing_zeros() &gt;= 4</code> is much clearer than <code>x &amp; 15 == 0</code></p>
<h3>Example</h3>
<pre><code class="language-rust">if x &amp; 0b1111 == 0 { }
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">if x.trailing_zeros() &gt;= 4 { }
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>verbose-bit-mask-threshold</code>:  The maximum allowed size of a bit mask before suggesting to use ‘trailing_zeros’</p>
<p>(default: <code>1</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+verbose_bit_mask">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/operators/mod.rs#L265">View Source</a></div></div></div></article><article id="verbose_file_reads"><input id="label-verbose_file_reads" type="checkbox"><label for="label-verbose_file_reads"><h2 class="lint-title"><div class="panel-title-name" id="lint-verbose_file_reads">verbose_file_reads
<a href="#verbose_file_reads" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of File::read_to_end and File::read_to_string.</p>
<h3>Why restrict this?</h3>
<p><code>fs::{read, read_to_string}</code> provide the same functionality when <code>buf</code> is empty with fewer imports and no intermediate values.
See also: <a href="https://doc.rust-lang.org/std/fs/fn.read.html">fs::read docs</a>, <a href="https://doc.rust-lang.org/std/fs/fn.read_to_string.html">fs::read_to_string docs</a></p>
<h3>Example</h3>
<pre><code class="language-rust">let mut f = File::open("foo.txt").unwrap();
let mut bytes = Vec::new();
f.read_to_end(&amp;mut bytes).unwrap();
</code></pre>
<p>Can be written more concisely as</p>
<pre><code class="language-rust">let mut bytes = fs::read("foo.txt").unwrap();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.44.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+verbose_file_reads">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3212">View Source</a></div></div></div></article><article id="volatile_composites"><input id="label-volatile_composites" type="checkbox"><label for="label-volatile_composites"><h2 class="lint-title"><div class="panel-title-name" id="lint-volatile_composites">volatile_composites
<a href="#volatile_composites" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint warns when volatile load/store operations
(<code>write_volatile</code>/<code>read_volatile</code>) are applied to composite types.</p>
<h3>Why is this bad?</h3>
<p>Volatile operations are typically used with memory mapped IO devices,
where the precise number and ordering of load and store instructions is
important because they can have side effects. This is well defined for
primitive types like <code>u32</code>, but less well defined for structures and
other composite types. In practice it’s implementation defined, and the
behavior can be rustc-version dependent.</p>
<p>As a result, code should only apply <code>write_volatile</code>/<code>read_volatile</code> to
primitive types to be fully well-defined.</p>
<h3>Example</h3>
<pre><code class="language-rust">struct MyDevice {
    addr: usize,
    count: usize
}

fn start_device(device: *mut MyDevice, addr: usize, count: usize) {
    unsafe {
        device.write_volatile(MyDevice { addr, count });
    }
}
</code></pre>
<p>Instead, operate on each primtive field individually:</p>
<pre><code class="language-rust">struct MyDevice {
    addr: usize,
    count: usize
}

fn start_device(device: *mut MyDevice, addr: usize, count: usize) {
    unsafe {
        (&amp;raw mut (*device).addr).write_volatile(addr);
        (&amp;raw mut (*device).count).write_volatile(count);
    }
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.92.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+volatile_composites">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/volatile_composites.rs#L10">View Source</a></div></div></div></article><article id="waker_clone_wake"><input id="label-waker_clone_wake" type="checkbox"><label for="label-waker_clone_wake"><h2 class="lint-title"><div class="panel-title-name" id="lint-waker_clone_wake">waker_clone_wake
<a href="#waker_clone_wake" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-perf">perf</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for usage of <code>waker.clone().wake()</code></p>
<h3>Why is this bad?</h3>
<p>Cloning the waker is not necessary, <code>wake_by_ref()</code> enables the same operation
without extra cloning/dropping.</p>
<h3>Example</h3>
<pre><code class="language-rust">waker.clone().wake();
</code></pre>
<p>Should be written</p>
<pre><code class="language-rust">waker.wake_by_ref();
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.75.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+waker_clone_wake">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L3774">View Source</a></div></div></div></article><article id="while_float"><input id="label-while_float" type="checkbox"><label for="label-while_float"><h2 class="lint-title"><div class="panel-title-name" id="lint-while_float">while_float
<a href="#while_float" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-nursery">nursery</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for while loops comparing floating point values.</p>
<h3>Why is this bad?</h3>
<p>If you increment floating point values, errors can compound,
so, use integers instead if possible.</p>
<h3>Known problems</h3>
<p>The lint will catch all while loops comparing floating point
values without regarding the increment.</p>
<h3>Example</h3>
<pre><code class="language-rust">let mut x = 0.0;
while x &lt; 42.0 {
    x += 1.0;
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let mut x = 0;
while x &lt; 42 {
    x += 1;
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.80.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+while_float">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L425">View Source</a></div></div></div></article><article id="while_immutable_condition"><input id="label-while_immutable_condition" type="checkbox"><label for="label-while_immutable_condition"><h2 class="lint-title"><div class="panel-title-name" id="lint-while_immutable_condition">while_immutable_condition
<a href="#while_immutable_condition" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks whether variables used within while loop condition
can be (and are) mutated in the body.</p>
<h3>Why is this bad?</h3>
<p>If the condition is unchanged, entering the body of the loop
will lead to an infinite loop.</p>
<h3>Known problems</h3>
<p>If the <code>while</code>-loop is in a closure, the check for mutation of the
condition variables in the body can cause false negatives. For example when only <code>Upvar</code> <code>a</code> is
in the condition and only <code>Upvar</code> <code>b</code> gets mutated in the body, the lint will not trigger.</p>
<h3>Example</h3>
<pre><code class="language-rust">let i = 0;
while i &gt; 10 {
    println!("let me loop forever!");
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+while_immutable_condition">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L398">View Source</a></div></div></div></article><article id="while_let_loop"><input id="label-while_let_loop" type="checkbox"><label for="label-while_let_loop"><h2 class="lint-title"><div class="panel-title-name" id="lint-while_let_loop">while_let_loop
<a href="#while_let_loop" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Detects <code>loop + match</code> combinations that are easier
written as a <code>while let</code> loop.</p>
<h3>Why is this bad?</h3>
<p>The <code>while let</code> loop is usually shorter and more
readable.</p>
<h3>Example</h3>
<pre><code class="language-rust">let y = Some(1);
loop {
    let x = match y {
        Some(x) =&gt; x,
        None =&gt; break,
    };
    // ..
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let y = Some(1);
while let Some(x) = y {
    // ..
};
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">HasPlaceholders</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+while_let_loop">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L185">View Source</a></div></div></div></article><article id="while_let_on_iterator"><input id="label-while_let_on_iterator" type="checkbox"><label for="label-while_let_on_iterator"><h2 class="lint-title"><div class="panel-title-name" id="lint-while_let_on_iterator">while_let_on_iterator
<a href="#while_let_on_iterator" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>while let</code> expressions on iterators.</p>
<h3>Why is this bad?</h3>
<p>Readability. A simple <code>for</code> loop is shorter and conveys
the intent better.</p>
<h3>Example</h3>
<pre><code class="language-rust">while let Some(val) = iter.next() {
    ..
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">for val in &amp;mut iter {
    ..
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+while_let_on_iterator">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/loops/mod.rs#L284">View Source</a></div></div></div></article><article id="wildcard_dependencies"><input id="label-wildcard_dependencies" type="checkbox"><label for="label-wildcard_dependencies"><h2 class="lint-title"><div class="panel-title-name" id="lint-wildcard_dependencies">wildcard_dependencies
<a href="#wildcard_dependencies" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-cargo">cargo</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for wildcard dependencies in the <code>Cargo.toml</code>.</p>
<h3>Why is this bad?</h3>
<p><a href="https://rust-lang-nursery.github.io/edition-guide/rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html">As the edition guide says</a>,
it is highly unlikely that you work with any possible version of your dependency,
and wildcard dependencies would cause unnecessary breakage in the ecosystem.</p>
<h3>Example</h3>
<pre><code class="language-toml">[dependencies]
regex = "*"
</code></pre>
<p>Use instead:</p>
<pre><code class="language-toml">[dependencies]
some_crate_1 = "~1.2.3"

some_crate_2 = "=1.2.3"
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.32.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+wildcard_dependencies">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/cargo/mod.rs#L150">View Source</a></div></div></div></article><article id="wildcard_enum_match_arm"><input id="label-wildcard_enum_match_arm" type="checkbox"><label for="label-wildcard_enum_match_arm"><h2 class="lint-title"><div class="panel-title-name" id="lint-wildcard_enum_match_arm">wildcard_enum_match_arm
<a href="#wildcard_enum_match_arm" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-restriction">restriction</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for wildcard enum matches using <code>_</code>.</p>
<h3>Why restrict this?</h3>
<p>New enum variants added by library updates can be missed.</p>
<h3>Known problems</h3>
<p>Suggested replacements may be incorrect if guards exhaustively cover some
variants, and also may not use correct path to enum if it’s not present in the current scope.</p>
<h3>Example</h3>
<pre><code class="language-rust">match x {
    Foo::A(_) =&gt; {},
    _ =&gt; {},
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">match x {
    Foo::A(_) =&gt; {},
    Foo::B(_) =&gt; {},
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.34.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+wildcard_enum_match_arm">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L261">View Source</a></div></div></div></article><article id="wildcard_imports"><input id="label-wildcard_imports" type="checkbox"><label for="label-wildcard_imports"><h2 class="lint-title"><div class="panel-title-name" id="lint-wildcard_imports">wildcard_imports
<a href="#wildcard_imports" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for wildcard imports <code>use _::*</code>.</p>
<h3>Why is this bad?</h3>
<p>wildcard imports can pollute the namespace. This is especially bad if
you try to import something through a wildcard, that already has been imported by name from
a different source:</p>
<pre><code class="language-rust">use crate1::foo; // Imports a function named foo
use crate2::*; // Has a function named foo

foo(); // Calls crate1::foo
</code></pre>
<p>This can lead to confusing error messages at best and to unexpected behavior at worst.</p>
<h3>Exceptions</h3>
<p>Wildcard imports are allowed from modules that their name contains <code>prelude</code>. Many crates
(including the standard library) provide modules named “prelude” specifically designed
for wildcard import.</p>
<p>Wildcard imports reexported through <code>pub use</code> are also allowed.</p>
<p><code>use super::*</code> is allowed in test modules. This is defined as any module with “test” in the name.</p>
<p>These exceptions can be disabled using the <code>warn-on-all-wildcard-imports</code> configuration flag.</p>
<h3>Known problems</h3>
<p>If macros are imported through the wildcard, this macro is not included
by the suggestion and has to be added by hand.</p>
<p>Applying the suggestion when explicit imports of the things imported with a glob import
exist, may result in <code>unused_imports</code> warnings.</p>
<h3>Example</h3>
<pre><code class="language-rust">use crate1::*;

foo();
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use crate1::foo;

foo();
</code></pre>
<h3>Configuration</h3>
<ul>
<li><code>allowed-wildcard-imports</code>:  List of path segments allowed to have wildcard imports.</li>
</ul>
<h4>Example</h4>
<pre><code class="language-toml">allowed-wildcard-imports = [ "utils", "common" ]
</code></pre>
<h4>Noteworthy</h4>
<ol>
<li>This configuration has no effects if used with <code>warn_on_all_wildcard_imports = true</code>.</li>
<li>Paths with any segment that containing the word ‘prelude’
are already allowed by default.</li>
</ol>
<p>(default: <code>[]</code>)</p>
<ul>
<li>
<p><code>warn-on-all-wildcard-imports</code>:  Whether to emit warnings on all wildcard imports, including those from <code>prelude</code>, from <code>super</code> in tests,
or for <code>pub use</code> reexports.</p>
<p>(default: <code>false</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.43.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+wildcard_imports">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/wildcard_imports.rs#L48">View Source</a></div></div></div></article><article id="wildcard_in_or_patterns"><input id="label-wildcard_in_or_patterns" type="checkbox"><label for="label-wildcard_in_or_patterns"><h2 class="lint-title"><div class="panel-title-name" id="lint-wildcard_in_or_patterns">wildcard_in_or_patterns
<a href="#wildcard_in_or_patterns" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for wildcard pattern used with others patterns in same match arm.</p>
<h3>Why is this bad?</h3>
<p>Wildcard pattern already covers any other pattern as it will match anyway.
It makes the code less readable, especially to spot wildcard pattern use in match arm.</p>
<h3>Example</h3>
<pre><code class="language-rust">match s {
    "a" =&gt; {},
    "bar" | _ =&gt; {},
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">match s {
    "a" =&gt; {},
    _ =&gt; {},
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.42.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+wildcard_in_or_patterns">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/matches/mod.rs#L335">View Source</a></div></div></div></article><article id="write_literal"><input id="label-write_literal" type="checkbox"><label for="label-write_literal"><h2 class="lint-title"><div class="panel-title-name" id="lint-write_literal">write_literal
<a href="#write_literal" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint warns about the use of literals as <code>write!</code>/<code>writeln!</code> args.</p>
<h3>Why is this bad?</h3>
<p>Using literals as <code>writeln!</code> args is inefficient
(c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary
(i.e., just put the literal in the format string)</p>
<h3>Example</h3>
<pre><code class="language-rust">writeln!(buf, "{}", "foo");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">writeln!(buf, "foo");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+write_literal">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/write/mod.rs#L210">View Source</a></div></div></div></article><article id="write_with_newline"><input id="label-write_with_newline" type="checkbox"><label for="label-write_with_newline"><h2 class="lint-title"><div class="panel-title-name" id="lint-write_with_newline">write_with_newline
<a href="#write_with_newline" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint warns when you use <code>write!()</code> with a format
string that
ends in a newline.</p>
<h3>Why is this bad?</h3>
<p>You should use <code>writeln!()</code> instead, which appends the
newline.</p>
<h3>Example</h3>
<pre><code class="language-rust">write!(buf, "Hello {}!\n", name);
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">writeln!(buf, "Hello {}!", name);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+write_with_newline">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/write/mod.rs#L179">View Source</a></div></div></div></article><article id="writeln_empty_string"><input id="label-writeln_empty_string" type="checkbox"><label for="label-writeln_empty_string"><h2 class="lint-title"><div class="panel-title-name" id="lint-writeln_empty_string">writeln_empty_string
<a href="#writeln_empty_string" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>This lint warns when you use <code>writeln!(buf, "")</code> to
print a newline.</p>
<h3>Why is this bad?</h3>
<p>You should use <code>writeln!(buf)</code>, which is simpler.</p>
<h3>Example</h3>
<pre><code class="language-rust">writeln!(buf, "");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">writeln!(buf);
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+writeln_empty_string">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/write/mod.rs#L152">View Source</a></div></div></div></article><article id="wrong_pub_self_convention"><input id="label-wrong_pub_self_convention" type="checkbox"><label for="label-wrong_pub_self_convention"><h2 class="lint-title"><div class="panel-title-name" id="lint-wrong_pub_self_convention">wrong_pub_self_convention
<a href="#wrong_pub_self_convention" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-deprecated">deprecated</span> <span class="label lint-level level-none">none</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Nothing. This lint has been deprecated</p>
<h3>Deprecation reason</h3>
<p><code>clippy::wrong_self_convention</code> now covers this case via the <code>avoid-breaking-exported-api</code> config.</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Deprecated in: <span class="label label-default label-version">1.54.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+wrong_pub_self_convention">Related Issues</a></div></div></div></article><article id="wrong_self_convention"><input id="label-wrong_self_convention" type="checkbox"><label for="label-wrong_self_convention"><h2 class="lint-title"><div class="panel-title-name" id="lint-wrong_self_convention">wrong_self_convention
<a href="#wrong_self_convention" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for methods with certain name prefixes or suffixes, and which
do not adhere to standard conventions regarding how <code>self</code> is taken.
The actual rules are:</p>
<table class="table"><thead><tr><th>Prefix</th><th>Postfix</th><th><code>self</code> taken</th><th><code>self</code> type</th></tr></thead><tbody>
<tr><td><code>as_</code></td><td>none</td><td><code>&amp;self</code> or <code>&amp;mut self</code></td><td>any</td></tr>
<tr><td><code>from_</code></td><td>none</td><td>none</td><td>any</td></tr>
<tr><td><code>into_</code></td><td>none</td><td><code>self</code></td><td>any</td></tr>
<tr><td><code>is_</code></td><td>none</td><td><code>&amp;mut self</code> or <code>&amp;self</code> or none</td><td>any</td></tr>
<tr><td><code>to_</code></td><td><code>_mut</code></td><td><code>&amp;mut self</code></td><td>any</td></tr>
<tr><td><code>to_</code></td><td>not <code>_mut</code></td><td><code>self</code></td><td><code>Copy</code></td></tr>
<tr><td><code>to_</code></td><td>not <code>_mut</code></td><td><code>&amp;self</code></td><td>not <code>Copy</code></td></tr>
</tbody></table>
<p>Note: Clippy doesn’t trigger methods with <code>to_</code> prefix in:</p>
<ul>
<li>Traits definition.
Clippy can not tell if a type that implements a trait is <code>Copy</code> or not.</li>
<li>Traits implementation, when <code>&amp;self</code> is taken.
The method signature is controlled by the trait and often <code>&amp;self</code> is required for all types that implement the trait
(see e.g. the <code>std::string::ToString</code> trait).</li>
</ul>
<p>Clippy allows <code>Pin&lt;&amp;Self&gt;</code> and <code>Pin&lt;&amp;mut Self&gt;</code> if <code>&amp;self</code> and <code>&amp;mut self</code> is required.</p>
<p>Please find more info here:
https://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv</p>
<h3>Why is this bad?</h3>
<p>Consistency breeds readability. If you follow the
conventions, your users won’t be surprised that they, e.g., need to supply a
mutable reference to a <code>as_..</code> function.</p>
<h3>Example</h3>
<pre><code class="language-rust">impl X {
    fn as_str(self) -&gt; &amp;'static str {
        // ..
    }
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">impl X {
    fn as_str(&amp;self) -&gt; &amp;'static str {
        // ..
    }
}
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>avoid-breaking-exported-api</code>:  Suppress lints whenever the suggested change would cause breakage for other crates.</p>
<p>(default: <code>true</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+wrong_self_convention">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L416">View Source</a></div></div></div></article><article id="wrong_transmute"><input id="label-wrong_transmute" type="checkbox"><label for="label-wrong_transmute"><h2 class="lint-title"><div class="panel-title-name" id="lint-wrong_transmute">wrong_transmute
<a href="#wrong_transmute" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for transmutes that can’t ever be correct on any
architecture.</p>
<h3>Why is this bad?</h3>
<p>It’s basically guaranteed to be undefined behavior.</p>
<h3>Known problems</h3>
<p>When accessing C, users might want to store pointer
sized objects in <code>extradata</code> arguments to save an allocation.</p>
<h3>Example</h3>
<pre><code class="language-rust">let ptr: *const T = core::intrinsics::transmute('x')
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+wrong_transmute">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/transmute/mod.rs#L29">View Source</a></div></div></div></article><article id="zero_divided_by_zero"><input id="label-zero_divided_by_zero" type="checkbox"><label for="label-zero_divided_by_zero"><h2 class="lint-title"><div class="panel-title-name" id="lint-zero_divided_by_zero">zero_divided_by_zero
<a href="#zero_divided_by_zero" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>0.0 / 0.0</code>.</p>
<h3>Why is this bad?</h3>
<p>It’s less readable than <code>f32::NAN</code> or <code>f64::NAN</code>.</p>
<h3>Example</h3>
<pre><code class="language-rust">let nan = 0.0f32 / 0.0;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let nan = f32::NAN;
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+zero_divided_by_zero">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/zero_div_zero.rs#L7">View Source</a></div></div></div></article><article id="zero_prefixed_literal"><input id="label-zero_prefixed_literal" type="checkbox"><label for="label-zero_prefixed_literal"><h2 class="lint-title"><div class="panel-title-name" id="lint-zero_prefixed_literal">zero_prefixed_literal
<a href="#zero_prefixed_literal" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-complexity">complexity</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Warns if an integral constant literal starts with <code>0</code>.</p>
<h3>Why is this bad?</h3>
<p>In some languages (including the infamous C language
and most of its
family), this marks an octal constant. In Rust however, this is a decimal
constant. This could
be confusing for both the writer and a reader of the constant.</p>
<h3>Example</h3>
<p>In Rust:</p>
<pre><code class="language-rust">fn main() {
    let a = 0123;
    println!("{}", a);
}
</code></pre>
<p>prints <code>123</code>, while in C:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a = 0123;
    printf("%d\n", a);
}
</code></pre>
<p>prints <code>83</code> (as <code>83 == 0o123</code> while <code>123 == 0o173</code>).</p>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+zero_prefixed_literal">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/misc_early/mod.rs#L144">View Source</a></div></div></div></article><article id="zero_ptr"><input id="label-zero_ptr" type="checkbox"><label for="label-zero_ptr"><h2 class="lint-title"><div class="panel-title-name" id="lint-zero_ptr">zero_ptr
<a href="#zero_ptr" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-style">style</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Catch casts from <code>0</code> to some pointer type</p>
<h3>Why is this bad?</h3>
<p>This generally means <code>null</code> and is better expressed as
{<code>std</code>, <code>core</code>}<code>::ptr::</code>{<code>null</code>, <code>null_mut</code>}.</p>
<h3>Example</h3>
<pre><code class="language-rust">let a = 0 as *const u32;
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">let a = std::ptr::null::&lt;u32&gt;();
</code></pre>
<h3>Configuration</h3>
<ul>
<li>
<p><code>msrv</code>:  The minimum rust version that the project supports. Defaults to the <code>rust-version</code> field in <code>Cargo.toml</code></p>
<p>(default: <code>current version</code>)</p>
</li>
</ul>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MachineApplicable</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">pre 1.29.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+zero_ptr">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/casts/mod.rs#L691">View Source</a></div></div></div></article><article id="zero_repeat_side_effects"><input id="label-zero_repeat_side_effects" type="checkbox"><label for="label-zero_repeat_side_effects"><h2 class="lint-title"><div class="panel-title-name" id="lint-zero_repeat_side_effects">zero_repeat_side_effects
<a href="#zero_repeat_side_effects" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for array or vec initializations which contain an expression with side effects,
but which have a repeat count of zero.</p>
<h3>Why is this bad?</h3>
<p>Such an initialization, despite having a repeat length of 0, will still call the inner function.
This may not be obvious and as such there may be unintended side effects in code.</p>
<h3>Example</h3>
<pre><code class="language-rust">fn side_effect() -&gt; i32 {
    println!("side effect");
    10
}
let a = [side_effect(); 0];
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn side_effect() -&gt; i32 {
    println!("side effect");
    10
}
side_effect();
let a: [i32; 0] = [];
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.79.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+zero_repeat_side_effects">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/zero_repeat_side_effects.rs#L13">View Source</a></div></div></div></article><article id="zero_sized_map_values"><input id="label-zero_sized_map_values" type="checkbox"><label for="label-zero_sized_map_values"><h2 class="lint-title"><div class="panel-title-name" id="lint-zero_sized_map_values">zero_sized_map_values
<a href="#zero_sized_map_values" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-pedantic">pedantic</span> <span class="label lint-level level-allow">allow</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for maps with zero-sized value types anywhere in the code.</p>
<h3>Why is this bad?</h3>
<p>Since there is only a single value for a zero-sized type, a map
containing zero sized values is effectively a set. Using a set in that case improves
readability and communicates intent more clearly.</p>
<h3>Known problems</h3>
<ul>
<li>A zero-sized type cannot be recovered later if it contains private fields.</li>
<li>This lints the signature of public items</li>
</ul>
<h3>Example</h3>
<pre><code class="language-rust">fn unique_words(text: &amp;str) -&gt; HashMap&lt;&amp;str, ()&gt; {
    todo!();
}
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">fn unique_words(text: &amp;str) -&gt; HashSet&lt;&amp;str&gt; {
    todo!();
}
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.50.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+zero_sized_map_values">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/zero_sized_map_values.rs#L11">View Source</a></div></div></div></article><article id="zombie_processes"><input id="label-zombie_processes" type="checkbox"><label for="label-zombie_processes"><h2 class="lint-title"><div class="panel-title-name" id="lint-zombie_processes">zombie_processes
<a href="#zombie_processes" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-suspicious">suspicious</span> <span class="label lint-level level-warn">warn</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Looks for code that spawns a process but never calls <code>wait()</code> on the child.</p>
<h3>Why is this bad?</h3>
<p>As explained in the <a href="https://doc.rust-lang.org/stable/std/process/struct.Child.html#warning">standard library documentation</a>,
calling <code>wait()</code> is necessary on Unix platforms to properly release all OS resources associated with the process.
Not doing so will effectively leak process IDs and/or other limited global resources,
which can eventually lead to resource exhaustion, so it’s recommended to call <code>wait()</code> in long-running applications.
Such processes are called “zombie processes”.</p>
<p>To reduce the rate of false positives, if the spawned process is assigned to a binding, the lint actually works the other way around; it
conservatively checks that all uses of a variable definitely don’t call <code>wait()</code> and only then emits a warning.
For that reason, a seemingly unrelated use can get called out as calling <code>wait()</code> in help messages.</p>
<h3>Control flow</h3>
<p>If a <code>wait()</code> call exists in an if/then block but not in the else block (or there is no else block),
then this still gets linted as not calling <code>wait()</code> in all code paths.
Likewise, when early-returning from the function, <code>wait()</code> calls that appear after the return expression
are also not accepted.
In other words, the <code>wait()</code> call must be unconditionally reachable after the spawn expression.</p>
<h3>Example</h3>
<pre><code class="language-rust">use std::process::Command;

let _child = Command::new("ls").spawn().expect("failed to execute child");
</code></pre>
<p>Use instead:</p>
<pre><code class="language-rust">use std::process::Command;

let mut child = Command::new("ls").spawn().expect("failed to execute child");
child.wait().expect("failed to wait on child");
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">MaybeIncorrect</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.83.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+zombie_processes">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/zombie_processes.rs#L17">View Source</a></div></div></div></article><article id="zst_offset"><input id="label-zst_offset" type="checkbox"><label for="label-zst_offset"><h2 class="lint-title"><div class="panel-title-name" id="lint-zst_offset">zst_offset
<a href="#zst_offset" class="anchor label label-default">&para;</a> <a href="" class="copy-to-clipboard anchor label label-default">&#128203;</a></div><span class="label label-default lint-group group-correctness">correctness</span> <span class="label lint-level level-deny">deny</span> <span class="label doc-folding"></span></h2></label><div class="lint-docs"><div class="lint-doc-md"><h3>What it does</h3>
<p>Checks for <code>offset(_)</code>, <code>wrapping_</code>{<code>add</code>, <code>sub</code>}, etc. on raw pointers to
zero-sized types</p>
<h3>Why is this bad?</h3>
<p>This is a no-op, and likely unintended</p>
<h3>Example</h3>
<pre><code class="language-rust">unsafe { (&amp;() as *const ()).offset(1) };
</code></pre>
</div><div class="lint-additional-info"><div>Applicability: <span class="label label-default applicability">Unspecified</span><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants">(?)</a></div><div>Added in: <span class="label label-default label-version">1.41.0</span></div><div><a href="https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+zst_offset">Related Issues</a></div><div><a href="https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/methods/mod.rs#L1714">View Source</a></div></div></div></article></div><a aria-label="View source on GitHub" class="github-corner" href="https://github.com/rust-lang/rust-clippy" rel="noopener noreferrer" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" style="position: absolute; top: 0; border: 0; right: 0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z" fill="var(--theme-color)"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></body></html>