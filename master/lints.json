[
  {
    "docs": {
      "What it does": "This lint checks for floating point literals that approximate constants which are defined in [`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants) or [`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants), respectively, suggesting to use the predefined constant.", 
      "Why is this bad": "Usually, the definition in the standard library is more precise than what people come up with. If you find that your definition is actually more precise, please [file a Rust issue](https://github.com/rust-lang/rust/issues).", 
      "Example": "```rust\nlet x = 3.14;\n```", 
      "Known problems": "If you happen to have a value that is within 1/8192 of a known constant, but is not *and should not* be the same, this lint will report your value anyway. We have not yet noticed any false positives in code we tested clippy with (this includes servo), but YMMV."
    }, 
    "id": "approx_constant", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for plain integer arithmetic", 
      "Why is this bad": "This is only checked against overflow in debug builds.\nIn some applications one wants explicitly checked, wrapping or saturating\narithmetic.", 
      "Example": "```rust\na + 1\n```", 
      "Known problems": "None"
    }, 
    "id": "integer_arithmetic", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for float arithmetic", 
      "Why is this bad": "For some embedded systems or kernel development, it\ncan be useful to rule out floating-point numbers", 
      "Example": "```rust\na + 1.0\n```", 
      "Known problems": "None"
    }, 
    "id": "float_arithmetic", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "Check for out of bounds array indexing with a constant index.", 
      "Why is this bad": "This will always panic at runtime.", 
      "Example": "```rust\nlet x = [1,2,3,4];\n...\nx[9];\n&x[2..9];\n```", 
      "Known problems": "Hopefully none."
    }, 
    "id": "out_of_bounds_indexing", 
    "level": "Deny"
  }, 
  {
    "docs": {
      "What it does": "Check for usage of indexing or slicing.", 
      "Why is this bad": "Usually, this can be safely allowed. However,\nin some domains such as kernel development, a panic can cause the\nwhole operating system to crash.", 
      "Example": "```rust\n...\nx[2];\n&x[0..2];\n```", 
      "Known problems": "Hopefully none."
    }, 
    "id": "indexing_slicing", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for `+=` operations and similar.", 
      "Why is this bad": "Projects with many developers from languages without those operations may\nfind them unreadable and not worth their weight.", 
      "Example": "```rust\na += 1;\n```", 
      "Known problems": "Types implementing `OpAssign` don't necessarily implement `Op`."
    }, 
    "id": "assign_ops", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "Check for `a = a op b` or `a = b commutative_op a` patterns.", 
      "Why is this bad": "These can be written as the shorter `a op= b`.", 
      "Example": "```rust\nlet mut a = 5;\n...\na = a + b;\n```", 
      "Known problems": "While forbidden by the spec, `OpAssign` traits may have implementations that differ from the regular `Op` impl."
    }, 
    "id": "assign_op_pattern", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "Check for `a op= a op b` or `a op= b op a` patterns.", 
      "Why is this bad": "Most likely these are bugs where one meant to write `a op= b`", 
      "Example": "```rust\nlet mut a = 5;\n...\na += a + b;\n```", 
      "Known problems": "Someone might actually mean `a op= a op b`, but that should rather be written as `a = (2 * a) op b` where applicable."
    }, 
    "id": "misrefactored_assign_op", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for items annotated with `#[inline(always)]`, unless the annotated function is empty or simply panics.", 
      "Why is this bad": "While there are valid uses of this annotation (and once you know when to use it, by all means `allow` this lint), it's a common newbie-mistake to pepper one's code with it.\nAs a rule of thumb, before slapping `#[inline(always)]` on a function, measure if that additional function call really affects your runtime profile sufficiently to make up for the increase in compile time.", 
      "Example": "```rust\n#[inline(always)]\nfn not_quite_hot_code(..) { ... }\n```", 
      "Known problems": "False positives, big time. This lint is meant to be deactivated by everyone doing serious performance work. This means having done the measurement."
    }, 
    "id": "inline_always", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for `#[deprecated]` annotations with a `since` field that is not a valid semantic version..", 
      "Why is this bad": "For checking the version of the deprecation, it must be valid semver. Failing that, the contained information is useless.", 
      "Example": "```rust\n#[deprecated(since = \"forever\")]\nfn something_else(..) { ... }\n```", 
      "Known problems": "None"
    }, 
    "id": "deprecated_semver", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for incompatible bit masks in comparisons.\nThe formula for detecting if an expression of the type  `_ <bit_op> m <cmp_op> c` (where `<bit_op>`\nis one of {`&`, `|`} and `<cmp_op>` is one of {`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following table:\n|Comparison  |Bit Op|Example     |is always|Formula               |\n|------------|------|------------|---------|----------------------|\n|`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n|`<`  or `>=`| `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n|`>`  or `<=`| `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n|`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n|`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n|`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |", 
      "Why is this bad": "If the bits that the comparison cares about are always set to zero or one by the bit mask, the comparison is constant `true` or `false` (depending on mask, compared value, and operators).\nSo the code is actively misleading, and the only reason someone would write this intentionally is to win an underhanded Rust contest or create a test-case for this lint.", 
      "Example": "```rust\nif (x & 1 == 2) { \u2026 }\n```", 
      "Known problems": "None"
    }, 
    "id": "bad_bit_mask", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for bit masks in comparisons which can be removed without changing the outcome. The basic structure can be seen in the following table:\n|Comparison| Bit Op  |Example    |equals |\n|----------|---------|-----------|-------|\n|`>` / `<=`|`|` / `^`|`x | 2 > 3`|`x > 3`|\n|`<` / `>=`|`|` / `^`|`x ^ 1 < 4`|`x < 4`|", 
      "Why is this bad": "Not equally evil as [`bad_bit_mask`](#bad_bit_mask), but still a bit misleading, because the bit mask is ineffective.", 
      "Example": "```rust\nif (x | 1 > 3) { \u2026 }\n```", 
      "Known problems": "False negatives: This lint will only match instances where we have figured out the math (which is for a power-of-two compared value). This means things like `x | 1 >= 7` (which would be better written as `x >= 6`) will not be reported (but bit masks like this are fairly uncommon)."
    }, 
    "id": "ineffective_bit_mask", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lints about usage of blacklisted names.", 
      "Why is this bad": "These names are usually placeholder names and should be avoided.", 
      "Configuration": "This lint has the following configuration variables:\n\n* `blacklisted-names: Vec<String>`: The list of blacklisted names to lint about (defaults to `[\"foo\", \"bar\", \"baz\"]`).", 
      "Example": "```rust\nlet foo = 3.14;\n```", 
      "Known problems": "None."
    }, 
    "id": "blacklisted_name", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for `if` conditions that use blocks to contain an expression.", 
      "Why is this bad": "It isn't really rust style, same as using parentheses to contain expressions.", 
      "Example": "```rust\nif { true } ..\n```", 
      "Known problems": "None"
    }, 
    "id": "block_in_if_condition_expr", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for `if` conditions that use blocks containing statements, or conditions that use closures with blocks.", 
      "Why is this bad": "Using blocks in the condition makes it hard to read.", 
      "Example": "```rust\nif { let x = somefunc(); x } ..\n// or\nif somefunc(|x| { x == 47 }) ..\n```", 
      "Known problems": "None"
    }, 
    "id": "block_in_if_condition_stmt", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for boolean expressions that can be written more concisely.", 
      "Why is this bad": "Readability of boolean expressions suffers from unnecessary duplication.", 
      "Example": "`if a && true` should be `if a` and `!(a == b)` should be `a != b`", 
      "Known problems": "Ignores short circuiting behavior of `||` and `&&`. Ignores `|`, `&` and `^`."
    }, 
    "id": "nonminimal_bool", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for boolean expressions that contain terminals that can be eliminated.", 
      "Why is this bad": "This is most likely a logic bug.", 
      "Example": "The `b` in `if a && b || a` is unnecessary because the expression is equivalent to `if a`", 
      "Known problems": "Ignores short circuiting behavior."
    }, 
    "id": "logic_bug", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for nested `if`-statements which can be collapsed by\n`&&`-combining their conditions and for `else { if .. }` expressions that can be collapsed to\n`else if ..`.", 
      "Why is this bad": "Each `if`-statement adds one level of nesting, which makes code look more complex than it really is.", 
      "Example": "```rust\nif x {\n    if y {\n        \u2026\n    }\n}\n// or\nif x {\n    \u2026\n} else {\n    if y {\n        \u2026\n    }\n}\n```\nShould be written:\n```rust\nif x && y {\n    \u2026\n}\n// or\nif x {\n    \u2026\n} else if y {\n    \u2026\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "collapsible_if", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for consecutive `ifs` with the same condition.", 
      "Why is this bad": "This is probably a copy & paste error.", 
      "Example": "```rust\nif a == b {\n    \u2026\n} else if a == b {\n    \u2026\n}\n```\nNote that this lint ignores all conditions with a function call as it could have side effects:\n```rust\nif foo() {\n    \u2026\n} else if foo() { // not linted\n    \u2026\n}\n```", 
      "Known problems": "Hopefully none."
    }, 
    "id": "ifs_same_cond", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for `if/else` with the same body as the *then* part and the\n*else* part.", 
      "Why is this bad": "This is probably a copy & paste error.", 
      "Example": "```rust\nlet foo = if \u2026 {\n    42\n} else {\n    42\n};\n```", 
      "Known problems": "Hopefully none."
    }, 
    "id": "if_same_then_else", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for `match` with identical arm bodies.", 
      "Why is this bad": "This is probably a copy & paste error. If arm bodies are the same on\npurpose, you can factor them\n[using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).", 
      "Example": "```rust,ignore\nmatch foo {\n    Bar => bar(),\n    Quz => quz(),\n    Baz => bar(), // <= oops\n}\n```\nThis should probably be\n```rust,ignore\nmatch foo {\n    Bar => bar(),\n    Quz => quz(),\n    Baz => baz(), // <= fixed\n}\n```\nor if the original code was not a typo:\n```rust,ignore\nmatch foo {\n    Bar | Baz => bar(), // <= shows the intent better\n    Quz => quz(),\n}\n```", 
      "Known problems": "False positive possible with order dependent `match`\n(see issue [#860](https://github.com/Manishearth/rust-clippy/issues/860))."
    }, 
    "id": "match_same_arms", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for methods with high cyclomatic complexity", 
      "Why is this bad": "Methods of high cyclomatic complexity tend to be badly readable. Also LLVM\nwill usually optimize small methods better.", 
      "Configuration": "This lint has the following configuration variables:\n\n* `cyclomatic-complexity-threshold: u64`: The maximum cyclomatic complexity a function can have (defaults to `25`).", 
      "Example": "No. You'll see it when you get the warning.", 
      "Known problems": "Sometimes it's hard to find a way to reduce the complexity"
    }, 
    "id": "cyclomatic_complexity", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "Nothing. This lint has been deprecated.", 
      "Deprecation reason": "This used to check for `Vec::as_slice`, which was unstable with good\nstable alternatives. `Vec::as_slice` has now been stabilized."
    }, 
    "id": "unstable_as_slice", 
    "level": "Deprecated"
  }, 
  {
    "docs": {
      "What it does": "Nothing. This lint has been deprecated.", 
      "Deprecation reason": "This used to check for `Vec::as_mut_slice`, which was unstable with good\nstable alternatives. `Vec::as_mut_slice` has now been stabilized."
    }, 
    "id": "unstable_as_mut_slice", 
    "level": "Deprecated"
  }, 
  {
    "docs": {
      "What it does": "Nothing. This lint has been deprecated.", 
      "Deprecation reason": "This used to check for `.to_string()` method calls on values\nof type `&str`. This is not unidiomatic and with specialization coming, `to_string` could be\nspecialized to be as efficient as `to_owned`."
    }, 
    "id": "str_to_string", 
    "level": "Deprecated"
  }, 
  {
    "docs": {
      "What it does": "Nothing. This lint has been deprecated.", 
      "Deprecation reason": "This used to check for `.to_string()` method calls on values\nof type `String`. This is not unidiomatic and with specialization coming, `to_string` could be\nspecialized to be as efficient as `clone`."
    }, 
    "id": "string_to_string", 
    "level": "Deprecated"
  }, 
  {
    "docs": {
      "What it does": "This lint warns about deriving `Hash` but implementing `PartialEq`\nexplicitly.", 
      "Why is this bad": "The implementation of these traits must agree (for example for use with\n`HashMap`) so it\u2019s probably a bad idea to use a default-generated `Hash` implementation  with\nan explicitly defined `PartialEq`. In particular, the following must hold for any type:\n```rust\nk1 == k2 \u21d2 hash(k1) == hash(k2)\n```", 
      "Example": "```rust\n#[derive(Hash)]\nstruct Foo;\nimpl PartialEq for Foo {\n    ..\n}\n```", 
      "Known problems": "None."
    }, 
    "id": "derive_hash_xor_eq", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint warns about explicit `Clone` implementation for `Copy` types.", 
      "Why is this bad": "To avoid surprising behaviour, these traits should agree and the behaviour\nof `Copy` cannot be overridden. In almost all situations a `Copy` type should have a `Clone`\nimplementation that does nothing more than copy the object, which is what\n`#[derive(Copy, Clone)]` gets you.", 
      "Example": "```rust\n#[derive(Copy)]\nstruct Foo;\nimpl Clone for Foo {\n    ..\n}\n```", 
      "Known problems": "None."
    }, 
    "id": "expl_impl_clone_on_copy", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for the presence of `_`, `::` or camel-case words outside\nticks in documentation.", 
      "Why is this bad": "*Rustdoc* supports markdown formatting, `_`, `::` and camel-case probably\nindicates some code which should be included between ticks. `_` can also be used for empasis in\nmarkdown, this lint tries to consider that.", 
      "Configuration": "This lint has the following configuration variables:\n\n* `doc-valid-idents: Vec<String>`: The list of words this lint should not consider as identifiers needing ticks (defaults to `[\"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"GitHub\", \"NaN\", \"GPLv2\", \"GPLv3\", \"JavaScript\", \"IPv4\", \"IPv6\", \"OAuth\", \"TrueType\"]`).", 
      "Examples": "```rust\n/// Do something with the foo_bar parameter. See also that::other::module::foo.\n// ^ `foo_bar` and `that::other::module::foo` should be ticked.\nfn doit(foo_bar) { .. }\n```", 
      "Known problems": "Lots of bad docs won\u2019t be fixed, what the lint checks for is limited."
    }, 
    "id": "doc_markdown", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for calls to `std::mem::drop` with a reference instead of an owned value.", 
      "Why is this bad": "Calling `drop` on a reference will only drop the reference itself, which is a no-op. It will not call the `drop` method (from the `Drop` trait implementation) on the underlying referenced value, which is likely what was intended.", 
      "Example": "```rust\nlet mut lock_guard = mutex.lock();\nstd::mem::drop(&lock_guard) // Should have been drop(lock_guard), mutex still locked\noperation_that_requires_mutex_to_be_unlocked();\n```", 
      "Known problems": "None"
    }, 
    "id": "drop_ref", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for uses of `contains_key` + `insert` on `HashMap` or\n`BTreeMap`.", 
      "Why is this bad": "Using `entry` is more efficient.", 
      "Example": "```rust\nif !m.contains_key(&k) { m.insert(k, v) }\n```\ncan be rewritten as:\n```rust\nm.entry(k).or_insert(v);\n```", 
      "Known problems": "Some false negatives, eg.:\n```rust\nlet k = &key;\nif !m.contains_key(k) { m.insert(k.clone(), v); }\n```"
    }, 
    "id": "map_entry", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "Lints on C-like enumerations that are `repr(isize/usize)` and have values\nthat don't fit into an `i32`.", 
      "Why is this bad": "This will truncate the variant value on 32 bit architectures, but works\nfine on 64 bit.", 
      "Example": "```rust\n#[repr(usize)]\nenum NonPortable {\n    X = 0x1_0000_0000,\n    Y = 0\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "enum_clike_unportable_variant", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "Warns when `use`ing all variants of an enumeration.", 
      "Why is this bad": "It is usually better style to use the prefixed name of an enumeration variant, rather than importing variants", 
      "Example": "```rust\nuse std::cmp::Ordering::*;\n```", 
      "Known problems": "Old-style enumerations that prefix the variants are still around"
    }, 
    "id": "enum_glob_use", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "Warns on enumeration variants that are prefixed or suffixed by the same\ncharacters.", 
      "Why is this bad": "Enumeration variant names should specify their variant, not repeat the\nenumeration name.", 
      "Configuration": "This lint has the following configuration variables:\n\n* `enum-variant-name-threshold: u64`: The minimum number of enum variants for the lints about variant names to trigger (defaults to `3`).", 
      "Example": "```rust\nenum Cake {\n    BlackForestCake,\n    HummingbirdCake,\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "enum_variant_names", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "Warns on type names that are prefixed or suffixed by the containing module's name", 
      "Why is this bad": "It requires the user to type the module name twice", 
      "Example": "```rust\nmod cake {\n    struct BlackForestCake;\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "stutter", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for equal operands to comparison, logical and bitwise,\ndifference and division binary operators (`==`, `>`, etc., `&&`, `||`, `&`, `|`, `^`, `-` and\n`/`).", 
      "Why is this bad": "This is usually just a typo or a copy and paste error.", 
      "Example": "```rust\nx + 1 == x + 1\n```", 
      "Known problems": "False negatives: We had some false positives regarding calls (notably\n[racer](https://github.com/phildawes/racer) had one instance of `x.pop() && x.pop()`), so we\nremoved matching any function or method calls. We may introduce a whitelist of known pure\nfunctions in the future."
    }, 
    "id": "eq_op", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for usage of `Box<T>` where an unboxed `T` would work fine.", 
      "Why is this bad": "This is an unnecessary allocation, and bad for performance. It is only\nnecessary to allocate if you wish to move the box into something.", 
      "Configuration": "This lint has the following configuration variables:\n\n* `too-large-for-stack: u64`: The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap (defaults to `200`).", 
      "Example": "```rust\nfn main() {\n    let x = Box::new(1);\n    foo(*x);\n    println!(\"{}\", *x);\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "boxed_local", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for closures which just call another function where the\nfunction can be called directly. `unsafe` functions or calls where types get adjusted are\nignored.", 
      "Why is this bad": "Needlessly creating a closure adds code for no\nbenefit and gives the optimizer more work.", 
      "Example": "`xs.map(|x| foo(x))` where `foo(_)` is a plain function that takes the exact\nargument type of `x`.", 
      "Known problems": "None"
    }, 
    "id": "redundant_closure", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lints about use of `format!(\"string literal with no argument\")` and\n`format!(\"{}\", foo)` where `foo` is a string.", 
      "Why is this bad": "There is no point of doing that. `format!(\"too\")` can be replaced by\n`\"foo\".to_owned()` if you really need a `String`. The even worse `&format!(\"foo\")` is often\nencountered in the wild. `format!(\"{}\", foo)` can be replaced by `foo.clone()` if `foo: String`\nor `foo.to_owned()` is `foo: &str`.", 
      "Examples": "`format!(\"foo\")` and `format!(\"{}\", foo)`", 
      "Known problems": "None."
    }, 
    "id": "useless_format", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint looks for use of the non-existent `=*`, `=!` and `=-` operators.", 
      "Why is this bad": "This is either a typo of `*=`, `!=` or `-=` or confusing.", 
      "Example": "```rust,ignore\na =- 42; // confusing, should it be `a -= 42` or `a = -42`?\n```", 
      "Known problems": "None."
    }, 
    "id": "suspicious_assignment_formatting", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for formatting of `else if`. It lints if the `else` and `if`\nare not on the same line or the `else` seems to be missing.", 
      "Why is this bad": "This is probably some refactoring remnant, even if the code is correct, it\nmight look confusing.", 
      "Example": "```rust,ignore\nif foo {\n} if bar { // looks like an `else` is missing here\n}\nif foo {\n} else\nif bar { // this is the `else` block of the previous `if`, but should it be?\n}\n```", 
      "Known problems": "None."
    }, 
    "id": "suspicious_else_formatting", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "Check for functions with too many parameters.", 
      "Why is this bad": "Functions with lots of parameters are considered bad style and reduce\nreadability (\u201cwhat does the 5th parameter mean?\u201d). Consider grouping some parameters into a\nnew type.", 
      "Configuration": "This lint has the following configuration variables:\n\n* `too-many-arguments-threshold: u64`: The maximum number of argument a function or method can have (defaults to `7`).", 
      "Example": "```rust\nfn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) { .. }\n```", 
      "Known problems": "None."
    }, 
    "id": "too_many_arguments", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "Check for public functions that dereferences raw pointer arguments but are\nnot marked unsafe.", 
      "Why is this bad": "The function should probably be marked `unsafe`, since for an arbitrary\nraw pointer, there is no way of telling for sure if it is valid.", 
      "Example": "```rust\npub fn foo(x: *const u8) { println!(\"{}\", unsafe { *x }); }\n```", 
      "Known problems": "* It does not check functions recursively so if the pointer is passed to a private non-\n`unsafe` function which does the dereferencing, the lint won't trigger.\n* It only checks for arguments whose type are raw pointers, not raw pointers got from an\nargument in some other way (`fn foo(bar: &[*const u8])` or `some_argument.get_raw_ptr()`)."
    }, 
    "id": "not_unsafe_ptr_arg_deref", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for identity operations, e.g. `x + 0`.", 
      "Why is this bad": "This code can be removed without changing the meaning. So it just obscures\nwhat's going on. Delete it mercilessly.", 
      "Example": "```rust\nx / 1 + 0 * 1 - 0 | 0\n```", 
      "Known problems": "None"
    }, 
    "id": "identity_op", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "Warns on the use of `!` or `!=` in an if condition with an else branch", 
      "Why is this bad": "Negations reduce the readability of statements", 
      "Example": "```rust\nif !v.is_empty() {\n    a()\n} else {\n    b()\n}\n```\nCould be written:\n```rust\nif v.is_empty() {\n    b()\n} else {\n    a()\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "if_not_else", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lints checks for items declared after some statement in a block", 
      "Why is this bad": "Items live for the entire scope they are declared in. But statements are\nprocessed in order. This might cause confusion as it's hard to figure out which item is meant\nin a statement.", 
      "Example": "```rust\nfn foo() {\n    println!(\"cake\");\n}\nfn main() {\n    foo(); // prints \"foo\"\n    fn foo() {\n        println!(\"foo\");\n    }\n    foo(); // prints \"foo\"\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "items_after_statements", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for getting the length of something via `.len()` just to\ncompare to zero, and suggests using `.is_empty()` where applicable.", 
      "Why is this bad": "Some structures can answer `.is_empty()` much faster than calculating\ntheir length. So it is good to get into the habit of using `.is_empty()`, and having it is\ncheap. Besides, it makes the intent clearer than a comparison.", 
      "Example": "```rust\nif x.len() == 0 { .. }\n```", 
      "Known problems": "None"
    }, 
    "id": "len_zero", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for items that implement `.len()` but not `.is_empty()`.", 
      "Why is this bad": "It is good custom to have both methods, because for some data structures,\nasking about the length will be a costly operation, whereas `.is_empty()` can usually answer in\nconstant time. Also it used to lead to false positives on the [`len_zero`](#len_zero) lint \u2013\ncurrently that lint will ignore such entities.", 
      "Example": "```rust\nimpl X {\n    fn len(&self) -> usize { .. }\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "len_without_is_empty", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for variable declarations immediately followed by a\nconditional affectation.", 
      "Why is this bad": "This is not idiomatic Rust.", 
      "Example": "```rust,ignore\nlet foo;\nif bar() {\n    foo = 42;\n} else {\n    foo = 0;\n}\nlet mut baz = None;\nif bar() {\n    baz = Some(42);\n}\n```\nshould be written\n```rust,ignore\nlet foo = if bar() {\n    42;\n} else {\n    0;\n};\nlet baz = if bar() {\n    Some(42);\n} else {\n    None\n};\n```", 
      "Known problems": "None."
    }, 
    "id": "useless_let_if_seq", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for lifetime annotations which can be removed by relying on\nlifetime elision.", 
      "Why is this bad": "The additional lifetimes make the code look more complicated, while there\nis nothing out of the ordinary going on. Removing them leads to more readable code.", 
      "Example": "```rust\nfn in_and_out<'a>(x: &'a u8, y: u8) -> &'a u8 { x }\n```", 
      "Known problems": "Potential false negatives: we bail out if the function has a `where` clause\nwhere lifetimes are mentioned."
    }, 
    "id": "needless_lifetimes", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for lifetimes in generics that are never used anywhere else.", 
      "Why is this bad": "The additional lifetimes make the code look more complicated, while there\nis nothing out of the ordinary going on. Removing them leads to more readable code.", 
      "Example": "```rust\nfn unused_lifetime<'a>(x: u8) { .. }\n```", 
      "Known problems": "None"
    }, 
    "id": "unused_lifetimes", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for looping over the range of `0..len` of some collection\njust to get the values by index.", 
      "Why is this bad": "Just iterating the collection itself makes the intent more clear and is\nprobably faster.", 
      "Example": "```rust\nfor i in 0..vec.len() {\n    println!(\"{}\", vec[i]);\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "needless_range_loop", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for loops on `x.iter()` where `&x` will do, and suggest the latter.", 
      "Why is this bad": "Readability.", 
      "Example": "```rust\n// with `y` a `Vec` or slice:\nfor x in y.iter() { .. }\n```", 
      "Known problems": "False negatives. We currently only warn on some known types."
    }, 
    "id": "explicit_iter_loop", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for loops on `x.next()`.", 
      "Why is this bad": "`next()` returns either `Some(value)` if there was a value, or `None`\notherwise. The insidious thing is that `Option<_>` implements `IntoIterator`, so that possibly\none value will be iterated, leading to some hard to find bugs. No one will want to write such\ncode [except to win an Underhanded Rust\nContest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).", 
      "Example": "```rust\nfor x in y.next() { .. }\n```", 
      "Known problems": "None"
    }, 
    "id": "iter_next_loop", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for `for` loops over `Option` values.", 
      "Why is this bad": "Readability. This is more clearly expressed as an `if let`.", 
      "Example": "```rust\nfor x in option { .. }\n```\nThis should be\n```rust\nif let Some(x) = option { .. }\n```", 
      "Known problems": "None"
    }, 
    "id": "for_loop_over_option", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for `for` loops over `Result` values.", 
      "Why is this bad": "Readability. This is more clearly expressed as an `if let`.", 
      "Example": "```rust\nfor x in result { .. }\n```\nThis should be\n```rust\nif let Ok(x) = result { .. }\n```", 
      "Known problems": "None"
    }, 
    "id": "for_loop_over_result", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint detects `loop + match` combinations that are easier written as a\n`while let` loop.", 
      "Why is this bad": "The `while let` loop is usually shorter and more readable", 
      "Example": "```rust\nloop {\n    let x = match y {\n        Some(x) => x,\n        None => break,\n    }\n    // .. do something with x\n}\n// is easier written as\nwhile let Some(x) = y {\n    // .. do something with x\n}\n```", 
      "Known problems": "Sometimes the wrong binding is displayed (#383)"
    }, 
    "id": "while_let_loop", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for using `collect()` on an iterator without using the\nresult.", 
      "Why is this bad": "It is more idiomatic to use a `for` loop over the iterator instead.", 
      "Example": "```rust\nvec.iter().map(|x| /* some operation returning () */).collect::<Vec<_>>();\n```", 
      "Known problems": "None"
    }, 
    "id": "unused_collect", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for loops over ranges `x..y` where both `x` and `y` are\nconstant and `x` is greater or equal to `y`, unless the range is reversed or has a negative\n`.step_by(_)`.", 
      "Why is it bad": "Such loops will either be skipped or loop until wrap-around (in debug code,\nthis may `panic!()`). Both options are probably not intended.", 
      "Examples": ":\n```rust\nfor x in 5..10-5 { .. } // oops, stray `-`\n```", 
      "Known problems": "The lint cannot catch loops over dynamically defined ranges. Doing this\nwould require simulating all possible inputs and code paths through the program, which would be\ncomplex and error-prone."
    }, 
    "id": "reverse_range_loop", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks `for` loops over slices with an explicit counter and\nsuggests the use of `.enumerate()`.", 
      "Why is it bad": "Not only is the version using `.enumerate()` more readable, the compiler is\nable to remove bounds checks which can lead to faster code in some instances.", 
      "Example": "```rust\nfor i in 0..v.len() { foo(v[i]);\nfor i in 0..v.len() { bar(i, v[i]); }\n```", 
      "Known problems": "None."
    }, 
    "id": "explicit_counter_loop", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for empty `loop` expressions.", 
      "Why is this bad": "Those busy loops burn CPU cycles without doing anything. Think of the\nenvironment and either block on something or at least make the thread sleep for some\nmicroseconds.", 
      "Example": "```rust\nloop {}\n```", 
      "Known problems": "None"
    }, 
    "id": "empty_loop", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for `while let` expressions on iterators.", 
      "Why is this bad": "Readability. A simple `for` loop is shorter and conveys the intent better.", 
      "Example": "```rust\nwhile let Some(val) = iter() { .. }\n```", 
      "Known problems": "None"
    }, 
    "id": "while_let_on_iterator", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This warns when you iterate on a map (`HashMap` or `BTreeMap`) and ignore\neither the keys or values.", 
      "Why is this bad": "Readability. There are `keys` and `values` methods that can be used to\nexpress that don't need the values or keys.", 
      "Example": "```rust\nfor (k, _) in &map { .. }\n```\ncould be replaced by\n```rust\nfor k in map.keys() { .. }\n```", 
      "Known problems": "None"
    }, 
    "id": "for_kv_map", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for mapping clone() over an iterator.", 
      "Why is this bad": "It makes the code less readable.", 
      "Example": "```rust\nx.map(|e| e.clone());\n```", 
      "Known problems": "None"
    }, 
    "id": "map_clone", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for matches with a single arm where an `if let` will usually\nsuffice.", 
      "Why is this bad": "Just readability \u2013 `if let` nests less than a `match`.", 
      "Example": "```rust\nmatch x {\n    Some(ref foo) -> bar(foo),\n    _ => ()\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "single_match", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for matches with a two arms where an `if let` will usually\nsuffice.", 
      "Why is this bad": "Just readability \u2013 `if let` nests less than a `match`.", 
      "Example": "```rust\nmatch x {\n    Some(ref foo) -> bar(foo),\n    _ => bar(other_ref),\n}\n```", 
      "Known problems": "Personal style preferences may differ"
    }, 
    "id": "single_match_else", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for matches where all arms match a reference, suggesting to\nremove the reference and deref the matched expression instead. It also checks for `if let &foo\n= bar` blocks.", 
      "Why is this bad": "It just makes the code less readable. That reference destructuring adds\nnothing to the code.", 
      "Example": "```rust\nmatch x {\n    &A(ref y) => foo(y),\n    &B => bar(),\n    _ => frob(&x),\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "match_ref_pats", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for matches where match expression is a `bool`. It suggests\nto replace the expression with an `if...else` block.", 
      "Why is this bad": "It makes the code less readable.", 
      "Example": "```rust\nlet condition: bool = true;\nmatch condition {\n    true => foo(),\n    false => bar(),\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "match_bool", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for overlapping match arms.", 
      "Why is this bad": "It is likely to be an error and if not, makes the code less obvious.", 
      "Example": "```rust\nlet x = 5;\nmatch x {\n    1 ... 10 => println!(\"1 ... 10\"),\n    5 ... 15 => println!(\"5 ... 15\"),\n    _ => (),\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "match_overlapping_arm", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for usage of `std::mem::forget(t)` where `t` is `Drop`.", 
      "Why is this bad": "`std::mem::forget(t)` prevents `t` from running its destructor, possibly\ncausing leaks", 
      "Example": "```rust\nmem::forget(Rc::new(55)))\n```", 
      "Known problems": "None."
    }, 
    "id": "mem_forget", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for `.unwrap()` calls on `Option`s.", 
      "Why is this bad": "Usually it is better to handle the `None` case, or to at least call\n`.expect(_)` with a more helpful message. Still, for a lot of quick-and-dirty code, `unwrap` is\na good choice, which is why this lint is `Allow` by default.", 
      "Example": "```rust\nx.unwrap()\n```", 
      "Known problems": "None"
    }, 
    "id": "option_unwrap_used", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for `.unwrap()` calls on `Result`s.", 
      "Why is this bad": "`result.unwrap()` will let the thread panic on `Err` values. Normally, you\nwant to implement more sophisticated error handling, and propagate errors upwards with `try!`.\nEven if you want to panic on errors, not all `Error`s implement good messages on display.\nTherefore it may be beneficial to look at the places where they may get displayed. Activate\nthis lint to do just that.", 
      "Example": "```rust\nx.unwrap()\n```", 
      "Known problems": "None"
    }, 
    "id": "result_unwrap_used", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for methods that should live in a trait implementation of a\n`std` trait (see [llogiq's blog post](http://llogiq.github.io/2015/07/30/traits.html) for\nfurther information) instead of an inherent implementation.", 
      "Why is this bad": "Implementing the traits improve ergonomics for users of the code, often\nwith very little cost. Also people seeing a `mul(..)` method may expect `*` to work equally, so\nyou should have good reason to disappoint them.", 
      "Example": "```rust\nstruct X;\nimpl X {\n   fn add(&self, other: &X) -> X { .. }\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "should_implement_trait", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for methods with certain name prefixes and which doesn't\nmatch how self is taken. The actual rules are:\n|Prefix |`self` taken          |\n|-------|----------------------|\n|`as_`  |`&self` or `&mut self`|\n|`from_`| none                 |\n|`into_`|`self`                |\n|`is_`  |`&self` or none       |\n|`to_`  |`&self`               |", 
      "Why is this bad": "Consistency breeds readability. If you follow the conventions, your users\nwon't be surprised that they, e.g., need to supply a mutable reference to a `as_..` function.", 
      "Example": "```rust\nimpl X {\n    fn as_str(self) -> &str { .. }\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "wrong_self_convention", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This is the same as [`wrong_self_convention`](#wrong_self_convention), but\nfor public items.", 
      "Why is this bad": "See [`wrong_self_convention`](#wrong_self_convention).", 
      "Example": "```rust\nimpl X {\n    pub fn as_str(self) -> &str { .. }\n}\n```", 
      "Known problems": "Actually *renaming* the function may break clients if the function is part\nof the public interface. In that case, be mindful of the stability guarantees you've given your\nusers."
    }, 
    "id": "wrong_pub_self_convention", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for usage of `ok().expect(..)`.", 
      "Why is this bad": "Because you usually call `expect()` on the `Result` directly to get a good\nerror message.", 
      "Example": "```rust\nx.ok().expect(\"why did I do this again?\")\n```", 
      "Known problems": "None."
    }, 
    "id": "ok_expect", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for usage of `_.map(_).unwrap_or(_)`.", 
      "Why is this bad": "Readability, this can be written more concisely as `_.map_or(_, _)`.", 
      "Example": "```rust\nx.map(|a| a + 1).unwrap_or(0)\n```", 
      "Known problems": "None."
    }, 
    "id": "option_map_unwrap_or", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint `Warn`s on `_.map(_).unwrap_or_else(_)`.", 
      "Why is this bad": "Readability, this can be written more concisely as `_.map_or_else(_, _)`.", 
      "Example": "```rust\nx.map(|a| a + 1).unwrap_or_else(some_function)\n```", 
      "Known problems": "None."
    }, 
    "id": "option_map_unwrap_or_else", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint `Warn`s on `_.filter(_).next()`.", 
      "Why is this bad": "Readability, this can be written more concisely as `_.find(_)`.", 
      "Example": "```rust\niter.filter(|x| x == 0).next()\n```", 
      "Known problems": "None."
    }, 
    "id": "filter_next", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint `Warn`s on `_.filter(_).map(_)`, `_.filter(_).flat_map(_)`,\n`_.filter_map(_).flat_map(_)` and similar.", 
      "Why is this bad": "Readability, this can be written more concisely as a single method call", 
      "Example": "```rust\niter.filter(|x| x == 0).map(|x| x * 2)\n```", 
      "Known problems": "Often requires a condition + Option/Iterator creation inside the closure"
    }, 
    "id": "filter_map", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint `Warn`s on an iterator search (such as `find()`, `position()`, or\n`rposition()`) followed by a call to `is_some()`.", 
      "Why is this bad": "Readability, this can be written more concisely as `_.any(_)`.", 
      "Example": "```rust\niter.find(|x| x == 0).is_some()\n```", 
      "Known problems": "None."
    }, 
    "id": "search_is_some", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint `Warn`s on using `.chars().next()` on a `str` to check if it\nstarts with a given char.", 
      "Why is this bad": "Readability, this can be written more concisely as `_.starts_with(_)`.", 
      "Example": "```rust\nname.chars().next() == Some('_')\n```", 
      "Known problems": "None."
    }, 
    "id": "chars_next_cmp", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`, etc., and\nsuggests to use `or_else`, `unwrap_or_else`, etc., or `unwrap_or_default` instead.", 
      "Why is this bad": "The function will always be called and potentially allocate an object\nin expressions such as:\n```rust\nfoo.unwrap_or(String::new())\n```\nthis can instead be written:\n```rust\nfoo.unwrap_or_else(String::new)\n```\nor\n```rust\nfoo.unwrap_or_default()\n```", 
      "Known problems": "If the function as side-effects, not calling it will change the semantic of\nthe program, but you shouldn't rely on that anyway."
    }, 
    "id": "or_fun_call", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for usage of `.extend(s)` on a `Vec` to extend the vector by a slice.", 
      "Why is this bad": "Since Rust 1.6, the `extend_from_slice(_)` method is stable and at least for now faster.", 
      "Example": "```rust\nmy_vec.extend(&xs)\n```", 
      "Known problems": "None."
    }, 
    "id": "extend_from_slice", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint warns on using `.clone()` on a `Copy` type.", 
      "Why is this bad": "The only reason `Copy` types implement `Clone` is for generics, not for\nusing the `clone` method on a concrete type.", 
      "Example": "```rust\n42u64.clone()\n```", 
      "Known problems": "None."
    }, 
    "id": "clone_on_copy", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint warns on using `.clone()` on an `&&T`", 
      "Why is this bad": "Cloning an `&&T` copies the inner `&T`, instead of cloning the underlying\n`T`", 
      "Example": "```rust\nfn main() {\n   let x = vec![1];\n   let y = &&x;\n   let z = y.clone();\n   println!(\"{:p} {:p}\",*y, z); // prints out the same pointer\n}\n```", 
      "Known problems": "None."
    }, 
    "id": "clone_double_ref", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint warns about `new` not returning `Self`.", 
      "Why is this bad": "As a convention, `new` methods are used to make a new instance of a type.", 
      "Example": "```rust\nimpl Foo {\n    fn new(..) -> NotAFoo {\n    }\n}\n```", 
      "Known problems": "None."
    }, 
    "id": "new_ret_no_self", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for string methods that receive a single-character `str` as an argument, e.g. `_.split(\"x\")`.", 
      "Why is this bad": "Performing these methods using a `char` is faster than using a `str`.", 
      "Example": "```rust\n_.split(\"x\")` could be `_.split('x')\n```", 
      "Known problems": "Does not catch multi-byte unicode characters."
    }, 
    "id": "single_char_pattern", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for getting the inner pointer of a temporary `CString`.", 
      "Why is this bad": "The inner pointer of a `CString` is only valid as long as the `CString` is\nalive.", 
      "Example": "```rust,ignore\nlet c_str = CString::new(\"foo\").unwrap().as_ptr();\nunsafe {\ncall_some_ffi_func(c_str);\n}\n```\nHere `c_str` point to a freed address. The correct use would be:\n```rust,ignore\nlet c_str = CString::new(\"foo\").unwrap();\nunsafe {\n    call_some_ffi_func(c_str.as_ptr());\n}\n```", 
      "Known problems": "None."
    }, 
    "id": "temporary_cstring_as_ptr", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for use of `.iter().nth()` (and the related\n`.iter_mut().nth()`) on standard library types with O(1) element access.", 
      "Why is this bad": "`.get()` and `.get_mut()` are more efficient and more readable.", 
      "Example": "```rust\nlet some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.iter().nth(3);\nlet bad_slice = &some_vec[..].iter().nth(3);\n```\nThe correct use would be:\n```rust\nlet some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.get(3);\nlet bad_slice = &some_vec[..].get(3);\n```", 
      "Known problems": "None."
    }, 
    "id": "iter_nth", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for expressions where `std::cmp::min` and `max` are used to\nclamp values, but switched so that the result is constant.", 
      "Why is this bad": "This is in all probability not the intended outcome. At the least it hurts\nreadability of the code.", 
      "Example": "`min(0, max(100, x))` will always be equal to `0`. Probably the author meant to\nclamp the value between 0 and 100, but has erroneously swapped `min` and `max`.", 
      "Known problems": "None"
    }, 
    "id": "min_max", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for function arguments and let bindings denoted as `ref`.", 
      "Why is this bad": "The `ref` declaration makes the function take an owned value, but turns\nthe argument into a reference (which means that the value is destroyed when exiting the\nfunction). This adds not much value: either take a reference type, or take an owned value and\ncreate references in the body.\nFor let bindings, `let x = &foo;` is preferred over `let ref x = foo`. The type of `x` is more\nobvious with the former.", 
      "Example": "```rust\nfn foo(ref x: u8) -> bool { .. }\n```", 
      "Known problems": "If the argument is dereferenced within the function, removing the `ref`\nwill lead to errors. This can be fixed by removing the dereferences, e.g. changing `*x` to `x`\nwithin the function."
    }, 
    "id": "toplevel_ref_arg", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for comparisons to NAN.", 
      "Why is this bad": "NAN does not compare meaningfully to anything \u2013 not even itself \u2013 so those comparisons are simply wrong.", 
      "Example": "`x == NAN`", 
      "Known problems": "None"
    }, 
    "id": "cmp_nan", 
    "level": "Deny"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for (in-)equality comparisons on floating-point values (apart from zero), except in functions called `*eq*` (which probably implement equality for a type involving floats).", 
      "Why is this bad": "Floating point calculations are usually imprecise, so asking if two values are *exactly* equal is asking for trouble. For a good guide on what to do, see [the floating point guide](http://www.floating-point-gui.de/errors/comparison).", 
      "Example": "`y == 1.23f64`", 
      "Known problems": "None"
    }, 
    "id": "float_cmp", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for conversions to owned values just for the sake of a comparison.", 
      "Why is this bad": "The comparison can operate on a reference, so creating an owned value effectively throws it away directly afterwards, which is needlessly consuming code and heap space.", 
      "Example": "`x.to_owned() == y`", 
      "Known problems": "None"
    }, 
    "id": "cmp_owned", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for getting the remainder of a division by one.", 
      "Why is this bad": "The result can only ever be zero. No one will write such code deliberately, unless trying to win an Underhanded Rust Contest. Even for that contest, it's probably a bad idea. Use something more underhanded.", 
      "Example": "`x % 1`", 
      "Known problems": "None"
    }, 
    "id": "modulo_one", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for patterns in the form `name @ _`.", 
      "Why is this bad": "It's almost always more readable to just use direct bindings.", 
      "Example": ":\n```rust\nmatch v {\n    Some(x) => (),\n    y @ _   => (), // easier written as `y`,\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "redundant_pattern", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for the use of bindings with a single leading underscore", 
      "Why is this bad": "A single leading underscore is usually used to indicate that a binding\nwill not be used. Using such a binding breaks this expectation.", 
      "Example": ":\n```rust\nlet _x = 0;\nlet y = _x + 1; // Here we are using `_x`, even though it has a leading underscore.\n                // We should rename `_x` to `x`\n```", 
      "Known problems": "The lint does not work properly with desugaring and macro, it has been\nallowed in the mean time."
    }, 
    "id": "used_underscore_binding", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for structure field patterns bound to wildcards.", 
      "Why is this bad": "Using `..` instead is shorter and leaves the focus on the fields that are actually bound.", 
      "Example": "```rust\nlet { a: _, b: ref b, c: _ } = ..\n```", 
      "Known problems": "None."
    }, 
    "id": "unneeded_field_pattern", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for function arguments having the similar names differing by an underscore", 
      "Why is this bad": "It affects code readability", 
      "Example": "```rust\nfn foo(a: i32, _a: i32) {}\n```", 
      "Known problems": "None."
    }, 
    "id": "duplicate_underscore_argument", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint detects closures called in the same expression where they are defined.", 
      "Why is this bad": "It is unnecessarily adding to the expression's complexity.", 
      "Example": "```rust\n(|| 42)()\n```", 
      "Known problems": "None."
    }, 
    "id": "redundant_closure_call", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint detects expressions of the form `--x`", 
      "Why is this bad": "It can mislead C/C++ programmers to think `x` was decremented.", 
      "Example": "```rust\n--x;\n```", 
      "Known problems": "None."
    }, 
    "id": "double_neg", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for instances of `mut mut` references.", 
      "Why is this bad": "Multiple `mut`s don't add anything meaningful to the source. This is\neither a copy'n'paste error, or it shows a fundamental misunderstanding of references)", 
      "Example": "```rust\nlet x = &mut &mut y;\n```", 
      "Known problems": "None"
    }, 
    "id": "mut_mut", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint detects giving a mutable reference to a function that only requires\nan immutable reference.", 
      "Why is this bad": "The immutable reference rules out all other references to the value. Also\nthe code misleads about the intent of the call site.", 
      "Example": "```rust\nmy_vec.push(&mut value)\n```", 
      "Known problems": "None"
    }, 
    "id": "unnecessary_mut_passed", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for usages of `Mutex<X>` where an atomic will do.", 
      "Why is this bad": "Using a mutex just to make access to a plain bool or reference sequential\nis shooting flies with cannons. `std::atomic::AtomicBool` and `std::atomic::AtomicPtr` are\nleaner and faster.", 
      "Example": "```rust\nlet x = Mutex::new(&y);\n```", 
      "Known problems": "This lint cannot detect if the mutex is actually used for waiting before a critical section."
    }, 
    "id": "mutex_atomic", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for usages of `Mutex<X>` where `X` is an integral type.", 
      "Why is this bad": "Using a mutex just to make access to a plain integer sequential is\nshooting flies with cannons. `std::atomic::usize` is leaner and faster.", 
      "Example": "```rust\nlet x = Mutex::new(0usize);\n```", 
      "Known problems": "This lint cannot detect if the mutex is actually used for waiting before a critical section."
    }, 
    "id": "mutex_integer", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for expressions of the form `if c { true } else { false }`\n(or vice versa) and suggest using the condition directly.", 
      "Why is this bad": "Redundant code.", 
      "Example": "```rust\nif x { false } else { true }\n```", 
      "Known problems": "Maybe false positives: Sometimes, the two branches are painstakingly\ndocumented (which we of course do not detect), so they *may* have some value. Even then, the\ndocumentation can be rewritten to match the shorter code."
    }, 
    "id": "needless_bool", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for expressions of the form `x == true` (or vice versa) and\nsuggest using the variable directly.", 
      "Why is this bad": "Unnecessary code.", 
      "Example": "`if x == true { }` could be `if x { }`", 
      "Known problems": "None."
    }, 
    "id": "bool_comparison", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for address of operations (`&`) that are going to be\ndereferenced immediately by the compiler", 
      "Why is this bad": "Suggests that the receiver of the expression borrows the expression.", 
      "Example": "```rust\nlet x: &i32 = &&&&&&5;\n```", 
      "Known problems": ""
    }, 
    "id": "needless_borrow", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint warns on needlessly including a base struct on update when all fields are changed anyway.", 
      "Why is this bad": "This will cost resources (because the base has to be somewhere), and make the code less readable.", 
      "Example": "```rust\nPoint { x: 1, y: 0, ..zero_point }\n```", 
      "Known problems": "None."
    }, 
    "id": "needless_update", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "Checks for multiplication by -1 as a form of negation.", 
      "Why is this bad": "It's more readable to just negate.", 
      "Example": "```rust\nx * -1\n```", 
      "Known problems": "This only catches integers (for now)"
    }, 
    "id": "neg_multiply", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lints about type with a `fn new() -> Self` method\nand no implementation of\n[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)", 
      "Why is this bad": "User might expect to be able to use\n[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\nas the type can be constructed without arguments.", 
      "Example": "```rust,ignore\nstruct Foo(Bar);\nimpl Foo {\n    fn new() -> Self {\n        Foo(Bar::new())\n    }\n}\n```\nInstead, use:\n```rust\nstruct Foo(Bar);\nimpl Default for Foo {\n    fn default() -> Self {\n        Foo(Bar::new())\n    }\n}\n```\nYou can also have `new()` call `Default::default()`", 
      "Known problems": "Hopefully none."
    }, 
    "id": "new_without_default", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lints about type with a `fn new() -> Self` method\nand no implementation of\n[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)", 
      "Why is this bad": "User might expect to be able to use\n[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\nas the type can be\nconstructed without arguments.", 
      "Example": "```rust,ignore\nstruct Foo;\nimpl Foo {\n    fn new() -> Self {\n        Foo\n    }\n}\n```\nJust prepend `#[derive(Default)]` before the `struct` definition", 
      "Known problems": "Hopefully none."
    }, 
    "id": "new_without_default_derive", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for statements which have no effect.", 
      "Why is this bad": "Similar to dead code, these statements are actually executed. However, as\nthey have no effect, all they do is make the code less readable.", 
      "Example": "```rust\n0;\n```", 
      "Known problems": "None."
    }, 
    "id": "no_effect", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for expression statements that can be reduced to a sub-expression", 
      "Why is this bad": "Expressions by themselves often have no side-effects. Having such\nexpressions reduces readability.", 
      "Example": "```rust\ncompute_array()[0];\n```", 
      "Known problems": "None."
    }, 
    "id": "unnecessary_operation", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint warns about names that are very similar and thus confusing", 
      "Why is this bad": "It's hard to distinguish between names that differ only by a single character", 
      "Example": "`checked_exp` and `checked_expr`", 
      "Known problems": "None?"
    }, 
    "id": "similar_names", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint warns about having too many variables whose name consists of a single character", 
      "Why is this bad": "It's hard to memorize what a variable means without a descriptive name.", 
      "Configuration": "This lint has the following configuration variables:\n\n* `single-char-binding-names-threshold: u64`: The maximum number of single char bindings a scope may have (defaults to `5`).", 
      "Example": "```rust\nlet (a, b, c, d, e, f, g) = (...);\n```", 
      "Known problems": "None?"
    }, 
    "id": "many_single_char_names", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for duplicate open options as well as combinations that make\nno sense.", 
      "Why is this bad": "In the best case, the code will be harder to read than necessary. I don't\nknow the worst case.", 
      "Example": "```rust\nOpenOptions::new().read(true).truncate(true)\n```", 
      "Known problems": "None"
    }, 
    "id": "nonsensical_open_options", 
    "level": "Warn"
  }, 
  {
    "docs": {}, 
    "id": "overflow_check_conditional", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for missing parameters in `panic!`.", 
      "Known problems": "Should you want to use curly brackets in `panic!` without any parameter,\nthis lint will warn.", 
      "Example": "```rust\npanic!(\"This `panic!` is probably missing a parameter there: {}\");\n```"
    }, 
    "id": "panic_params", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for operations where precedence may be unclear and suggests\nto add parentheses. Currently it catches the following:\n* mixed usage of arithmetic and bit shifting/combining operators without parentheses\n* a \"negative\" numeric literal (which is really a unary `-` followed by a numeric literal)\n  followed by a method call", 
      "Why is this bad": "Because not everyone knows the precedence of those operators by heart, so\nexpressions like these may trip others trying to reason about the code.", 
      "Examples": "* `1 << 2 + 3` equals 32, while `(1 << 2) + 3` equals 7\n* `-1i32.abs()` equals -1, while `(-1i32).abs()` equals 1", 
      "Known problems": "None"
    }, 
    "id": "precedence", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint warns whenever you print on *stdout*. The purpose of this lint is\nto catch debugging remnants.", 
      "Why is this bad": "People often print on *stdout* while debugging an application and might\nforget to remove those prints afterward.", 
      "Example": "```rust\nprintln!(\"Hello world!\");\n```", 
      "Known problems": "Only catches `print!` and `println!` calls."
    }, 
    "id": "print_stdout", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint warns whenever you use `Debug` formatting. The purpose of this lint\nis to catch debugging remnants.", 
      "Why is this bad": "The purpose of the `Debug` trait is to facilitate debugging Rust code. It\nshould not be used in in user-facing output.", 
      "Example": "```rust\nprintln!(\"{:?}\", foo);\n```"
    }, 
    "id": "use_debug", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for function arguments of type `&String` or `&Vec` unless\nthe references are mutable.", 
      "Why is this bad": "Requiring the argument to be of the specific size makes the function less\nuseful for no benefit; slices in the form of `&[T]` or `&str` usually suffice and can be\nobtained from other types, too.", 
      "Example": "```rust\nfn foo(&Vec<u32>) { .. }\n```", 
      "Known problems": "None"
    }, 
    "id": "ptr_arg", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for iterating over ranges with a `.step_by(0)`, which never\nterminates.", 
      "Why is this bad": "This very much looks like an oversight, since with `loop { .. }` there is\nan obvious better way to endlessly loop.", 
      "Example": "```rust\nfor x in (5..5).step_by(0) { .. }\n```", 
      "Known problems": "None"
    }, 
    "id": "range_step_by_zero", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for zipping a collection with the range of `0.._.len()`.", 
      "Why is this bad": "The code is better expressed with `.enumerate()`.", 
      "Example": "```rust\nx.iter().zip(0..x.len())\n```", 
      "Known problems": "None"
    }, 
    "id": "range_zip_with_len", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks [regex] creation (with `Regex::new`, `RegexBuilder::new` or\n`RegexSet::new`) for correct regex syntax.\n[regex]: https://crates.io/crates/regex", 
      "Why is this bad": "This will lead to a runtime panic.", 
      "Example": "```rust\nRegex::new(\"|\")\n```", 
      "Known problems": "None."
    }, 
    "id": "invalid_regex", 
    "level": "Deny"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for trivial [regex] creation (with `Regex::new`,\n`RegexBuilder::new` or `RegexSet::new`).\n[regex]: https://crates.io/crates/regex", 
      "Why is this bad": "This can likely be replaced by `==` or `str::starts_with`,\n`str::ends_with` or `std::contains` or other `str` methods.", 
      "Example": "```rust\nRegex::new(\"^foobar\")\n```", 
      "Known problems": "None."
    }, 
    "id": "trivial_regex", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for usage of `regex!(_)` which as of now is usually slower\nthan `Regex::new(_)` unless called in a loop (which is a bad idea anyway).", 
      "Why is this bad": "Performance, at least for now. The macro version is likely to catch up\nlong-term, but for now the dynamic version is faster.", 
      "Example": "```rust\nregex!(\"foo|bar\")\n```", 
      "Known problems": "None"
    }, 
    "id": "regex_macro", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for return statements at the end of a block.", 
      "Why is this bad": "Removing the `return` and semicolon will make the code more rusty.", 
      "Example": "```rust\nfn foo(x: usize) { return x; }\n```", 
      "Known problems": "Following this lint's advice may currently run afoul of Rust issue\n[#31439](https://github.com/rust-lang/rust/issues/31439), so if you get lifetime errors, please\nroll back the change until that issue is fixed."
    }, 
    "id": "needless_return", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for `let`-bindings, which are subsequently returned.", 
      "Why is this bad": "It is just extraneous code. Remove it to make your code more rusty.", 
      "Example": "```rust\n{ let x = ..; x }\n```", 
      "Known problems": "Following this lint's advice may currently run afoul of Rust issue\n[#31439](https://github.com/rust-lang/rust/issues/31439), so if you get lifetime errors, please\nroll back the change until that issue is fixed."
    }, 
    "id": "let_and_return", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for mis-uses of the serde API", 
      "Why is this bad": "Serde is very finnicky about how its API should be used, but the type system can't be used to enforce it (yet)", 
      "Example": "implementing `Visitor::visit_string` but not `Visitor::visit_str`", 
      "Known problems": "None."
    }, 
    "id": "serde_api_misuse", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for bindings that shadow other bindings already in scope,\nwhile just changing reference level or mutability.", 
      "Why is this bad": "Not much, in fact it's a very common pattern in Rust code. Still, some may\nopt to avoid it in their code base, they can set this lint to `Warn`.", 
      "Example": "```rust\nlet x = &x;\n```", 
      "Known problems": "This lint, as the other shadowing related lints, currently only catches\nvery simple patterns."
    }, 
    "id": "shadow_same", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for bindings that shadow other bindings already in scope,\nwhile reusing the original value.", 
      "Why is this bad": "Not too much, in fact it's a common pattern in Rust code. Still, some\nargue that name shadowing like this hurts readability, because a value may be bound to\ndifferent things depending on position in the code.", 
      "Example": "```rust\nlet x = x + 1;\n```", 
      "Known problems": "This lint, as the other shadowing related lints, currently only catches\nvery simple patterns."
    }, 
    "id": "shadow_reuse", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for bindings that shadow other bindings already in scope,\neither without a initialization or with one that does not even use the original value.", 
      "Why is this bad": "Name shadowing can hurt readability, especially in large code bases,\nbecause it is easy to lose track of the active binding at any place in the code. This can be\nalleviated by either giving more specific names to bindings ore introducing more scopes to\ncontain the bindings.", 
      "Example": "```rust\nlet x = y; let x = z; // shadows the earlier binding\n```", 
      "Known problems": "This lint, as the other shadowing related lints, currently only catches\nvery simple patterns."
    }, 
    "id": "shadow_unrelated", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint matches code of the form `x = x + y` (without `let`!).", 
      "Why is this bad": "It's not really bad, but some people think that the `.push_str(_)` method\nis more readable.", 
      "Example": "```rust\nlet mut x = \"Hello\".to_owned();\nx = x + \", World\";\n```", 
      "Known problems": "None."
    }, 
    "id": "string_add_assign", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "The `string_add` lint matches all instances of `x + _` where `x` is of type\n`String`, but only if [`string_add_assign`](#string_add_assign) does *not* match.", 
      "Why is this bad": "It's not bad in and of itself. However, this particular `Add`\nimplementation is asymmetric (the other operand need not be `String`, but `x` does), while\naddition as mathematically defined is symmetric, also the `String::push_str(_)` function is a\nperfectly good replacement. Therefore some dislike it and wish not to have it in their code.\nThat said, other people think that string addition, having a long tradition in other languages\nis actually fine, which is why we decided to make this particular lint `allow` by default.", 
      "Example": "```rust\nlet x = \"Hello\".to_owned();\nx + \", World\"\n```", 
      "Known problems": "None"
    }, 
    "id": "string_add", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint matches the `as_bytes` method called on string\nliterals that contain only ASCII characters.", 
      "Why is this bad": "Byte string literals (e.g. `b\"foo\"`) can be used instead. They are shorter\nbut less discoverable than `as_bytes()`.", 
      "Example": "```rust\nlet bs = \"a byte string\".as_bytes();\n```"
    }, 
    "id": "string_lit_as_bytes", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lints manual swapping.", 
      "Why is this bad": "The `std::mem::swap` function exposes the intent better without\ndeinitializing or copying either variable.", 
      "Example": "```rust,ignore\nlet t = b;\nb = a;\na = t;\n```", 
      "Known problems": "None."
    }, 
    "id": "manual_swap", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lints `foo = bar; bar = foo` sequences.", 
      "Why is this bad": "This looks like a failed attempt to swap.", 
      "Example": "```rust,ignore\na = b;\nb = a;\n```", 
      "Known problems": "None."
    }, 
    "id": "almost_swapped", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for construction of a structure or tuple just to assign a\nvalue in it.", 
      "Why is this bad": "Readability. If the structure is only created to be updated, why not write\nthe structure you want in the first place?", 
      "Example": "```rust\n(0, 0).0 = 1\n```", 
      "Known problems": "None."
    }, 
    "id": "temporary_assignment", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for transmutes that can't ever be correct on any architecture", 
      "Why is this bad": "It's basically guaranteed to be undefined behaviour", 
      "Example": "```rust\nlet ptr: *const T = core::intrinsics::transmute('x')`\n```", 
      "Known problems": "When accessing C, users might want to store pointer sized objects in\n`extradata` arguments to save an allocation."
    }, 
    "id": "wrong_transmute", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for transmutes to the original type of the object and\ntransmutes that could be a cast.", 
      "Why is this bad": "Readability. The code tricks people into thinking that something complex\nis going on", 
      "Example": "```rust\ncore::intrinsics::transmute(t) // where the result type is the same as `t`'s\n```", 
      "Known problems": "None."
    }, 
    "id": "useless_transmute", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "* This lint checks for transmutes between a type `T` and `*T`.", 
      "Why is this bad": "It's easy to mistakenly transmute between a type and a pointer to that type.", 
      "Example": "```rust\ncore::intrinsics::transmute(t)` // where the result type is the same as `*t` or `&t`'s\n```", 
      "Known problems": "None."
    }, 
    "id": "crosspointer_transmute", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "* This lint checks for transmutes from a pointer to a reference.", 
      "Why is this bad": "This can always be rewritten with `&` and `*`.", 
      "Example": "```rust\nlet _: &T = std::mem::transmute(p); // where p: *const T\n// can be written:\nlet _: &T = &*p;\n```", 
      "Known problems": "None."
    }, 
    "id": "transmute_ptr_to_ref", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for use of `Box<Vec<_>>` anywhere in the code.", 
      "Why is this bad": "`Vec` already keeps its contents in a separate area on the heap. So if you\n`Box` it, you just add another level of indirection without any benefit whatsoever.", 
      "Example": "```rust\nstruct X {\n    values: Box<Vec<Foo>>,\n}\n```", 
      "Known problems": "None"
    }, 
    "id": "box_vec", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for usage of any `LinkedList`, suggesting to use a `Vec` or\na `VecDeque` (formerly called `RingBuf`).", 
      "Why is this bad": "Gankro says:\n> The TL;DR of `LinkedList` is that it's built on a massive amount of pointers and indirection.\n> It wastes memory, it has terrible cache locality, and is all-around slow. `RingBuf`, while\n> \"only\" amortized for push/pop, should be faster in the general case for almost every possible\n> workload, and isn't even amortized at all if you can predict the capacity you need.\n>\n> `LinkedList`s are only really good if you're doing a lot of merging or splitting of lists.\n> This is because they can just mangle some pointers instead of actually copying the data. Even\n> if you're doing a lot of insertion in the middle of the list, `RingBuf` can still be better\n> because of how expensive it is to seek to the middle of a `LinkedList`.", 
      "Example": "```rust\nlet x = LinkedList::new();\n```", 
      "Known problems": "False positives \u2013 the instances where using a `LinkedList` makes sense are\nfew and far between, but they can still happen."
    }, 
    "id": "linkedlist", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for binding a unit value.", 
      "Why is this bad": "A unit value cannot usefully be used anywhere. So binding one is kind of pointless.", 
      "Example": "`let x = { 1; };`", 
      "Known problems": "None"
    }, 
    "id": "let_unit_value", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for comparisons to unit.", 
      "Why is this bad": "Unit is always equal to itself, and thus is just a clumsily written constant. Mostly this happens when someone accidentally adds semicolons at the end of the operands.", 
      "Example": "`if { foo(); } == { bar(); } { baz(); }` is equal to `{ foo(); bar(); baz(); }`", 
      "Known problems": "None"
    }, 
    "id": "unit_cmp", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for casts from any numerical to a float type where the receiving type cannot store all values from the original type without rounding errors. This possible rounding is to be expected, so this lint is `Allow` by default.\nBasically, this warns on casting any integer with 32 or more bits to `f32` or any 64-bit integer to `f64`.", 
      "Why is this bad": "It's not bad at all. But in some applications it can be helpful to know where precision loss can take place. This lint can help find those places in the code.", 
      "Example": "`let x = u64::MAX; x as f64`", 
      "Known problems": "None"
    }, 
    "id": "cast_precision_loss", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for casts from a signed to an unsigned numerical type. In this case, negative values wrap around to large positive values, which can be quite surprising in practice. However, as the cast works as defined, this lint is `Allow` by default.", 
      "Why is this bad": "Possibly surprising results. You can activate this lint as a one-time check to see where numerical wrapping can arise.", 
      "Example": "`let y : i8 = -1; y as u64` will return 18446744073709551615", 
      "Known problems": "None"
    }, 
    "id": "cast_sign_loss", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for on casts between numerical types that may truncate large values. This is expected behavior, so the cast is `Allow` by default.", 
      "Why is this bad": "In some problem domains, it is good practice to avoid truncation. This lint can be activated to help assess where additional checks could be beneficial.", 
      "Example": "`fn as_u8(x: u64) -> u8 { x as u8 }`", 
      "Known problems": "None"
    }, 
    "id": "cast_possible_truncation", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for casts from an unsigned type to a signed type of the same size. Performing such a cast is a 'no-op' for the compiler, i.e. nothing is changed at the bit level, and the binary representation of the value is reinterpreted. This can cause wrapping if the value is too big for the target signed type. However, the cast works as defined, so this lint is `Allow` by default.", 
      "Why is this bad": "While such a cast is not bad in itself, the results can be surprising when this is not the intended behavior, as demonstrated by the example below.", 
      "Example": "`u32::MAX as i32` will yield a value of `-1`.", 
      "Known problems": "None"
    }, 
    "id": "cast_possible_wrap", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for types used in structs, parameters and `let` declarations above a certain complexity threshold.", 
      "Why is this bad": "Too complex types make the code less readable. Consider using a `type` definition to simplify them.", 
      "Configuration": "This lint has the following configuration variables:\n\n* `type-complexity-threshold: u64`: The maximum complexity a type can have (defaults to `250`).", 
      "Example": "`struct Foo { inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>> }`", 
      "Known problems": "None"
    }, 
    "id": "type_complexity", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint points out expressions where a character literal is casted to `u8` and suggests using a byte literal instead.", 
      "Why is this bad": "In general, casting values to smaller types is error-prone and should be avoided where possible. In the particular case of converting a character literal to u8, it is easy to avoid by just using a byte literal instead. As an added bonus, `b'a'` is even slightly shorter than `'a' as u8`.", 
      "Example": "`'x' as u8`", 
      "Known problems": "None"
    }, 
    "id": "char_lit_as_u8", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for comparisons where one side of the relation is either the minimum or maximum value for its type and warns if it involves a case that is always true or always false. Only integer and boolean types are checked.", 
      "Why is this bad": "An expression like `min <= x` may misleadingly imply that is is possible for `x` to be less than the minimum. Expressions like `max < x` are probably mistakes.", 
      "Example": "`vec.len() <= 0`, `100 > std::i32::MAX`", 
      "Known problems": "None"
    }, 
    "id": "absurd_extreme_comparisons", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for comparisons where the relation is always either true or false, but where one side has been upcast so that the comparison is necessary. Only integer types are checked.", 
      "Why is this bad": "An expression like `let x : u8 = ...; (x as u32) > 300` will mistakenly imply that it is possible for `x` to be outside the range of `u8`.", 
      "Example": "`let x : u8 = ...; (x as u32) > 300`", 
      "Known problems": "https://github.com/Manishearth/rust-clippy/issues/886"
    }, 
    "id": "invalid_upcast_comparisons", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for the Unicode zero-width space in the code.", 
      "Why is this bad": "Having an invisible character in the code makes for all sorts of April\nfools, but otherwise is very much frowned upon.", 
      "Example": "You don't see it, but there may be a zero-width space somewhere in this text.", 
      "Known problems": "None"
    }, 
    "id": "zero_width_space", 
    "level": "Deny"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for non-ASCII characters in string literals.", 
      "Why is this bad": "Yeah, we know, the 90's called and wanted their charset back. Even so,\nthere still are editors and other programs out there that don't work well with Unicode. So if\nthe code is meant to be used internationally, on multiple operating systems, or has other\nportability requirements, activating this lint could be useful.", 
      "Example": "```rust\nlet x = \"H\u00e4?\"\n```", 
      "Known problems": "None"
    }, 
    "id": "non_ascii_literal", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for string literals that contain Unicode in a form that is\nnot equal to its [NFC-recomposition](http://www.unicode.org/reports/tr15/#Norm_Forms).", 
      "Why is this bad": "If such a string is compared to another, the results may be surprising.", 
      "Example": "You may not see it, but \u201ca\u0300\u201d and \u201c\u00e0\u201d aren't the same string. The former when\nescaped is actually `\"a\\u{300}\"` while the latter is `\"\\u{e0}\"`.", 
      "Known problems": "None"
    }, 
    "id": "unicode_not_nfc", 
    "level": "Allow"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for imports that remove \"unsafe\" from an item's name", 
      "Why is this bad": "Renaming makes it less clear which traits and structures are unsafe.", 
      "Example": "```rust,ignore\nuse std::cell::{UnsafeCell as TotallySafeCell};\nextern crate crossbeam;\nuse crossbeam::{spawn_unsafe as spawn};\n```", 
      "Known problems": "None."
    }, 
    "id": "unsafe_removed_from_name", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for unused labels.", 
      "Why is this bad": "Maybe the label should be used in which case there is an error in the\ncode or it should be removed.", 
      "Example": "```rust,ignore\nfn unused_label() {\n    'label: for i in 1..2 {\n        if i > 4 { continue }\n    }\n```", 
      "Known problems": "Hopefully none."
    }, 
    "id": "unused_label", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint warns about using `&vec![..]` when using `&[..]` would be possible.", 
      "Why is this bad": "This is less efficient.", 
      "Example": "```rust,ignore\nfoo(&vec![1, 2])\n```", 
      "Known problems": "None."
    }, 
    "id": "useless_vec", 
    "level": "Warn"
  }, 
  {
    "docs": {
      "What it does": "This lint checks for `0.0 / 0.0`.", 
      "Why is this bad": "It's less readable than `std::f32::NAN` or `std::f64::NAN`", 
      "Example": "```rust\n0.0f32 / 0.0\n```", 
      "Known problems": "None"
    }, 
    "id": "zero_divided_by_zero", 
    "level": "Warn"
  }
]