#![allow(clippy::manual_async_fn)]
#![warn(clippy::large_futures)]

// Note: large_futures are allowed here, as rustfix cannot actually fix this case.
// The reason we still keep it around is that it's used as a helper in other tests.
// See large_futures_unfixable.rs where this definition is demonstrated to emit a lint as well.
#[allow(clippy::large_futures)]
async fn big_fut(_arg: [u8; 1024 * 16]) {}

async fn wait() {
    let f = async {
        Box::pin(big_fut([0u8; 1024 * 16])).await;
        //~^ large_futures
    };
    Box::pin(f).await
    //~^ large_futures
}
async fn calls_fut(fut: impl std::future::Future<Output = ()>) {
    loop {
        Box::pin(wait()).await;
        //~^ large_futures

        if true {
            return fut.await;
        } else {
            Box::pin(wait()).await;
            //~^ large_futures
        }
    }
}

pub async fn test() {
    let fut = Box::pin(big_fut([0u8; 1024 * 16]));
    //~^ large_futures

    Box::pin(foo()).await;
    //~^ large_futures

    calls_fut(Box::pin(fut)).await;
    //~^ large_futures
}

pub fn foo() -> impl std::future::Future<Output = ()> {
    Box::pin(async {
        //~^ large_futures
        let x = [0i32; 1024 * 16];
        async {}.await;
        dbg!(x);
    })
}

pub async fn lines() {
    Box::pin(async {
        //~^ large_futures
        let x = [0i32; 1024 * 16];
        async {}.await;

        println!("{:?}", x);
    })
    .await;
}

// Note: large_futures are allowed here, as rustfix cannot actually fix this case.
pub async fn macro_expn() {
    macro_rules! macro_ {
        () => {
            Box::pin(async {
                //~^ large_futures
                let x = [0i32; 1024 * 16];
                async {}.await;
                println!("macro: {:?}", x);
            })
        };
    }
    macro_!().await
}

fn main() {}
