#![warn(clippy::str_to_string)]

fn main() {
    let hello: String = "hello world".to_owned();
    //~^ str_to_string

    let msg: &str = &hello[..];
    msg.to_owned();
    //~^ str_to_string
}

fn issue16271(key: &[u8]) {
    macro_rules! t {
        ($e:expr) => {
            match $e {
                Ok(e) => e,
                Err(e) => panic!("{} failed with {}", stringify!($e), e),
            }
        };
    }

    let _value: String = t!(str::from_utf8(key)).to_owned();
    //~^ str_to_string
}

struct GenericWrapper<T>(T);

impl<T> GenericWrapper<T> {
    fn mapper<U, F: FnOnce(T) -> U>(self, f: F) -> U {
        f(self.0)
    }
}

fn issue16511(x: Option<&str>) {
    let _: Option<String> = x.map(str::to_owned);
    //~^ str_to_string

    let _: Option<String> = x.map(str::to_owned);
    //~^ str_to_string

    // This should not trigger the lint because ToOwned::to_owned would produce &str, not String.
    let _: Vec<String> = ["a", "b"].iter().map(ToString::to_string).collect();

    fn mapper<F: Fn(&str) -> String>(f: F) -> String {
        f("hello")
    }
    let _: String = mapper(str::to_owned);
    //~^ str_to_string

    let w: GenericWrapper<&str> = GenericWrapper("hello");
    let _: String = w.mapper(str::to_owned);
    //~^ str_to_string
}

// No lint: non-str types should not trigger str_to_string. See #16569
fn no_lint_non_str() {
    let _: Vec<String> = [1, 2].iter().map(i32::to_string).collect();
}
