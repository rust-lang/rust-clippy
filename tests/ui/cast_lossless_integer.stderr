error: casts from `u8` to `u16` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:9:5
   |
LL |     0u8 as u16;
   |     ^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
   = note: `-D clippy::cast-lossless` implied by `-D warnings`
   = help: to override `-D warnings` add `#[allow(clippy::cast_lossless)]`
help: use `u16::from` instead
   |
LL -     0u8 as u16;
LL +     u16::from(0u8);
   |

error: casts from `u8` to `i16` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:12:5
   |
LL |     0u8 as i16;
   |     ^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i16::from` instead
   |
LL -     0u8 as i16;
LL +     i16::from(0u8);
   |

error: casts from `u8` to `u32` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:15:5
   |
LL |     0u8 as u32;
   |     ^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `u32::from` instead
   |
LL -     0u8 as u32;
LL +     u32::from(0u8);
   |

error: casts from `u8` to `i32` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:18:5
   |
LL |     0u8 as i32;
   |     ^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i32::from` instead
   |
LL -     0u8 as i32;
LL +     i32::from(0u8);
   |

error: casts from `u8` to `u64` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:21:5
   |
LL |     0u8 as u64;
   |     ^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `u64::from` instead
   |
LL -     0u8 as u64;
LL +     u64::from(0u8);
   |

error: casts from `u8` to `i64` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:24:5
   |
LL |     0u8 as i64;
   |     ^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i64::from` instead
   |
LL -     0u8 as i64;
LL +     i64::from(0u8);
   |

error: casts from `u8` to `u128` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:27:5
   |
LL |     0u8 as u128;
   |     ^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `u128::from` instead
   |
LL -     0u8 as u128;
LL +     u128::from(0u8);
   |

error: casts from `u8` to `i128` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:30:5
   |
LL |     0u8 as i128;
   |     ^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i128::from` instead
   |
LL -     0u8 as i128;
LL +     i128::from(0u8);
   |

error: casts from `u16` to `u32` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:33:5
   |
LL |     0u16 as u32;
   |     ^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `u32::from` instead
   |
LL -     0u16 as u32;
LL +     u32::from(0u16);
   |

error: casts from `u16` to `i32` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:36:5
   |
LL |     0u16 as i32;
   |     ^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i32::from` instead
   |
LL -     0u16 as i32;
LL +     i32::from(0u16);
   |

error: casts from `u16` to `u64` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:39:5
   |
LL |     0u16 as u64;
   |     ^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `u64::from` instead
   |
LL -     0u16 as u64;
LL +     u64::from(0u16);
   |

error: casts from `u16` to `i64` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:42:5
   |
LL |     0u16 as i64;
   |     ^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i64::from` instead
   |
LL -     0u16 as i64;
LL +     i64::from(0u16);
   |

error: casts from `u16` to `u128` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:45:5
   |
LL |     0u16 as u128;
   |     ^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `u128::from` instead
   |
LL -     0u16 as u128;
LL +     u128::from(0u16);
   |

error: casts from `u16` to `i128` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:48:5
   |
LL |     0u16 as i128;
   |     ^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i128::from` instead
   |
LL -     0u16 as i128;
LL +     i128::from(0u16);
   |

error: casts from `u32` to `u64` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:51:5
   |
LL |     0u32 as u64;
   |     ^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `u64::from` instead
   |
LL -     0u32 as u64;
LL +     u64::from(0u32);
   |

error: casts from `u32` to `i64` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:54:5
   |
LL |     0u32 as i64;
   |     ^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i64::from` instead
   |
LL -     0u32 as i64;
LL +     i64::from(0u32);
   |

error: casts from `u32` to `u128` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:57:5
   |
LL |     0u32 as u128;
   |     ^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `u128::from` instead
   |
LL -     0u32 as u128;
LL +     u128::from(0u32);
   |

error: casts from `u32` to `i128` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:60:5
   |
LL |     0u32 as i128;
   |     ^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i128::from` instead
   |
LL -     0u32 as i128;
LL +     i128::from(0u32);
   |

error: casts from `u64` to `u128` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:63:5
   |
LL |     0u64 as u128;
   |     ^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `u128::from` instead
   |
LL -     0u64 as u128;
LL +     u128::from(0u64);
   |

error: casts from `u64` to `i128` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:66:5
   |
LL |     0u64 as i128;
   |     ^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i128::from` instead
   |
LL -     0u64 as i128;
LL +     i128::from(0u64);
   |

error: casts from `i8` to `i16` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:69:5
   |
LL |     0i8 as i16;
   |     ^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i16::from` instead
   |
LL -     0i8 as i16;
LL +     i16::from(0i8);
   |

error: casts from `i8` to `i32` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:72:5
   |
LL |     0i8 as i32;
   |     ^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i32::from` instead
   |
LL -     0i8 as i32;
LL +     i32::from(0i8);
   |

error: casts from `i8` to `i64` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:75:5
   |
LL |     0i8 as i64;
   |     ^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i64::from` instead
   |
LL -     0i8 as i64;
LL +     i64::from(0i8);
   |

error: casts from `i8` to `i128` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:78:5
   |
LL |     0i8 as i128;
   |     ^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i128::from` instead
   |
LL -     0i8 as i128;
LL +     i128::from(0i8);
   |

error: casts from `i16` to `i32` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:81:5
   |
LL |     0i16 as i32;
   |     ^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i32::from` instead
   |
LL -     0i16 as i32;
LL +     i32::from(0i16);
   |

error: casts from `i16` to `i64` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:84:5
   |
LL |     0i16 as i64;
   |     ^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i64::from` instead
   |
LL -     0i16 as i64;
LL +     i64::from(0i16);
   |

error: casts from `i16` to `i128` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:87:5
   |
LL |     0i16 as i128;
   |     ^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i128::from` instead
   |
LL -     0i16 as i128;
LL +     i128::from(0i16);
   |

error: casts from `i32` to `i64` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:90:5
   |
LL |     0i32 as i64;
   |     ^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i64::from` instead
   |
LL -     0i32 as i64;
LL +     i64::from(0i32);
   |

error: casts from `i32` to `i128` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:93:5
   |
LL |     0i32 as i128;
   |     ^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i128::from` instead
   |
LL -     0i32 as i128;
LL +     i128::from(0i32);
   |

error: casts from `i64` to `i128` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:96:5
   |
LL |     0i64 as i128;
   |     ^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i128::from` instead
   |
LL -     0i64 as i128;
LL +     i128::from(0i64);
   |

error: casts from `u8` to `u16` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:100:13
   |
LL |     let _ = (1u8 + 1u8) as u16;
   |             ^^^^^^^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `u16::from` instead
   |
LL -     let _ = (1u8 + 1u8) as u16;
LL +     let _ = u16::from(1u8 + 1u8);
   |

error: casts from `i8` to `i64` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:103:13
   |
LL |     let _ = 1i8 as I64Alias;
   |             ^^^^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `I64Alias::from` instead
   |
LL -     let _ = 1i8 as I64Alias;
LL +     let _ = I64Alias::from(1i8);
   |

error: casts from `u8` to `u16` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:106:18
   |
LL |     let _: u16 = 0u8 as _;
   |                  ^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `Into::into` instead
   |
LL -     let _: u16 = 0u8 as _;
LL +     let _: u16 = 0u8.into();
   |

error: casts from `i8` to `i16` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:109:18
   |
LL |     let _: i16 = -1i8 as _;
   |                  ^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `Into::into` instead
   |
LL -     let _: i16 = -1i8 as _;
LL +     let _: i16 = (-1i8).into();
   |

error: casts from `u8` to `u16` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:112:18
   |
LL |     let _: u16 = (1u8 + 2) as _;
   |                  ^^^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `Into::into` instead
   |
LL -     let _: u16 = (1u8 + 2) as _;
LL +     let _: u16 = (1u8 + 2).into();
   |

error: casts from `u16` to `u32` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:115:18
   |
LL |     let _: u32 = 1i8 as u16 as _;
   |                  ^^^^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `Into::into` instead
   |
LL -     let _: u32 = 1i8 as u16 as _;
LL +     let _: u32 = (1i8 as u16).into();
   |

error: casts from `i8` to `i32` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:150:13
   |
LL |     let _ = sign_cast!(x, u8, i8) as i32;
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i32::from` instead
   |
LL -     let _ = sign_cast!(x, u8, i8) as i32;
LL +     let _ = i32::from(sign_cast!(x, u8, i8));
   |

error: casts from `i8` to `i32` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:153:13
   |
LL |     let _ = (sign_cast!(x, u8, i8) + 1) as i32;
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `i32::from` instead
   |
LL -     let _ = (sign_cast!(x, u8, i8) + 1) as i32;
LL +     let _ = i32::from(sign_cast!(x, u8, i8) + 1);
   |

error: casts from `u8` to `u32` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:160:13
   |
LL |             1u8 as u32
   |             ^^^^^^^^^^
...
LL |     let _ = in_macro!();
   |             ----------- in this macro invocation
   |
   = help: an `as` cast can become silently lossy if the types change in the future
   = note: this error originates in the macro `in_macro` (in Nightly builds, run with -Z macro-backtrace for more info)
help: use `u32::from` instead
   |
LL -             1u8 as u32
LL +             u32::from(1u8)
   |

error: casts from `u8` to `u32` can be expressed infallibly using `From`
  --> tests/ui/cast_lossless_integer.rs:175:13
   |
LL |     let _ = 0u8 as ty!();
   |             ^^^^^^^^^^^^
   |
   = help: an `as` cast can become silently lossy if the types change in the future
help: use `<ty!()>::from` instead
   |
LL -     let _ = 0u8 as ty!();
LL +     let _ = <ty!()>::from(0u8);
   |

error: aborting due to 40 previous errors

