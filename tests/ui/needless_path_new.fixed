#![warn(clippy::needless_path_new)]

use std::fs;
use std::path::Path;

fn takes_path(_: &Path) {}
fn takes_impl_path(_: impl AsRef<Path>) {}
fn takes_path_and_impl_path(_: &Path, _: impl AsRef<Path>) {}
fn takes_two_impl_paths_with_the_same_generic<P: AsRef<Path>>(_: P, _: P) {}
fn takes_two_impl_paths_with_different_generics<P: AsRef<Path>, Q: AsRef<Path>>(_: P, _: Q) {}

struct Foo;

impl Foo {
    fn takes_path(_: &Path) {}
    fn takes_self_and_path(&self, _: &Path) {}
    fn takes_path_and_impl_path(_: &Path, _: impl AsRef<Path>) {}
    fn takes_self_and_path_and_impl_path(&self, _: &Path, _: impl AsRef<Path>) {}
}

fn main() {
    let f = Foo;

    fs::write("foo.txt", "foo"); //~ needless_path_new

    fs::copy(
        "foo", //~ needless_path_new
        "bar", //~ needless_path_new
    );

    Foo::takes_path(Path::new("foo"));

    f.takes_self_and_path_and_impl_path(
        Path::new("foo"),
        "bar", //~ needless_path_new
    );

    // We can and should change both independently
    takes_two_impl_paths_with_different_generics(
        "foo", //~ needless_path_new
        "bar", //~ needless_path_new
    );

    let a = takes_impl_path;
    a("foo.txt"); //~ needless_path_new

    // Don't lint

    takes_path(Path::new("foo"));

    // The paramater that _could_ be passed directly, was;
    // The parameter that could't, wasn't
    takes_path_and_impl_path(Path::new("foo"), "bar");
    Foo::takes_path_and_impl_path(Path::new("foo"), "bar");
    f.takes_self_and_path_and_impl_path(Path::new("foo"), "bar");

    // We are conservative and don't suggest changing a parameter
    // if it contains a generic type used elsewhere in the function
    takes_two_impl_paths_with_the_same_generic(Path::new("foo"), Path::new("bar"));

    // The type ascription specifies `Path`, not just `impl AsRef<Path>`
    let _: Option<&Path> = Some(Path::new("foo"));

    // The return type requires `Path`, not just `impl AsRef<Path>`
    fn foo() -> Option<&'static Path> {
        Some(Path::new("foo.txt"))
    }
}
