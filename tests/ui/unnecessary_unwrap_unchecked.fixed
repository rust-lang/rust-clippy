//@aux-build:unnecessary_unwrap_unchecked_helper.rs
//@aux-build:proc_macros.rs
#![warn(clippy::unnecessary_unwrap_unchecked)]

use proc_macros::{external, with_span};

#[rustfmt::skip]
use unnecessary_unwrap_unchecked_helper::{lol, kek};

mod b {
    pub fn test_fn() -> Option<u32> {
        Some(0)
    }

    pub unsafe fn test_fn_unchecked() -> u32 {
        0
    }
}

fn test_fn() -> Option<u32> {
    Some(0)
}

unsafe fn test_fn_unchecked() -> u32 {
    0
}

struct A;

impl A {
    fn a(&self) -> Option<u32> {
        Some(0)
    }

    unsafe fn a_unchecked(&self) -> u32 {
        0
    }

    fn an_assoc_fn() -> Option<u32> {
        Some(0)
    }

    unsafe fn an_assoc_fn_unchecked() -> u32 {
        0
    }
}

struct B;

impl B {
    fn b(&self) -> Option<u32> {
        Some(0)
    }
}

impl B {
    unsafe fn b_unchecked(&self) -> u32 {
        0
    }
}

fn main() {
    let string_slice = unsafe { std::str::from_utf8_unchecked(&[]) };
    //~^ unnecessary_unwrap_unchecked
    let a = unsafe { A::a_unchecked(&A) };
    //~^ unnecessary_unwrap_unchecked
    let a = unsafe {
        let a = A;
        a.a_unchecked()
    };
    //~^^ unnecessary_unwrap_unchecked
    let an_assoc_fn = unsafe { A::an_assoc_fn_unchecked() };
    //~^ unnecessary_unwrap_unchecked
    let extern_fn = unsafe { unnecessary_unwrap_unchecked_helper::lol_unchecked() };
    //~^ unnecessary_unwrap_unchecked
    let extern_fn_qualified = unsafe { unnecessary_unwrap_unchecked_helper::lol_unchecked() };
    //~^ unnecessary_unwrap_unchecked
    let local_fn = unsafe { b::test_fn_unchecked() };
    //~^ unnecessary_unwrap_unchecked

    // Don't lint: unlike `kek`, `kek_unchecked` isn't accessible from here
    let extern_pub_fn = unsafe { kek().unwrap_unchecked() };

    // Don't lint: `B::b` and `B::b_unchecked` come from distinct impl blocks
    // (even though that wouldn't actually make the suggestion invalid in this case)
    let b = unsafe {
        let b = B;
        b.b().unwrap_unchecked()
    };

    macro_rules! local {
        () => {{
            unsafe { ::std::str::from_utf8(&[]).unwrap_unchecked() };
        }};
    }
    local!();
    external! {
        unsafe { std::str::from_utf8(&[]).unwrap_unchecked() };
    }
    with_span! {
        span
        unsafe { std::str::from_utf8(&[]).unwrap_unchecked() };
    }
}
