//@run-rustfix
//@aux-build:proc_macros.rs:proc-macro
#![allow(clippy::default_constructed_unit_structs, clippy::no_effect, unused)]
#![warn(clippy::trivial_default_constructed_types)]
#![feature(generic_arg_infer)]

#[macro_use]
extern crate proc_macros;

use std::sync::atomic::{AtomicBool, AtomicI8, AtomicPtr, AtomicU8};

#[derive(Default)]
struct OtherType;

impl Default for &OtherType {
    fn default() -> Self {
        &OtherType
    }
}

#[derive(Default)]
struct OtherTypeWithParams<T, E>(T, E);

struct NotDefault;

impl NotDefault {
    pub fn default() -> u32 {
        0
    }
}

fn main() {
    0u32;
    let _: Option<u32> = None;
    let _ = None::<u32>;
    let _: (usize,) = (0usize,);
    let _: u32 = 0u32;
    let _: (u32, _) = (0u32, 0u32);
    let _: [u32; 10] = [0u32; 10];
    let _: [u32; 10] = [0u32; _];
    ();
    let _: [u32; 10] = [0u32; 10];
    let _: [f32; 1000] = [0.0f32; 1000];
    let _ = &"";
    let _ = false;
    let _ = (0u32, 0u32, false);
    let _ = std::sync::atomic::AtomicBool::new(false);
    let _ = std::sync::atomic::AtomicI8::new(0);
    let _ = std::sync::atomic::AtomicPtr::new(std::ptr::null_mut::<u32>());
    let _ = std::sync::atomic::AtomicPtr::new(std::ptr::null_mut::<()>());
    let _ = std::sync::atomic::AtomicU8::new(0);
    let _ = &[0u8];
    let _ = &mut [0u8];
    let _ = [0u8; 31];
    let _: (usize, OtherType) = (0usize, <OtherType>::default());
    let _: &OtherType = <&OtherType>::default();
    let _: (usize, OtherTypeWithParams<u32, u16>) = (0usize, <OtherTypeWithParams::<u32, u16>>::default());
    let _ = '\x00';
    // Do not lint
    let _ = NotDefault::default();
    let _ = <(u32, u32, bool, &str)>::default();

    external! {
        u32::default();
        let _: Option<u32> = Option::default();
        let _: (usize,) = Default::default();
        <()>::default();
        let _: [u32; 10] = Default::default();
        let _: [f32; 1000] = [Default::default(); 1000];
        let _ = <&str>::default();
        let _ = bool::default();
        let _ = char::default();
    }
    with_span! {
        span
        u32::default();
        let _: Option<u32> = Option::default();
        let _: (usize,) = Default::default();
        <()>::default();
        let _: [u32; 10] = Default::default();
        let _: [f32; 1000] = [Default::default(); 1000];
        let _ = <&str>::default();
        let _ = bool::default();
        let _ = char::default();
    }
}
